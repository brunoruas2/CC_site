"use strict";(self.webpackChunkciencia_computacao=self.webpackChunkciencia_computacao||[]).push([[3631],{26213:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"202510070652","title":"OOP - Interface e Implementa\xe7\xe3o","description":"OOPSOLID - Interface Segregation Principle (ISP)SOLID - Dependency Inversion Principle (DIP)","source":"@site/zettel/202510070652.mdx","sourceDirName":".","slug":"/202510070652","permalink":"/CC_site/zettel/202510070652","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"OOP","permalink":"/CC_site/zettel/tags/oop"}],"version":"current","frontMatter":{"title":"OOP - Interface e Implementa\xe7\xe3o","sidebar_label":"202510070652 - OOP - Interface e Implementa\xe7\xe3o","tags":["OOP"],"date":"2025-10-07T00:00:00.000Z"},"sidebar":"zettelSidebar","previous":{"title":"202510070712 - OOP - Heran\xe7a e Composi\xe7\xe3o","permalink":"/CC_site/zettel/202510070712"},"next":{"title":"202510070636 - OOP - Modificadores de Acesso","permalink":"/CC_site/zettel/202510070636"}}');var o=t(74848),s=t(28453);const r={title:"OOP - Interface e Implementa\xe7\xe3o",sidebar_label:"202510070652 - OOP - Interface e Implementa\xe7\xe3o",tags:["OOP"],date:new Date("2025-10-07T00:00:00.000Z")},i="OOP - Interface e Implementa\xe7\xe3o",c={},l=[{value:"Refer\xeancias",id:"refer\xeancias",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"oop---interface-e-implementa\xe7\xe3o",children:"OOP - Interface e Implementa\xe7\xe3o"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/zettel/202510030654",children:"OOP"}),(0,o.jsx)(n.a,{href:"/zettel/202510170631",children:"SOLID - Interface Segregation Principle (ISP)"}),(0,o.jsx)(n.a,{href:"/zettel/202510170652",children:"SOLID - Dependency Inversion Principle (DIP)"})]}),"\n",(0,o.jsxs)(n.p,{children:["Uma interface define contratos (parecido com uma classe abstrata) mas sem definir nenhuma implementa\xe7\xe3o. A principal diferen\xe7a \xe9 que a classe abstrata ",(0,o.jsx)(n.strong,{children:"pode"})," implementar algo se ela quiser, enquanto uma interface n\xe3o tem nada de implementa\xe7\xe3o al\xe9m do nome do m\xe9todo, o retorno e os params das fun\xe7\xf5es."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public interface IRepo\n{\n\tvoid GetItem();\n}\n\npublic class Repo : IRepo\n{\n\tpublic void GetItem()  { // implementacao  }\n}\n\npublic class RepoFake : IRepo\n{\n\tpublic void GetItem() { // faz nada }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Podemos usar a classe de reposit\xf3rio direto em uma classe instanciando um objeto dele dentro do c\xf3digo mas isso \xe9 ruim porque aumenta o acoplamento. Se eu mudar a classe ",(0,o.jsx)(n.code,{children:"Repo"}),", existe uma grande chance de quebrar a implementa\xe7\xe3o na classe abaixo. Al\xe9m disso, a cria\xe7\xe3o de teste de unidade fica muito dif\xedcil porque eu vou precisar lidar com o comportamento do reposit\xf3rio. Chamamos esse m\xe9todo de ",(0,o.jsx)(n.strong,{children:"composi\xe7\xe3o concreta"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class ImplementaRuim\n{\n\tpublic void MetodoRuim()\n\t{\n\t\tvar repo = new Repo();\n\t\trepo.GetItem();\n\t}\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Para melhorar isso, podemos usar a ",(0,o.jsx)(n.a,{href:"/zettel/202510181406",children:"DI - Inje\xe7\xe3o de Depend\xeancia"})," de modo que eu injeto o reposit\xf3rio no construtor e uso ele sem aumentar o acoplamento. Chamamos essa t\xe9cnica de ",(0,o.jsx)(n.strong,{children:"composi\xe7\xe3o por interface"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class ImplementaBom\n{\n\tprivate readonly IRepo _repo;\n\t\n\tpublic ImplementaBom(IRepo repo) { _repo = repo; }\n\t\n\tpublic void MetodoBom() { _repo.GetItem(); }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Isso facilita muito os testes de unidade porque podemos passar qualquer classe mockada no construtor da classe de teste abstraindo totalmente a camada de reposit\xf3rio."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class TesteUniade\n{\n\tpublic void Teste1()\n\t{\n\t\t// aqui eu posso injetar a classe RepoFake o que torna a criacao\n\t\t// de testes MUITO mais simples\n\t\tvar teste = new ImplementaBom(RepoFake)\n\t\t\n\t\t// resto do teste\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"refer\xeancias",children:"Refer\xeancias"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://desenvolvedor.io/formacao/arquiteto-de-software",children:"Desenvolvedor.io - Curso Arquitetura"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var a=t(96540);const o={},s=a.createContext(o);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);