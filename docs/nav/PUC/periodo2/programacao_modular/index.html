<!doctype html>
<html>
    <head>
                <title>Programação Modular - Ciência da Computação</title>

            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">

            
            <link rel="canonical" href="https://brunoruas2.github.io/CC_site/nav/PUC/periodo2/programacao_modular/">
            

            
                <link  rel="icon" type="image/x-icon" href="../../../../assets/logo.png">
            
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
                        <script>hljs.initHighlightingOnLoad();</script>
            <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700">
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="../../../../assets/css/bootstrap.min.css">
            <link rel="stylesheet" href="../../../../assets/css/main.min.css">
                <link href="../../../../css/custom.css" rel="stylesheet">
                <script src="../../../../javascripts/config.js"></script>
                <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
                <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
                <script src="../../../../search/main.js"></script>

            
                
            
    </head>

    <body>
        <div class="container py-3">
            <header>
                    <!-- block header -->
<nav class="navbar navbar-expand-xl border-bottom">
    <div class="container-fluid">
        
            <img class="logo" src="../../../../assets/logo.png">
        

        
            <span class="normal fs-4 title-color site-name" id="component-site-name" style="text-transform: uppercase;">Ciência da Computação</span>
        

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsMenu"
            aria-controls="navbarsMenu" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse flex-column ml-auto" id="navbarsMenu">
            <ul class="navbar-nav">

                <!-- block menu -->
                <li class="nav-item">
                    <!-- block menu -->
    
        <li class="nav-item" id="component-menu">
            <ul class="navbar-nav">
                        <li class="nav-item">
                            <a class="
                            nav-link text-gray text-decoration-none" href="../../../..">[Home]</a>
                        </li>
                        <li class="nav-item dropdown">
                            <a class=" active 
                            nav-link dropdown-toggle text-decoration-none" href="#" data-bs-toggle="dropdown">[PUC-MG]</a>
                            <ul class="dropdown-menu">
                                    <!-- block dropdown-menu -->
    <li>
        <a href="../../Sobre/puc/" class="dropdown-item text-decoration-none ">Tecnólogo</a>
    </li>
<!-- endblock -->
                                    <!-- block dropdown-menu -->
    <li>
        <a class="dropdown-item text-decoration-none" href="#">Período 1 &raquo;</a>
        <ul class="submenu dropdown-menu">
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo1/algoritmos_e_abstracao/" class="dropdown-item text-decoration-none ">Algoritmo e Abstração</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo1/algoritmos_e_logica/" class="dropdown-item text-decoration-none ">Algoritmo e Lógica</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo1/desenvolvimento_web/" class="dropdown-item text-decoration-none ">Desenvolvimento Web Frontend</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo1/matematica_basica/" class="dropdown-item text-decoration-none ">Matemática Básica</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo1/organizacao_computadores/" class="dropdown-item text-decoration-none ">Organização de Computadores</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo1/fundamentos_eng_soft/" class="dropdown-item text-decoration-none ">Fundamentos de Eng. de Software</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo1/pensamento_comp/" class="dropdown-item text-decoration-none ">Pensamento Computacional</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo1/logica_comp/" class="dropdown-item text-decoration-none ">Lógica Computacional</a>
    </li>
<!-- endblock -->
        </ul>
    </li>
<!-- endblock -->
                                    <!-- block dropdown-menu -->
    <li>
        <a class="dropdown-item text-decoration-none" href="#">Período 2 &raquo;</a>
        <ul class="submenu dropdown-menu">
                <!-- block dropdown-menu -->
    <li>
        <a href="../algoritmo_estrutura_dados/" class="dropdown-item text-decoration-none ">Algoritmos e Estrutura de Dados</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../" class="dropdown-item text-decoration-none ">Modelagem de Dados</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../engenharia_requisitos/" class="dropdown-item text-decoration-none ">Engenharia de Requisitos</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../design_interacao/" class="dropdown-item text-decoration-none ">Design de Interação</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="./" class="dropdown-item text-decoration-none  active ">Programação Modular</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../dev_web_backend/" class="dropdown-item text-decoration-none ">Desenvolvimento Web Back-End</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../" class="dropdown-item text-decoration-none ">Fundamentos de Redes de Computadores</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../" class="dropdown-item text-decoration-none ">Manipulação da Dados com SQL</a>
    </li>
<!-- endblock -->
        </ul>
    </li>
<!-- endblock -->
                                    <!-- block dropdown-menu -->
    <li>
        <a class="dropdown-item text-decoration-none" href="#">Período 3 &raquo;</a>
        <ul class="submenu dropdown-menu">
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo3/" class="dropdown-item text-decoration-none ">Modelagem e Gestão de Processos</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo3/estat_desc/" class="dropdown-item text-decoration-none ">Estatística Descritiva</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo3/dev_mobile/" class="dropdown-item text-decoration-none ">Desenvolvimento de Aplicações Móveis</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo3/gerencia_projetos/" class="dropdown-item text-decoration-none ">Gerência de Projetos de TI</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo3/gerencia_config/" class="dropdown-item text-decoration-none ">Gerência de Configuração</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo3/qualidade_processos/" class="dropdown-item text-decoration-none ">Qualidade de Processos de Software</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo3/gerencia_requisitos/" class="dropdown-item text-decoration-none ">Gerência de Requisitos de Software</a>
    </li>
<!-- endblock -->
        </ul>
    </li>
<!-- endblock -->
                                    <!-- block dropdown-menu -->
    <li>
        <a class="dropdown-item text-decoration-none" href="#">Período 4 &raquo;</a>
        <ul class="submenu dropdown-menu">
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo4/" class="dropdown-item text-decoration-none ">Cloud Computing</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo4/" class="dropdown-item text-decoration-none ">Projeto de Software</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo4/arquitetura_distribuida/" class="dropdown-item text-decoration-none ">Arquitetura de Software Distribuído</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo4/" class="dropdown-item text-decoration-none ">APIs e Web Services</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo4/" class="dropdown-item text-decoration-none ">Teste de Software</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo4/" class="dropdown-item text-decoration-none ">Banco de Dados NoSQL</a>
    </li>
<!-- endblock -->
        </ul>
    </li>
<!-- endblock -->
                                    <!-- block dropdown-menu -->
    <li>
        <a class="dropdown-item text-decoration-none" href="#">Período 5 &raquo;</a>
        <ul class="submenu dropdown-menu">
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo5/seguranca/" class="dropdown-item text-decoration-none ">Segurança Aplicada ao Desenvolvimento</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo5/" class="dropdown-item text-decoration-none ">Compliance em TI</a>
    </li>
<!-- endblock -->
                <!-- block dropdown-menu -->
    <li>
        <a href="../../periodo5/" class="dropdown-item text-decoration-none ">Implantação de Solução de TI</a>
    </li>
<!-- endblock -->
        </ul>
    </li>
<!-- endblock -->
                            </ul>
                        </li>
                        <li class="nav-item">
                            <a class="
                            nav-link text-gray text-decoration-none" href="../../../tech/">[Sobre]</a>
                        </li>
            </ul>
        </li>
<!-- endblock -->
                </li>
                <!-- endblock -->

                <!-- block search -->
                <li class="nav-item">
                    <a class="collapsed" data-bs-toggle="collapse" href="#collapseExample" role="button" aria-expanded="false" aria-controls="collapseExample">
                        <div class="md-search-icon">
                            <i class="fa fa-search" aria-hidden="true"></i>
                        </div>
                    </a>
                </li>
                <!--  endblock -->

                <!-- block source -->
                <li class="nav-item">
                    
                        
                            <!-- block source -->
<div class="md-source source-detail">
  <div class="md-source-repo-icon">
    <i class="fa fa-github-alt" aria-hidden="true"></i>
  </div>

  <div class="md-source-repo-url">
    <a href="https://github.com/brunoruas2/ciencia_computacao" class="md-source">
      brunoruas2/ciencia_computacao
    </a>

    <ul class="md-source-repo-text">
      <li>
        <i class="fa fa-tag" aria-hidden="true"></i>
        <img alt="GitHub tag (latest by date)"
          src="https://img.shields.io/github/v/tag/brunoruas2/ciencia_computacao?color=white&label=%20&style=flat-square">
      </li>

      <li>
        <i class="fa fa-star" aria-hidden="true"></i>
        <img alt="GitHub Repo stars"
          src="https://img.shields.io/github/stars/brunoruas2/ciencia_computacao?color=white&label=%20&style=flat-square">
      </li>

      <li>
        <i class="fa fa-code-fork" aria-hidden="true"></i>
        <img alt="GitHub forks"
          src="https://img.shields.io/github/forks/brunoruas2/ciencia_computacao?color=white&label=%20&style=flat-square">
      </li>
    </ul>
  </div>

</div>
<!--  endblock -->
                        
                    
                </li>
                <!--  endblock -->
            </ul>
        </div>
    </div>
</nav>
<!--  endblock -->
            </header>

            <main><!-- block search -->
<div class="collapse" id="collapseExample">
    <div role="search" class="search-box">
        <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
            <input type="text" name="q" class="search-query"
            placeholder="Search docs" title="Type search term here" />
        </form>
    </div>
</div>
<!-- endblock -->
                    <!-- block content -->
<section class="container post">
    <article>
        <header>
            
                <h1 class="bold title" id="component-title">Programação Modular</h1>
            
        </header>
        <p><h2 id="assuntos">Assuntos</h2>
<ul>
<li><a href="#programacao-orientada-a-objetos"><strong>Programação Orientada à Objetos</strong></a><ul>
<li><a href="#fatores-de-qualidade-de-software">Fatores de Qualidade de Software</a></li>
<li><a href="#classes-e-objetos">Classes e Objetos</a></li>
<li><a href="#encapsulamento">Encapsulamento</a></li>
<li><a href="#herança">Herança</a></li>
</ul>
</li>
<li><a href="#polimorfismo-e-principios-do-projeto-modular"><strong>Polimorfismo e Princípios do Projeto Modular</strong></a><ul>
<li><a href="#polimorfismo-de-inclusao">Polimorfismo de Inclusão</a></li>
<li><a href="#polimorfismo-parametrico">Polimorfismo Paramétrico</a></li>
<li><a href="#projeto-orientado-para-objetos">Projeto Orientado para Objetos</a></li>
</ul>
</li>
<li><a href="#bibliografia"><strong>Bibliografia</strong></a></li>
</ul>
<h2 id="programacao-orientada-a-objetos">Programação Orientada à Objetos</h2>
<p>A essa altura já estamos cientes que podemos pensar em um algoritmo como uma sucessão de passos que finda na execução de um objetivo em tempo de processamento útil para um usuário. Antigamente, acreditava-se que todos os problemas poderiam ser expressos com o uso de apenas 3 estruturas de controle: comandos sequências, comandos de seleção (condicionais) e comandos de repetição (iterativos).</p>
<p>Nessa era, o foco estava apenas da completude do desafio proposto. A missão era resolver o problema por meio de um software.</p>
<p>Mas não demorou muito para as organizações perceberem que várias tarefas estavam presentes em diferentes problemas com apenas algumas alterações. Além disso, o custo e a complexidade dos problemas evolui e coisas como eficiência e padronização começaram a ficar mais relevantes no meio empresarial que já passava a se cristalizar em grandes corporações.</p>
<p>Para sanar essas necessidades, as linguagens de programação evoluíram e passaram a suportar abstrações como <strong>funções</strong> e <strong>procedimentos</strong>.</p>
<p>Podemos entender uma <strong>função</strong> como uma abstração de expressão que representam o mapeamento<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup> de entradas em um conjunto de resultado. O professor usa o exemplo da função fatorial:
<span class="arithmatex">\(n! = n * (n-1)!\)</span></p>
<p>Que pode ser escrito como uma função em c#
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Calculo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">fatorial</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fatorial</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="m">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">valor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">resultado</span><span class="p">;</span>
<span class="w">        </span><span class="n">Calculo</span><span class="w"> </span><span class="n">calc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Calculo</span><span class="p">();</span>
<span class="w">        </span><span class="n">resultado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calc</span><span class="p">.</span><span class="n">fatorial</span><span class="p">(</span><span class="n">valor</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;{0}! = {1}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">valor</span><span class="p">,</span><span class="w"> </span><span class="n">resultado</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<strong>Comentário:</strong> Tudo que usamos nesse programa acima foi aprendido na parte 1 desse material com apenas 1 exceção. Pode ser que para algumas pessoas seja estranho que na definição da função fatorial se faça uso da própria função que está sendo criada. Chamamos esse recurso de <strong>recursão</strong> e é usado bastante como ferramenta de solução de problemas matemáticos formais. Aqui tem um <a href="https://panda.ime.usp.br/pensepy/static/pensepy/12-Recursao/recursionsimple-ptbr.html">link</a> sobre essa técnica em linguagem de programação.</p>
<p>Além do conceito de função, as linguagens também evoluíram para o uso de <strong>procedimentos</strong> que podem ser entendidos como a abstração de comandos. É a representação de um conjunto de passos que resolve um tarefa. Diferente das funções que possuem um retorno, um procedimento pode ou não ter um resultado visível.</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MainClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Tarefa1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Executando tarefa 1&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Tarefa2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Executando tarefa 2&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">MenuPrincipal</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Escolha uma opção:&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;1. Tarefa 1\n2. Tarefa 2\n3. Sair&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&quot;Opção: &quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;1&quot;</span><span class="p">:</span>
<span class="w">                </span><span class="n">Tarefa1</span><span class="p">();</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;2&quot;</span><span class="p">:</span>
<span class="w">                </span><span class="n">Tarefa2</span><span class="p">();</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;3&quot;</span><span class="p">:</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">            </span><span class="k">default</span><span class="p">:</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="w"> </span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">MenuPrincipal</span><span class="p">())</span><span class="w"> </span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
Nós aprendemos na parte 1 do material que um tipo abstrato de dado é a construção de uma classe que possui dentro de si a lógica de estruturas e métodos necessários para a construção de uma solução otimizada de software.</p>
<p>Desse modo, podemos pensar em um <strong>Módulo</strong><sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup> como um tipo abstrato de dados que consegue internalizar a lógica de implementação dos seus elementos de modo a permitir que apenas alguns dos seus elementos sejam manipulados.</p>
<p>A vantagem de se encapsular a lógica é permitir que os arquivos de código se tornem mais legíveis porque toda a lógica das funções usadas está guardada nos arquivos de referência de cada módulo que foi carregado no começo do script, além disso, podemos desejar que certas partes do nosso código não estejam disponíveis para manipulação por parte do usuário. </p>
<p><strong>Comentário:</strong> Já vimos um pouco sobre escopo quando trabalhos tipos abstratos de dados.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Conta</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">_criacao</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">_saldo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Conta</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">saldoInicial</span><span class="p">,</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">criacao</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">_saldo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">saldoInicial</span><span class="p">;</span>
<span class="w">        </span><span class="n">_criacao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">criacao</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">DataCriacao</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">get</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">_criacao</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">Sacar</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">quantia</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_saldo</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">quantia</span><span class="p">)</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">ArgumentException</span><span class="p">(</span><span class="s">&quot;Saque maior que saldo.&quot;</span><span class="p">,</span><span class="s">&quot;quantia&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">_saldo</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">quantia</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">quantia</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Depositar</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">quantia</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">quantia</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">ArgumentException</span><span class="p">(</span><span class="s">&quot;Depósito deve ser positivo.&quot;</span><span class="p">,</span><span class="s">&quot;quantia&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">_saldo</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">quantia</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">GetSaldo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">_saldo</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MainClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="w"> </span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Conta</span><span class="w"> </span><span class="n">contaDoZe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Conta</span><span class="p">(</span><span class="m">1200</span><span class="p">,</span><span class="w"> </span><span class="n">Datetime</span><span class="p">.</span><span class="n">Now</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Saldo da Conta: {0:C2}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">contaDoZe</span><span class="p">.</span><span class="n">GetSaldo</span><span class="p">());</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">quantia</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">212</span><span class="p">;</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Sacar {0:C2} da conta.&quot;</span><span class="p">,</span><span class="n">quantia</span><span class="p">);</span>
<span class="w">        </span><span class="n">contaDoZe</span><span class="p">.</span><span class="n">Sacar</span><span class="p">(</span><span class="n">quantia</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Saldo na conta: {0:C2}&quot;</span><span class="p">,</span><span class="n">contaDoZe</span><span class="p">.</span><span class="n">GetSaldo</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Comentário:</strong> Se alguns de vocês tiveram dúvidas na linha onde o objeto <code>ContaDoZe</code> é criado pela passagem de dois parâmetros <code>Conta(1200,DateTime.Now)</code> é porque vocês se esqueceram do que aprendemos sobre <strong>construtores</strong>.</p>
<p><strong>Programação Orientada à Objetos</strong></p>
<p>Criado em 1967 por Alan Kay, o paradigma da programação orientada à objetos propõe uma mudança no modo de entendermos como um software é construído. A novidade foi a proposição de módulos independentes que não compartilham dados mas são capazes de se comunicarem (como se fossem células). O que permite o reaproveitamento de soluções e o acoplamento de diferentes objetos para a criação de ferramentas complexas e, ainda assim, cuja manutenção era mais fácil.</p>
<p><img alt="34-alan-kay.png" src="../../../../assets/imgs/34-alan-kay.png" /></p>
<p>Claro que existem novos riscos associados à mudança do paradigma. Por exemplo, chamamos de alto acoplamento a situação onde os módulos de um sistema são muito interdependentes e podem, com a falha crítica em algum deles, desencadear uma quebra generalizada na aplicação. Temos que focar sempre em soluções de baixo acoplamento.</p>
<p>Podemos ver como os conceitos vão evoluindo gradualmente. Primeiro aprendemos sobre estruturas de dados nativas. Depois aprendemos como criar nossas próprias estruras de dados. Em seguida, aprendemos sobre tipos abstratos de dados com classes e estruturas. Finalmente, agora vemos como esses conceitos foram usados para a construção de um paradigma novo de desenvolvimento denominado programação orientada à objetos.</p>
<h3 id="fatores-de-qualidade-de-software">Fatores de Qualidade de Software</h3>
<p>Várias vezes ao longo do material nós usamos termos como "software de qualidade" ou "programas bem construídos" ou alguma ideia similar. Agora, vamos definir mais claramente quais características uma solução de software precisa ter para ser digna de tal chancela.</p>
<p>A norma que rege esse consenso aplicado no mercado atualmente é a <a href="https://iso25000.com/index.php/en/iso-25000-standards/iso-25010">ISO/IEC 25010</a>. Essa norma divide os fatores de qualidade de um produto em 8 fatores de qualidade:</p>
<ul>
<li>Funcionalidade</li>
<li>Desempenho</li>
<li>Compatibilidade</li>
<li>Usabilidade</li>
<li>Confiabilidade</li>
<li>Segurança</li>
<li>Manutenibilidade</li>
<li>Portabilidade</li>
</ul>
<p>Como podemos ver, são vários critérios que são usados no trabalho de avaliação de uma solução. Além dessa classificação, podemos elencar os fatores em 2 grupos: fatores externos (relacionados com a dinâmica de interação dos usuários) e fatores internos (relacionados a dinâmica dos programadores com a aplicação).</p>
<p>Mesmo sabendo que todos os fatores são importantes, como estamos estudando esse conteúdo sob a perspectiva da programação modular, vamos nos ater apenas aos fatores que são impactados pela decisão de um projeto modular de aplicação.</p>
<h4 id="fatores-externos">Fatores Externos</h4>
<p>No que tange à experiência do usuário, podemos destacar algumas características que toda solução deve apresentar para ser considerada de qualidade.</p>
<p><strong>Correção:</strong> O sistema deve executar a atividade que foi previamente definida como objetivo para sua construção. Isso garante que ele funcionará como o previsto.</p>
<p><strong>Robustez:</strong> O sistema deve funcionar mesmo em condições anormais. Essa características está bastante relacionada à capacidade de lidar com erros e situações não previstas anteriormente pelo desenvolvimento.</p>
<p>Quando um sistema é bem construído, mesmo em situações de impossibilidade de funcionamento (como a ausência de internet em um sistema web) existem diferentes modos de lidar com essa limitação imposta ao funcionamento da aplicação. Um conceito que vale a pena aprendermos é o <a href="https://www.techtarget.com/searchnetworking/definition/graceful-degradation"><strong>graceful degradation</strong></a>. </p>
<p><strong>Adaptação a Novas Situações</strong></p>
<p>O desenvolvimento ágil trouxe várias mudanças de postura no planejamento e execução de um projeto de tecnologia. Como agora não é necessário saber todas as características do produto final, existe a possibilidade de novas funções e ferramentas surgirem ao longo do processo de criação inicialmente planejado.</p>
<p>Para se atender as demandas geradas por esse paradigma, os produtos gerados a cada etapa deve ter as seguintes propriedades:</p>
<p><strong>Extensabilidade:</strong> O sistema deve se adaptar a mudanças na sua especificação.</p>
<p><strong>Reusabiliadde:</strong> O sistema de ter módulos que podem ser aproveitadas em outras soluções. Permitindo uma maior produtividade e celeridade do processe de desenvolvimento.</p>
<p><strong>Compatibilidade:</strong> O sistema deve ter partes que são capazes de se comunicar entre si e com outros sistemas. Nesse contexto que os padrões de desenvolvimento e protocolos são tão relevantes.</p>
<p><strong>Desempenho</strong></p>
<p>Uma características muitíssimo relevante, principalmente em projetos escaláveis é a eficiência. Fazer bom uso do hardware economiza custos para o cliente e é uma das qualidades mais desejadas para empresas de grande monta.</p>
<p>Sempre devemos ter em mente que haverá um trade-off entre a capacidade de resolução dos problemas propostos e o consumo de poder de processamento disponível no momento. Um sistema deve fazer o que é desejado da melhor maneira possível.</p>
<p>No escopo da programação modular, como os módulos são autocontidos, no contexto de sistema muito complexos haverá, muito provavelmente, uma preferência pela correção e robustez (que garantem o resultado esperado) em detrimento da eficiência (que garante a otimização do uso dos recursos).</p>
<h4 id="fatores-internos">Fatores Internos</h4>
<p>Os fatores internos de qualidade de um software são aqueles relacionados às características percebidas pelos desenvolvedores e profissionais que farão a manutenção do programa.</p>
<p>Os principais fatores internos de qualidade de software são:</p>
<ul>
<li>Legibilidade</li>
<li>Manutenibilidade</li>
<li>Modularidade</li>
</ul>
<p>A Legibilidade pode ser entendia em dois componentes: <strong>inteligibilidade</strong> que é a facilidade de se entender a lógica implementada naquele código e a <strong>legibilidade</strong> que é a construção de códigos de maneira a facilitar a identificação dos tokens e operadores usados.</p>
<p>Pensando na necessidade de se padronizar o uso de estilo das linguagens de programação é que surgem os <strong>Coding Standards</strong> que padronizam várias práticas para tornar a legibilidade das linguagens mais eficiente no seu meio de uso. Um bom programador sempre está com os padrões das linguagens que utiliza em dia.</p>
<p>A Manutenibilidade é a facilidade de se modificar e corrigir problemas encontrados na solução. Em uma estrutura modular é comum ter que identificar qual módulo está apresentando problemas e prosseguir com a correção da lógica que está gerando o problema.</p>
<p>A Modularidade é relacionada a divisão do sistema. Um módulo encapsula a lógica de uma determinada ação do sistema e torna o gerenciamento da solução mais eficiente porque divide em vários arquivos menores o que antigamente ficaria em um único arquivo texto de difícil entendimento. Esse fator é regido por dois pressupostos essenciais: princípio da unidade funcional (uma função por módulo) e coesão (cada módulo tem tudo que precisa para implementar a sua função).</p>
<h3 id="classes-e-objetos">Classes e Objetos</h3>
<h4 id="atributos-e-metodos">Atributos e Métodos</h4>
<p>Finalmente temos todos os conceitos necessários para aprendermos como programar usando o paradigma orientado à objetos. A principal postura que devemos ter é a de procurar abstrair o mundo real em objetos que são entidades autocontidas que possuem 3 características:</p>
<ul>
<li>Estado</li>
<li>Comportamento</li>
<li>Identidade</li>
</ul>
<p>Chamamos de <strong>Classe</strong> a coleção de objetos que compartilham as mesmas propriedades e comportamentos.</p>
<p>Agora vamos relembrar o que já aprendemos lá em Algoritmos e Abstração de dados.</p>
<p>Podemos definir uma classe em c# para um tipo de produto qualquer do seguinte modo:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Produto</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emEstoque</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">quantidade</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
A diferença agora é que sabemos o que é uma classe do ponto de vista dos conceitos de programação orientada à objetos.</p>
<p><strong>Semântica de Referência</strong></p>
<p>Um objeto é uma instância<sup id="fnref:3"><a class="footnote-ref" href="#fn:3">3</a></sup> de uma classe que possui um <strong>nome</strong> e uma <strong>posição</strong> na memória.</p>
<p>Uma classe pode ter várias instâncias de objetos<sup id="fnref:4"><a class="footnote-ref" href="#fn:4">4</a></sup>.</p>
<p>Em c# primeiro fazemos uma referência ao objeto para, depois, criarmos ele efetivamente usando o token <code>new</code>. Isso ocorre na mesma linha de código.</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MainClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Produto</span><span class="w"> </span><span class="n">produto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Produto</span><span class="p">();</span>
<span class="w">        </span><span class="n">produto</span><span class="p">.</span><span class="n">descricao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Cafe&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">produto</span><span class="p">.</span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.99</span><span class="p">;</span>
<span class="w">        </span><span class="n">produto</span><span class="p">.</span><span class="n">quantidade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">;</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Em estoque: {0}&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="n">produto</span><span class="p">.</span><span class="n">emEstoque</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;sim&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">&quot;não&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
Na parte <code>Produto produto</code> estamos fazendo apenas a <strong>referência</strong> à classe mas o objeto ainda não foi alocado na memória. Inicialmente o objeto <code>produto</code> é <code>null</code>.</p>
<p>Logo após a referência usamos o token <code>new</code> para, ai sim, criar um endereço na memória que onde o objeto será criado.</p>
<p><strong>Comentário:</strong> Se você ainda está com dúvidas sobre o que esse objeto criado fará, recomendamos fortemente os fundamentos da etapa 1.</p>
<h4 id="construtores">Construtores</h4>
<p>Começamos a ver esse assunto no período 1 do curso. Vale a pena relembrar antes de continuar essa seção.</p>
<p>Como vimos antes, o comando <code>Produto produto = new Produto();</code> faz a referência ao objeto e logo após cria um endereço na memória para ele.</p>
<p>Algumas linguagens possuem uma ferramenta automática de gestão de memória chamada <strong>Coletor de lixo</strong> ou <strong>Garbage Collector</strong> que é responsável pela exclusão de itens não usados durante a execução de um programa. Para nossa alegria, o c# possui essa ferramenta. Mais sobre esse conceito pode ser encontrado nesse <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#:~:text=The%20garbage%20collector%20attempts%20to,manual%20memory%20management%20in%20Lisp.">link</a>.</p>
<p>Por causa dessa característica da linguagem, no caso do objeto <code>produto</code> que criamos anteriormente, recebe alguns valores padrões no momento da sua criação. Se a variável for numérica, recebe o valor 0 e para as strings é passado o valor null. Desse modo, nosso objeto foi salvo no momento da sua criação com os seguintes valores:</p>
<pre><code>Descrição: null
Preço: 0.0
Quantidade: 0
</code></pre>
<p>Para garantir a correta utilização de um objeto criado, devemos nos valer da capacidade de definir valores no mesmo momento em que estamos criando um novo objeto. Já sabemos que esse conceito recebe o nome de <strong>construtor</strong>. Também sabemos que, em c#, um construtor é criado do mesmo modo de um método, a única diferença é que ele deve receber o <strong>mesmo nome</strong> do objeto e que não possuem valores de retorno. O número de construtores que um objeto pode receber é ilimitado.</p>
<p>Como vimos antes, um objeto sempre terá um construtor. Se não o declararmos, então o próprio c# se encarrega de definir quais serão os valores recebidos. De outro modo, se nós definirmos explicitamente um construtor no objeto, o compilador do c# sempre respeitará os valores que definimos no construtor.</p>
<p><strong>Razões Para se Utilizar Construtores Especializados</strong></p>
<ul>
<li>Alguns objetos possuem regras de estado válido que não comportam os dois tipos de valores do construtor default do c# (que só atribui 0 ou null);</li>
<li>Alguns objetos usam a data corrente como carimbo de tempo (timestamp) que pode ser definida por meio do construtor que recebe a hora do sistema;</li>
<li>Em objetos muito complexos, o volume de atributos pode ser muito elevado e, se não amarrados corretamente, pode haver algum equívoco por parte do usuário na hora de definir todos os valores corretos. Um construtor garante que, pelo menos na sua criação, o objeto terá um estado inicial válido para ser preenchido.</li>
</ul>
<p><strong>Construtores na Classe de Produto</strong></p>
<p>Voltaremos à nossa classe de objeto chamada de Produto para definirmos os seus construtores.
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Produto</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// construtor que recebe parametros</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Produto</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">descricao</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m">3</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">descricao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descricao</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">preco</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">quantidade</span><span class="w"> </span><span class="o">&gt;=</span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">quantidade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quantidade</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// novo construtor default</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Produto</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">descricao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Novo Produto&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.01F</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">quantidade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emEstoque</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">quantidade</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<strong>Comentário:</strong> O objeto <code>this</code> é um token que faz referência ao escopo onde se encontra. No caso em tela, ele se refere ao objeto sendo criado e não ao método onde está sendo usado. Essa parte de tokens de referência de escopo é um pouco confusa a primeira vista mas com o tempo é possível entender melhor.</p>
<p>Dessa maneira, nossa nova classe melhorada de objeto chamado Produto recebe dois tipos de construção. Podemos criar um objeto de produto com ou sem parâmetros.
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="c1">// Caso sem passagem de parâmetros</span>
<span class="n">Produto</span><span class="w"> </span><span class="n">produto1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Produto</span><span class="p">();</span>
<span class="c1">// Caso com passagem de parâmetros</span>
<span class="n">Produto</span><span class="w"> </span><span class="n">produto2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Produto</span><span class="p">(</span><span class="s">&quot;café&quot;</span><span class="p">,</span><span class="w"> </span><span class="m">1.50F</span><span class="p">,</span><span class="w"> </span><span class="m">12</span><span class="p">);</span>
</code></pre></div></p>
<h4 id="atributos-estaticos-e-propriedades">Atributos Estáticos e Propriedades</h4>
<p><strong>Membros Estáticos</strong></p>
<p>Antes de definirmos o que seria um membro estático, temos que formalizar o conceito de escopo. Podemos definir <strong>escopo</strong> como a região do código onde a variável pode ser acessada. Outra maneira de pensarmos esse conceito é a região do código onde a variável é visível pelo programa.</p>
<p>Podemos criar métodos e atributos que serão comuns a todos os objetos que tenham referência a eles na sua construção. Até agora, todos os métodos e atributos que tivemos nos nossos objetos foram criados <strong>dentro</strong> dos próprios objetos e, portanto, são salvos em diferentes endereços de memória a medida que novos objetos são criados ao longo do programa.</p>
<p>Pois bem, um <strong>membro estático</strong> é exatamente esse método ou atributo que são criados em escopo global e "inseridos" dentro dos nossos objetos por meio da referência a esse membro na classe que criará os objetos. Eles são muito úteis para implementação de <strong>contadores</strong> ou <strong>identificadores de auto-incremento</strong>. O termo "estático" é uma alusão ao fato que esses construtos são alocados no momento que a classe é carregada na memória e não variam o seu endereço ao longo de todo o programa, ou seja, eles existem antes mesmo de declararmos o primeiro objeto da classe criada.</p>
<p>Em c# usamos o token <code>static</code> para a declaração de um membro estático.</p>
<p><strong>Exemplo de Contador Auto-incremento</strong></p>
<p>Como agora temos um endereço na memória que todos os objetos podem fazer referência, podemos criar um contador que adiciona o valor 1 sempre que um novo objeto (ou instância) da classe for criada.</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Produto</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="c1">// novo atributo de identificação</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// referencia ao membro estático</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">contador</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// construtor que recebe parâmetros</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Produto</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Produto</span><span class="p">.</span><span class="n">contador</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">descricao</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m">3</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">descricao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descricao</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">preco</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">quantidade</span><span class="w"> </span><span class="o">&gt;=</span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">quantidade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quantidade</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// novo construtor default</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Produto</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Produto</span><span class="p">.</span><span class="n">contador</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">descricao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Novo Produto&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.01F</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">quantidade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emEstoque</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">quantidade</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
Podemos ver que, como o contador é um membro estático da classe, para acessar o seu valor temos que fazer referência à classe e não ao objeto.</p>
<p>A essa altura, alguns de vocês já devem ter percebido que toda aplicação c# está dentro de uma classe chamada <code>MainClass</code>. Com o nosso novo conhecimento de membro estático, podemos ver que o termo <code>public static void Main</code> possui 4 elementos dos quais nós já conhecemos o significado de 3:</p>
<ul>
<li>O termo <code>public</code> faz referência ao escopo de acesso;</li>
<li>O termo <code>static</code> faz referência ào conceito que acabamos de aprender de membro estático;</li>
<li><code>Main</code> é apenas um nome dado ao método da classe <code>Mainclass</code>.</li>
</ul>
<p>Basta aprendermos o significado do termo <code>void</code> e entenderemos como e porquê os programas em c# usam essa estrutura para funcionar corretamente.</p>
<p>Outra coisa que podemos perceber é que, pelo fato do método <code>Main</code> estar dentro de uma classe, se ele não fosse um membro estático, ele só seria executado na instanciação de um objeto. O problema é que esse objeto é justamente a aplicação. Ou seja, para o objeto Main ser instanciado precisaríamos de uma aplicação mas é justamente o objeto Main que contém a nossa aplicação. Por isso temos que usar o conceito de membro estático e que é disparado no momento em que a classe é carregada no nosso código.</p>
<h4 id="destrutores">Destrutores</h4>
<p>Já começamos a entender o que são destrutores lá no microfundamento de algoritmo de lógica. Recapitulando o que já sabemos, um <strong>destrutor</strong> é parecido com o construtor mas é ativado no momento em que a instância da classe é destruída pelo garbage collector no momento em que o objeto não é mais acessível a nenhuma parte do programa.</p>
<p>O coletor de lixo é executado em paralelo ao programa em uma thread separada do processador. Ele é executado esporadicamente e tem como missão liberar os espaços em memória sempre que identificar informações em memória que não são usadas ao longo da execução do programa por meio da busca de referência das mesmas. Mesmo não sendo o ideal, é possível forçar o .NET (que é o <a href="https://www.lewagon.com/pt-BR/blog/o-que-e-framework#:~:text=Framework%20%C3%A9%20um%20termo%20ingl%C3%AAs,de%20um%20projeto%20de%20desenvolvimento.">framework</a> mais famoso de c#) a executar o garbage collector por meio do comando <code>GC.Collect();</code>.</p>
<p>Por padrão, todo objeto em c# tem um destrutor nativo que tem como única atividade a liberação do espaço alocado em memória. Mas assim como acontece com os construtores, podemos definir alguma rotina a ser executada no momento da sua exclusão por meio da definição explícita. A regra de definição é parecida com a do construtor com a única diferença de colocarmos um til como primeiro caractere. No nosso exemplo, o destrutor será <code>~Produto()</code>.</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Produto</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="c1">// novo atributo de identificacao</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// referencia aos membros estaticos</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">contador</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">instancias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// construtor que recebe parametros</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Produto</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Produto</span><span class="p">.</span><span class="n">contador</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">instancias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Produto</span><span class="p">.</span><span class="n">instancias</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">descricao</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m">3</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">descricao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descricao</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">preco</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">quantidade</span><span class="w"> </span><span class="o">&gt;=</span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">quantidade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quantidade</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// novo construtor default</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Produto</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Produto</span><span class="p">.</span><span class="n">contador</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">instancias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Produto</span><span class="p">.</span><span class="n">instancias</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">descricao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Novo Produto&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.01F</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">quantidade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emEstoque</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">quantidade</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// destrutor</span>
<span class="w">    </span><span class="o">~</span><span class="n">Produto</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Adeus, mundo cruel!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">instancias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Produto</span><span class="p">.</span><span class="n">instancias</span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<strong>Comentário:</strong> Reflita sobre esse código acima. Não devemos ter nenhuma dúvida sobre todos os elementos da construção dessa classe chamada <code>Produto</code>. Sempre retorne e revise os tópicos anteriores até que tudo tenha sentido.</p>
<h3 id="encapsulamento">Encapsulamento</h3>
<p>Alguns assuntos podem parecer repetidos. Mas aprofundaremos mais a discussão em relação ao que já aprendemos na primeira parte desse material.</p>
<h4 id="principio-da-ocultacao-da-informacao">Princípio da Ocultação da Informação</h4>
<p>Podemos definir o princípio da ocultação como sendo:</p>
<p>"Toda informação a respeito de um módulo deve ser privativa do módulo, exceto se for explicitamente declarada como pública."</p>
<p>David Parnas introduziu esse conceito em meados de 1972. No seu <a href="https://cseweb.ucsd.edu/~wgg/CSE218/Parnas-IFIP71-information-distribution.PDF">paper</a> temos a seguinte citação em tradução livre:"[...] A documentação dos sistema que torna todas as informações acessíveis a todos os trabalhadores do projeto é discutida. A tese que essa informações deve ser 'pública' é temerária porque, na maioria dos casos, é útil que a informação sobre o sistema esteja escondida da maioria dos programadores [...]".</p>
<p><strong>Interface</strong></p>
<p>Podemos definir a interface de uma aplicação de software como:</p>
<p>"Tudo aquilo que o usuário do objeto vê e acessa."</p>
<p>Podemos ver que esse conceito de "usuário" serve tanto para o usuário da aplicação quanto para outros programadores que usarão algum objeto de uma classe que criamos anteriormente nos nossos módulos.</p>
<p>No contexto do princípio da ocultação da informação, temos que pensar em interfaces que demonstrem apenas os aspectos estáveis da solução. Tudo que for dinâmico são do escopo da implementação.</p>
<p>Um módulo pode ocultar informações como, por exemplo, Algoritmos e Representação de Dados.</p>
<p>A interface pode ser divida em duas partes:</p>
<ul>
<li>Assinatura - Nomes e Tipos de informações sobre as funções do módulo</li>
<li>Especificação - Descrição sobre o significado e funcionamento dessas funções</li>
</ul>
<p><strong>Comentário:</strong> Essa seção será expandida em tempo oportuno porque esse assunto é muito vasto para pararmos apenas nesses conceitos básicos.</p>
<p><strong>Encapsulamento</strong></p>
<p>Um módulo deve ter um conjunto de comandos e a especificação desses comandos, já vimos que essa parte pode ser chamada de <strong>interface</strong> do módulo. O conceito de encapsulamento é derivado do princípio da ocultação da informação no sentido que todo módulo pode receber (e normalmente recebe) atualizações na sua parte de <strong>implementação</strong> sem que haja mudanças visíveis na camada de interface.</p>
<p>Dizemos que os <strong>atributos</strong> dos módulos são protegidos pelo encapsulamento porque ficam restritos apenas à camada interna não acessível a todos. Quando queremos um input de dados do usuário damos sempre preferência aos <strong>métodos</strong> do nosso objeto porque dessa maneira podemos validar os dados inseridos.</p>
<p>Além dessa capacidade de manutenção na camada de implementação, o encapsulamento permite a proteção da lógica da regra de negócio para a construção das classes. No exemplo do produto, podemos encapsular a variável quantidade por meio do acesso mediante apenas a um método pre-definido. Isso nos dá a certeza que um usuário não poderá inserir valores da maneira inadvertida que possam gerar resultados imprevistos no nosso sistema.</p>
<p>Um conceito relevante que podemos destacar é chamado de <strong>encapsulamento e princípio da caixa preta</strong>. Que pode ser resumido como:</p>
<p>"Um módulo deve consistir de um conjunto de comandos com uma função bem definida e o mais independente possível em relação ao resto do sistema."</p>
<p>Existem outras características relevantes na construção dos módulos que devemos observar:</p>
<ul>
<li>Independência Funcional - Cada módulo é responsável por uma função específica e bem definida;</li>
<li>Coesão - Todas as partes de um módulo devem estar logicamente ligadas às outras. Assim como um sistema deve ter módulos logicamente relacionados;</li>
<li>Acoplamento - Relação de dependência entre os módulos de um sistema. O ideal é um baixo nível de acoplamento</li>
</ul>
<p><img alt="35-acoplamento.png" src="../../../../assets/imgs/35-acoplamento.png" /></p>
<p>Na imagem acima, cada caixa é uma módulo que possui relações internas (que devem ser coesas). Um alto acoplamento é aquele que permite muitas conexões entre os módulos de modo a, em caso de falha em um dos nós da rede, existir um risco de efeito cascata em caso de falha.</p>
<h4 id="modificadores-de-acesso">Modificadores de Acesso</h4>
<p>O princípio da ocultação da informação é aplicado por meio do <strong>encapsulamento</strong>. O c# e outras linguagens modernas permitem que controlemos o nível de visibilidade dos membros de uma classe de forma a ocultarmos todos os dados e métodos que precisarmos para garantir o cumprimento da tarefa com todos aqueles requisitos de qualidade de software alcançados.</p>
<p>Em c# existem 3 níveis de acesso aos atributos e métodos que podemos usar na criação de um módulo<sup id="fnref:5"><a class="footnote-ref" href="#fn:5">5</a></sup>:</p>
<ul>
<li><code>private</code> - Acesso apenas na própria classe;</li>
<li><code>protected</code> - Acesso permitido na própria classe e em suas subclasses (ou classes filhas);</li>
<li><code>public</code> - Acesso em qualquer parte do programa</li>
</ul>
<p><strong>Comentário:</strong> Por default, o c# atribui o nível privado quando nenhum modificador de acesso é atribuído explicitamente. Mas é sempre uma boa prática tornar os acessos sempre explicitamente visíveis no código, mesmo quando eles são privados.</p>
<p>Voltando à nossa classe Produto. O ideal seria manter todos os atributos privados com apenas os construtores e o método de checagem de estoque acessíveis ao usuário.
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Produto</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="c1">// novo atributo de identificacao</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// referencia aos membros estaticos</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">contador</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">instancias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// construtor que recebe parametros</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Produto</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Produto</span><span class="p">.</span><span class="n">contador</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">instancias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Produto</span><span class="p">.</span><span class="n">instancias</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">descricao</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m">3</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">descricao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">descricao</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">preco</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">quantidade</span><span class="w"> </span><span class="o">&gt;=</span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="n">quantidade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quantidade</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// novo construtor default</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Produto</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Produto</span><span class="p">.</span><span class="n">contador</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">instancias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Produto</span><span class="p">.</span><span class="n">instancias</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">descricao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Novo Produto&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.01F</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">quantidade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emEstoque</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">quantidade</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// destrutor</span>
<span class="w">    </span><span class="o">~</span><span class="n">Produto</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Adeus, mundo cruel!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">instancias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Produto</span><span class="p">.</span><span class="n">instancias</span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<strong>Regras de Encapsulamento</strong></p>
<p>Para facilitar a internalização do princípio da ocultação da informação. Podemos elencar algumas regras de bolso para serem usadas sempre que uma dúvida a respeito desse tema aparecer:</p>
<ul>
<li>Sempre opte pelo nível de acesso mais restrito que faça sentido para cada membro<sup id="fnref:6"><a class="footnote-ref" href="#fn:6">6</a></sup> da classe;</li>
<li>Use <code>private</code> a menos que haja uma boa razão para o contrário;</li>
<li>Use <code>public</code> apenas para constantes</li>
</ul>
<p><strong>Comentário:</strong> Os pontos 1 e 2 são praticamente a mesma coisa na minha visão. A lógica do ponto 3 é que quanto mais membros de classe públicos, maior é a chance que outros módulos façam uso deles, desse modo, o risco de um alto acoplamento se torna cada vez maior.</p>
<h4 id="metodos-de-acesso-e-propriedades">Métodos de Acesso e Propriedades</h4>
<p>O princípio da ocultação da informação não nos impede de ter acesso aos atributos. Nós apenas nos certificamos que eles serão seguramente acessados por meios dos métodos que deixaremos disponíveis para interação.</p>
<p>Chamamos de <strong>métodos de acesso</strong> os meios criados para permitir que os usuários tenham capacidade de acessar da maneira desejada as informações contidas nos atributos dos nossos objetos. Desse modo, temos a confiança que os valores atribuídos aos atributos dos nossos objetos sempre obedecerão às regras definidas nos seus métodos públicos.</p>
<p><strong>Comentário:</strong> Já iniciamos esse assunto anteriormente no nosso material.</p>
<p><strong>Métodos get (leitura):</strong> É capaz de acessar um valor de atributo privado.</p>
<p><strong>Métodos set (escrita):</strong> É capaz de atribuir valor a um atributo privado.</p>
<p>Até o momento, a nossa classe (que também chamamos de módulo) está criada de maneira que ainda não podemos ter acesso a seus atributos propriamente.</p>
<p>Uma maneira de criar um método de acesso get para o nosso atributo de preço pode ser:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="w">    </span><span class="na">[...]</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="na">[...]</span>

<span class="w">    </span><span class="c1">// método de acesso get para atributo preco</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">GetPreco</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="na">[...]</span>
</code></pre></div>
<p>Podemos ir um pouco além de criar um método de acesso set da seguinte maneira:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="w">    </span><span class="na">[...]</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="na">[...]</span>

<span class="w">    </span><span class="c1">// método de acesso set para o atributo preco</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">SetPreco</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">preco</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="na">[...]</span>
</code></pre></div>
Desse modo, criamos a leitura e a escrita do atributo intermediados pelos métodos que nos permitem controlar as características do input realizado e, assim, nos dar segurança que nossa aplicação se comportará da maneira desejada.</p>
<p><strong>Propriedades</strong></p>
<p>Podemos melhorar ainda mais a legibilidade do nosso código por meio do uso das propriedades nativas dos atributos de um módulo. Podemos definir uma <strong>propriedade</strong> como um tipo especial de atributo que possui métodos associados a ele.</p>
<p>Temos 3 métodos que podem nos conferir mais clareza no código e alcançar o mesmo resultado que nossos códigos anteriores:</p>
<ul>
<li><code>init</code> - Atribui o valor inicial ao atributo da classe;</li>
<li><code>set</code> - Atualiza o valor de um atributo;</li>
<li><code>get</code> - Retorna o valor atual de um atributo</li>
</ul>
<p>Reescrevendo nossos métodos de acesso à propriedade de preço, temos que:
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="w">    </span><span class="na">[...]</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="na">[...]</span>

<span class="w">    </span><span class="c1">// criando a propriedade Preco</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Preco</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">get</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// outra maneira de sintaxe para o get:</span>
<span class="w">        </span><span class="c1">// get =&gt; this.preco</span>
<span class="w">        </span><span class="k">set</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="n">preco</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// criando a propriedade Preco2 sem nenhum verificador</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Preco</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">get</span><span class="p">;</span><span class="w"> </span><span class="k">set</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
O parâmetro <code>value</code> é passado junto ao método set para atualização dos valores dos atributos.</p>
<p>Mais informações sobre as propriedades podem ser encontradas nesse <a href="https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/get">link</a>.</p>
<h4 id="namespaces-e-partial-classes">Namespaces e Partial Classes</h4>
<h5 id="namespaces">Namespaces</h5>
<p>Já entendemos que um módulo deve ser autocontido e com um propósito bem definido. Entretanto, isso não quer dizer que teremos, na construção de um sistema complexo, apenas 1 módulo que englobe toda a solução. Para tanto, quebramos as relações e tarefas em vários módulos diferentes sempre respeitando os princípios que aprendemos anteriormente sobre código de qualidade.</p>
<p>Agora que temos vários módulos, precisaremos de uma maneira de agrupa-los de maneira que faça sentido. É exatamente para isso que existe o conceito de <strong>namespaces</strong>. Com esse conceito, podemos criar uma lógica mais geral que englobe vários módulos.</p>
<p>Os namespaces são usados para a criação de bibliotecas de código e podem ser entendidos como um conjunto de classes.</p>
<p>Por convenção e organização lógica, sempre que tivermos a necessidade de criarmos um namespace, devemos salvar todas as classes contidas nele em arquivos separados e um arquivo de código por classe. Por exemplo, se nossa solução possui dois namespaces com uma classe em cada, criaremos duas pastas na raiz do nosso programa, sendo cada uma delas nomeada pelo seu respectivo namespace. Abaixo temos um exemplo de organização de arquivos.</p>
<pre><code>|- code/
|- bin/
|- namespace1/
|------------ class1.cs
|------------ class2.cs
|-namespace2/
|------------ class1.cs
|------------ class2.cs
|------------ class3.cs
|- obj/
|- Program.cs
</code></pre>
<p>Podemos ver que nosso programa tem como diretório raiz a pasta "code". Dentro dela temos o nosso arquivo de código principal <code>Program.cs</code>. Também podemos ver diversas classes separadas em cada pasta <code>namespace</code>. Isso nos permite uma manutenção mais simples a medida que nosso programa se torne cada vez mais complexo e refinado.</p>
<p>Do ponto de vista do código. Em c# o <code>namespace</code> é declarado dentro das classes que estão dentro dele:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">Contabil</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Juros</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Valor</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">get</span><span class="p">;</span><span class="w"> </span><span class="k">set</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
Também podemos importar namespaces em outros módulos por meio do token <code>using</code>:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">Contabil</span><span class="p">;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MainClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Contabil</span><span class="p">.</span><span class="n">Juros</span><span class="w"> </span><span class="n">jurosAReceber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Contabil</span><span class="p">.</span><span class="n">Juros</span><span class="p">();</span>
<span class="w">        </span><span class="n">jurosAReceber</span><span class="p">.</span><span class="n">Valor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">12345.23F</span><span class="p">;</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;Juros a Receber: {jurosAReceber.Valor:C2}&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
Mesmo não sendo o ideal, outro problema que o namespace resolve é o de conflito de nomes de métodos ou classes. Nos exemplos acima, só usamos um namespace <code>Contabil</code> com uma classe chamada Juros. Entretanto, poderíamos, sem nenhum problema, termos criado outro namespace, <code>Financeiro</code> por exemplo, com uma classe chamada juros. Não teríamos problema de conflito de nomes porque na hora de instanciarmos as classes nós sempre fazemos referência ao namespace em que a classe se encontra.</p>
<p><strong>Partial Classes</strong></p>
<p>O recomendado hoje em dia é que uma classe deve ser implementada em um único arquivo<sup id="fnref:7"><a class="footnote-ref" href="#fn:7">7</a></sup>. Mas, como tudo na vida, as vezes precisamos fazer concessões.</p>
<p>É possível definirmos uma classe em mais de um arquivo. Chamamos esse tipo de classe de <code>partial class</code>. A ideia é facilitar a organização de classes muito grandes de maneis mais fácil para manutenção. Esse tipo de abordagem é especialmente relevante para programação frontend de interfaces gráficas porque a quantidade de código gerado pelo compilador é enorme.</p>
<p>Podemos atualizar nossa estrutura de pastas com uma partial class agora.</p>
<pre><code>|- code/
|- bin/
|- namespace1/
|------------ class1.cs
|------------ class2.cs
|-namespace2/
|------------ class1.cs
|------------ class2.cs
|------------ class3.cs
|- partialClass1.cs
|- partialClass2.cs
|- obj/
|- Program.cs
</code></pre>
<p>Desse modo podemos criar um "pedaço" da classe em cada arquivo separado. O código ficará assim:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="c1">// parte 1</span>
<span class="k">public</span><span class="w"> </span><span class="k">partial</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ClasseParcial</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="n">tarefa</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">get</span><span class="p">;</span><span class="w"> </span><span class="k">set</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// parte 2</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">public</span><span class="w"> </span><span class="k">partial</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ClasseParcial</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">ExibeTarefa</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Esu estou &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">tarefa</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
No arquivo <code>Program.cs</code> teremos:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MainClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ClasseParcial</span><span class="w"> </span><span class="n">classeParcial</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClasseParcial</span><span class="p">();</span>
<span class="w">        </span><span class="n">classeParcial</span><span class="p">.</span><span class="n">tarefa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;escrevendo&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">classeParcial</span><span class="p">.</span><span class="n">ExibeTarefa</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
A documentação oficial pode ser encontrada nesse <a href="https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods">link</a>.</p>
<h3 id="heranca">Herança</h3>
<h4 id="generalizacao-e-especificacao">Generalização e Especificação</h4>
<p>Em todo processo de desenvolvimento é normal que a solução evolua com o passar do tempo e estruturas criadas anteriormente (como módulos) acabam evoluindo junto.</p>
<p>Nesse contexto é que surgem dois conceitos importantes para o nosso aprendizado: <strong>Generalização</strong> e <strong>Especificação</strong>.</p>
<p>Podemos entender como processo de <strong>Generalização</strong> a construção de uma classe genérica a partir da abstração de várias classes mais definidas. Como, por exemplo, ao desenvolvermos uma solução que tenha vários objetos relacionados à cada tipo de produto que um supermercado venda. Podemos procurar os elementos comuns em todas as classes de diferentes produtos e construir uma classe maior denominada ``produto". Chamamos esse caminho (de baixo pra cima) de bottom-up.</p>
<p>No caminho oposto, temos o processo de <strong>Especificação</strong>. Nessa lógica, podemos partir de uma classe maior e, pela necessidade, criamos subclasses que compartilham elementos comuns com essa classe mais geral. Como exemplo, podemos citar um sistema de gerenciamento de condomínio que pode ter a classe "bloco" onde vai receber todas as informações e métodos de cada bloco e, por demanda de informações mais detalhadas, passemos a criar classes menores chamadas "andar" ou "apartamento" que contém informações adicionais ao nosso objeto anterior. Esse caminho (de cima pra baixo) é chamado de top-down.</p>
<p><strong>Herança</strong></p>
<p>Na criação de uma classe através da generalização ou da especificação é que o conceito de <strong>herança</strong> é nascido. Como estamos criando classes em termos de outras pré-existentes, devemos descrever a relação entre essas diferentes classes.</p>
<p>No momento da definição da relação de herança podemos usar os vínculos do tipo "é um tipo de" ou "é um".</p>
<p>Quando criamos uma herança, o objeto mais geral é chamado de supertipo. Todos os subtipos desse objeto compartilham as características dele e recebem novas que não são atribuídas ao supertipo.</p>
<p>Podemos chamar os subtipos de <strong>classes derivadas</strong>, <strong>classes filhas</strong>, <strong>subclasses</strong> e etc. Por outro lado, as classes mais gerais podem ser chamadas de <strong>classes base</strong>, <strong>superclasses</strong> <strong>classes pai</strong> e etc.</p>
<p>Existem linguagens que permite que uma subclasse receba harança de diferentes superclasses. Chamamos isso de <strong>herança múltipla</strong> e, ao contrário do que pode parecer, não é uma ideia muito boa porque aumenta o risco de auto acoplamento. Para tanto, o c# não permite herança múltipla.</p>
<p><strong>Exemplo de Herança em c#</strong></p>
<p>Agora que aprendemos os conceitos, podemos aprender como criar essas relações usando a linguagem c#. Partindo de uma superclasse chamada <code>Pessoa</code>, podemos criar as subclasses do seguinte modo:
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="c1">// superclasse</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Pessoa</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="na">[...]</span>
<span class="p">}</span>

<span class="c1">// subclasses</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Professor</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Pessoa</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="na">[...]</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Aluno</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Pessoa</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="na">[...]</span>
<span class="p">}</span>
</code></pre></div>
Retomando nosso exemplo para o módulo <code>Produto</code>, podemos criar uma subclasse chamada <code>BemDeConsumo</code>:
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BemDeConsumo</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Produto</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">validade</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">Validade</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">validade</span><span class="p">;</span>
<span class="w">        </span><span class="k">set</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">validade</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="p">(</span><span class="k">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BemDuravel</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Produto</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">garantia</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Validade</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">garantia</span><span class="p">;</span>
<span class="w">        </span><span class="k">set</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">garantia</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="m">6</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<strong>Comentário:</strong> Não se assustem pela mudança na maneira de escrever as propriedades <code>get</code> e <code>set</code>. Esse token <code>=&gt;</code> é interpretado do mesmo jeito que o par de chaves vistos anteriormente.</p>
<p>Ao usarmos essas subclasses no nosso programa, elas terão os mesmo atributos e métodos que a superclasse <code>Produto</code> que elaboramos durante todo esse capítulo.</p>
<p><strong>Comentário:</strong> Existe um princípio da programação orientada à objetos que prioria composição ao invés da herança. A ideia é que é melhor fazer as conexões entre classes de mesma hierarquia do que criar uma vasta linha entre superclasses e subclasses. Em tempo oportuno retomaremos essa discussão. Por enquanto segue esse <a href="https://acervolima.com/favorecendo-a-composicao-em-vez-da-heranca-em-java-com-exemplos/#:~:text=Favorecer%20a%20composi%C3%A7%C3%A3o%20em%20vez,uma%20classe%20base%20ou%20pai.">link</a> com esse assunto.</p>
<h4 id="construtores-em-classes-filhas">Construtores em Classes Filhas</h4>
<p>Quando instaciamos um objeto a partir de uma classe filha, primeiro disparamos os construtores da classe pai para, depois, executarmos os construtores da subclasse.</p>
<p>Se a classe filha não indicar um construtor diferente, o c# usa o construtor default da classe pai. Entretanto, é possível definir quais serão os atributos usados tanto no processo de construção herdados quanto nos nativos da subclasse. Para usarmos essa configuração de construção, passamos os parâmetros através do token <code>: base(atributos)</code>.</p>
<p><strong>Exemplo de Construtores em Classes Estendidas (Subclasses ou Classes Filhas)</strong></p>
<p>Para exemplo, usaremos as subclasses <code>BemDeConsumo</code> que já vimos nos exemplos passados.
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BemDeConsumo</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Produto</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">validade</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">Validade</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">validade</span><span class="p">;</span>
<span class="w">        </span><span class="k">set</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">validade</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="p">(</span><span class="n">validade</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">BemDeConsumo</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">,</span>

<span class="w">    </span><span class="n">DateTime</span><span class="w"> </span><span class="n">validade</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">base</span><span class="p">(</span><span class="n">descricao</span><span class="p">,</span><span class="w"> </span><span class="n">preco</span><span class="p">,</span><span class="w"> </span><span class="n">quantidade</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">validade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">validade</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
No exemplo acima, o nosso construtor da classe filha receberá 4 parâmetros dos quais 3 (descrição, preço e quantidade) serão usados no processo do construtor da classe pai.</p>
<p>Construtores e encapsulamento são o primeiro passo para a garantia da correção e robustez de um sistema. Sempre que usarmos a herança, temos que nos valer dessas técnicas para melhorar a qualidade dos nossos programas.</p>
<h2 id="polimorfismo-e-principios-do-projeto-modular">Polimorfismo e Princípios do Projeto Modular</h2>
<h3 id="polimorfismo-de-inclusao">Polimorfismo de Inclusão</h3>
<p>Nessa seção vamos aprender como reutilizar soluções de código por meio do uso de hierarquia entre classes. Esse tipo de "transformação" entre classes filhas e superclasses é chamado de 
<strong>polimorfismo de inclusão</strong>.</p>
<h4 id="sobreposicao-de-metodos-virtual-e-override">Sobreposição de Métodos (virtual e override)</h4>
<p>Podemos conceder certas liberdades aos nossos objetos derivados de superclasses. Uma dessas liberdades é a capacidade de <strong>sobreposição</strong> ou <strong>override</strong> que é dada, quando queremos permitir que um atributo ou método tenha seu funcionamento modificado nas classes filhas mantendo-se o mesmo nome que o seu referente na classe pai. Usamos o token <code>virtual</code> na classe pai no momento da sua construção para permitir as sobreposições futuras.</p>
<p>Da mesma maneira que temos um token na classe pai, temos que usar o token <code>override</code> na classe filha para indicar a sobreposição de atributo ou método. Além de sobrescrever, podemos fazer uso do método original da superclasse por meio do token de referência <code>base</code><sup id="fnref:8"><a class="footnote-ref" href="#fn:8">8</a></sup>.</p>
<p>Outra requisição obrigatória no processo de sobreposição é o uso do token <code>new</code> na hora da criação de um método ou atributo de mesmo nome na classe original. Abaixo temos um exemplo de como podemos expandir um método criado na classe origina por meio da sobreposição.</p>
<p><strong>Comentário:</strong> Até agora usamos várias vezes o token <code>void</code> e ainda não tivemos a satisfação de uma definição do que ele faz. O token <code>void</code> é usado na construção de <strong>métodos sem retorno</strong>, ou seja, funções que não possuem uma linha com o comando <code>return</code>. </p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">superClasse</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;string original&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// permitindo a sobrescrita por meio do token &#39;virtual&#39;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">mostra</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Mostra original&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span><span class="w"> </span><span class="nc">subClasse</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">superClasse</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// criando uma variável &#39;str&#39; na classe filha</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;String nova&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// override do método original</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">mostra</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;-------&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">base</span><span class="p">.</span><span class="n">mostra</span><span class="p">();</span><span class="w"> </span><span class="c1">// função original</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;-------&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Mostra Estendida&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;-------&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<strong>Polimorfismo Universão de Inclusão</strong></p>
<p>Os <strong>três princípios básicos da programação orientada à objetos</strong> são:</p>
<ul>
<li>Encapsulamento</li>
<li>Herança</li>
<li>Polimorfismo</li>
</ul>
<p>Já sabemos o que são os dois primeiros. Sabemos que a herança nos permite reaproveitar códigos anteriores em novos contextos. Entretanto, é raro termos aplicações exatamente iguais às do momento em que as classes originais foram criadas. É precisamente nesse contexto que surge o nosso terceiro princípio da OOP.</p>
<p>O <strong>Polimorfismo</strong> nos permite "adaptar" ou sobrepor algumas característica originais trazidas pela herança nos objetos derivados de classes anteriormente cridas. Ele nos permite criar sobreposições de métodos derivados para o melhor aproveitamento e adaptação aos problemas novos.</p>
<p>Para a existência do polimorfismos são necessários três requisitos:</p>
<ul>
<li>Herança</li>
<li>Sobreposição de Métodos</li>
<li>Referência de uma superclasse que aponte para um objeto de uma subclasse (referência polimórfica)</li>
</ul>
<p>Vamos a um exemplo de polimorfismo mas com o devido contexto. É natural pensar que um objeto contenha um método cuja saída seja uma string com as informações a respeito dele. Em c# existem métodos nativos, ou seja, que existe por padrão em todos os objetos, cujo um deles é chamado <code>toString()</code> que retorna uma string com informações sobre o objeto.</p>
<p><strong>Comentário:</strong> Mais sobre esse assunto pode ser encontrado nessa <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.object?view=net-6.0">documentação oficial</a>.</p>
<p>Mas como esse método é nativo, normalmente ele só trás algumas poucas informações sobre os objetos. Pensando nos atributos de qualidade de software que aprendemos até agora, não faz sentido (ou não é indicado) criarmos um método novo que retorne uma string com informações das nossas classes instanciadas porque já temos um por default. Como podemos resolver o fato desse método nativo não ser suficientemente detalhado? Polimorfismo é a solução!</p>
<p>Agora vamos fazer uma mudança no comportamento do método nativo das classes em c# toString().
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Produto</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">fabricacao</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">contador</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">instancia</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">    </span><span class="na">[...]</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nf">ToString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">$&quot;Produto {id}: {descricao}\n</span>
<span class="w">        </span><span class="n">Preço</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="n">preco</span><span class="p">:</span><span class="n">C2</span><span class="p">}</span><span class="err">\</span><span class="n">n</span>
<span class="w">        </span><span class="n">Quant</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="n">quantidade</span><span class="p">}</span><span class="err">\</span><span class="n">n</span>
<span class="w">        </span><span class="n">Fabric</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="n">fabricacao</span><span class="p">}</span><span class="s">&quot;;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<strong>Comentário:</strong> Mas espere um segundo. Temos um <code>override</code> em uma classe pai?! É isso mesmo! A razão disso é que <strong>todas as classes</strong> em c# são, de certa maneira, classes filhas de uma classe mestre que contém todos os métodos padrões. Mesmo as classes pai.
"
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BemDeConsumo</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Produto</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">validade</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">Validade</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">validade</span><span class="p">;</span>
<span class="w">        </span><span class="k">set</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">validade</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="p">(</span><span class="k">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// construtor</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">BemDeConsumo</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">descricao</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">preco</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">quantidade</span><span class="p">,</span>
<span class="w">    </span><span class="n">DateTime</span><span class="w"> </span><span class="n">fabricacao</span><span class="p">,</span><span class="w"> </span><span class="n">DateTime</span><span class="w"> </span><span class="n">validade</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">base</span><span class="p">(</span><span class="n">descricao</span><span class="p">,</span><span class="w"> </span><span class="n">preco</span><span class="p">,</span><span class="w"> </span><span class="n">quantidade</span><span class="p">,</span><span class="w"> </span><span class="n">fabricacao</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">valiade</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">validade</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nf">ToString</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">base</span><span class="p">.</span><span class="n">ToString</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">$&quot; validade : {validade}&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p><strong>Comentário:</strong> Essa seção é bem densa e importante. Pare e reflita sobre os códigos que foram vistos aqui. Revise sempre que necessário.</p>
<h4 id="classes-abstratas">Classes Abstratas</h4>
<p>Em c# podemos definir métodos sem declarar as suas implementações, ou seja, reservamos os nomes mas não dizemos o que eles farão. Não é de se estranhar que esses métodos recebam a nomenclatura de <strong>métodos abstratos</strong>. Se uma classe possui um ou mais desses métodos ela é chamada de <strong>classe abstrata</strong> porque não contém tudo que é necessário para a construção de uma classe normal.</p>
<p>Como as classes abstratas são "incompletas", não podemos instanciar objetos com elas. Entretanto, podemos usar o que aprendemos de polimorfismo para "preencher" essas lacunas por meio das classes derivadas. Uma classe herdeira também herda os métodos da classe abstrata, sejam eles abstratos ou não.</p>
<p>Abaixo temos a criação de uma classe abstrata com um método abstrato. Percebam o uso do token <code>abstract</code> para esses casos.</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="c1">// criacao da classe abstrata</span>
<span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Pai</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// criacao do metodo abstrato</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">abstract</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nf">fazNadaAinda</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// classe filha</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Filha</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Pai</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nf">fazNadaAinda</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;{Agora eu faço algo!}&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
Perceba que o método <code>fazNadaAinda</code> é apenas declarado sem qualquer construção da funcionalidade do mesmo. Se tentarmos instanciar essa classe, teremos um erro porque classes abstratas não podem ser instanciadas em objetos concretos. Mas podemos criar uma classe filha que dará o restante da lógica necessária a sua instanciação.</p>
<p>Abaixo temos um exemplo de um programa simples que conta até 10 com o uso de uma classe abstrata pai.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// classe abstrata</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Pai</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// método abstrato</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">abstract</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">fazNadaAinda</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// classe filha</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Filha</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Pai</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">contador</span><span class="p">;</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Contador</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">contador</span><span class="p">;</span>
<span class="w">            </span><span class="k">set</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">contador</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">value</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// método abstrato herdado</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">fazNadaAinda</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">contador</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">contador</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// programa</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">MainClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// instanciação da classe filha</span>
<span class="w">        </span><span class="n">Filha</span><span class="w"> </span><span class="n">objFilha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Filha</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// loop usando o método abstrato que agora possui definição</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">objFilha</span><span class="p">.</span><span class="n">Contador</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">10</span><span class="p">)</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;{objFilha.fazNadaAinda()}&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="comparando-virtual-e-abstract">Comparando Virtual e Abstract</h5>
<p>Referente às classes:</p>
<ul>
<li>Classes não podem ser <code>virtual</code></li>
<li>Clases com algum elemeto declarado como <code>abstract</code> devem ser <code>abstract</code> também</li>
<li>Classes abstratas não podem ser instanciadas</li>
</ul>
<p>Referente aos membros das classes:</p>
<ul>
<li>Membros de classes criados com <code>virtual</code> podem ser criados na classe e sobrepostos pelas classes filhas</li>
<li>Membros de classes criados com <code>abstract</code> <strong>devem ser</strong> implementados nas classes filhas por meio do token <code>override</code></li>
</ul>
<p><strong>Polimorfismo</strong></p>
<p>Volte nos 3 requisitos de existência do polimorfismo. Agora podemos ver que para a existência desse conceito, deve existir pelo menos duas classes de hierarquias diferentes em que exista algum grau de criação genérica na classe original que será definida na classe derivada.</p>
<p>Para a melhor fixação desse conteúdo, o professor nos dá um exemplo de <strong>lista de figuras</strong>: Considere que queremos implementar uma lista de figuras genérica capaz de armazenar diversos tipos de objetos geométricos. Cada objeto terá informações sobre coordenadas x e y; lado; cor e se possui ou não preenchimento. De posse dessas informações, podemos definir um método <code>desenhar()</code> que mostrará na tela uma representação visual da figura cadastrada. Entretanto, cada figura terá o seu conjunto próprio de características.</p>
<p>Esse é um caso ótimo para o polimorfismo.
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System.Drawing</span><span class="p">;</span>

<span class="k">public</span><span class="w"> </span><span class="k">abstract</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Figura</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="w"> </span><span class="k">set</span><span class="p">;}</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="w"> </span><span class="k">set</span><span class="p">;}</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Lado</span><span class="w"> </span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="w"> </span><span class="k">set</span><span class="p">;}</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="n">Cor</span><span class="w"> </span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="w"> </span><span class="k">set</span><span class="p">;}</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">Preenchido</span><span class="w"> </span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="w"> </span><span class="k">set</span><span class="p">;}</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">figura</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lado</span><span class="p">,</span>

<span class="w">    </span><span class="n">Color</span><span class="w"> </span><span class="n">cor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">preenchido</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">Lado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lado</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">Cor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cor</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">Preenchido</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preenchido</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// método abstrato</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">abstract</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Desenha</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
De posse dessa abstração chamada <code>Figura</code>, podemos estender esse conceito através do polimorfismo através da criação de classes filhas.
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Quadrado</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">figura</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Quadrado</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lado</span><span class="p">,</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="n">cor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">preenchido</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">base</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">lado</span><span class="p">,</span><span class="w"> </span><span class="n">cor</span><span class="p">,</span><span class="w"> </span><span class="n">preenchido</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// como todos os parâmetros foram</span>
<span class="w">        </span><span class="c1">// usados no construtor base</span>
<span class="w">        </span><span class="c1">// aqui fica vazio</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Desenha</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;Desenhando o Quadrdo&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Circulo</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Figura</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="w"> </span><span class="nf">Circulo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lado</span><span class="p">,</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="n">cor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">preenchido</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">base</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">lado</span><span class="p">,</span><span class="w"> </span><span class="n">cor</span><span class="p">,</span><span class="w"> </span><span class="n">preenchido</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// como todos os parametros foram</span>
<span class="w">        </span><span class="c1">// usados no construtor base</span>
<span class="w">        </span><span class="c1">// aqui fica vazio</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Desenha</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;Desenhando o Circulo&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
Nosso programa agora é capaz (hipoteticamente) de construir figuras que sejam quadrados e círculos. Vejam como usamos o polimorfismo para a construção dessa solução. Podemos criar 2 objetos do seguinte modo:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MainClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Figura</span><span class="p">[]</span><span class="w"> </span><span class="n">figuras</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">figura</span><span class="p">[</span><span class="m">10</span><span class="p">];</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">figuras</span><span class="p">[</span><span class="n">numFig</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Quadrado</span><span class="p">(</span><span class="m">10</span><span class="p">,</span><span class="m">20</span><span class="p">,</span><span class="m">50</span><span class="p">,</span><span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">,</span><span class="w"> </span><span class="k">true</span><span class="p">);</span>
<span class="w">        </span><span class="n">figuras</span><span class="p">[</span><span class="n">numFig</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Circulo</span><span class="p">(</span><span class="m">100</span><span class="p">,</span><span class="m">225</span><span class="p">,</span><span class="m">80</span><span class="p">,</span><span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">,</span><span class="w"> </span><span class="k">false</span><span class="p">);</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numFig</span><span class="p">;</span><span class="w"> </span><span class="n">pos</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="n">figuras</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">Desenha</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<strong>Comentário:</strong> Se ficou na dúvida, lembre-se do que aprendemos sobre <strong>vetores</strong> na disciplina de abstração de dados.</p>
<h4 id="classes-e-membros-selados-sealed">Classes e Membros Selados (sealed)</h4>
<p>Da mesma maneira que aprendemos como permitir o polimorfismo, o c# também nos permite impedir que certas classes ou membros de classe sofram herança ou polimorfismo.</p>
<p>Para impedir que uma classe sofra hierarquia, basta defini-la com o token <code>sealed</code>. Isso automaticamente torna esse classe um classe final da hierarquia.</p>
<p>Quando o assunto é um membro de classe (atributo, método ou propriedade) a ideia é bem parecida. Basta usarmos o token <code>sealed</code> para impedir que outros programadores façam uma modificação em algum membro de classe que não temos a intenção que seja alterado por meio de um <code>override</code>.</p>
<p>Como exemplo, o professor da matéria nos dá um método de validação de usuário:
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">protected</span><span class="w"> </span><span class="k">sealed</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">validateUser</span><span class="p">()</span>
</code></pre></div>
Se não atribuirmos o selamento do método, é possível que algum programador mal intencionado possa modificar nosso método por algo como:
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">protected</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">validateUser</span><span class="p">()</span>
<span class="p">{</span>
<span class="k">return</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Desse modo, nosso método de validação se tornou completamente inútil. Entretanto, da maneira que construímos, o programa do programador mal intencionado retornará um erro porque ele está tentando usar polimorfismo em um membro de classe selado.</p>
<p>Outra vantagem além da segurança é a performance. Como aquela classe não será mais hierarquizada, o compilador trabalhará com ela de um modo a não se preocupar com associações dinâmicas existentes em classes com polimorfismo.</p>
<p><strong>Comparando Private e Sealed</strong></p>
<p>Uma dúvida que pode surgir é a respeito da diferença prática entre usarmos o escopo <code>private</code> para controle de acesso e o <code>sealed</code> para controle de hierarquia.</p>
<p>Vamos aos comparativos:</p>
<ul>
<li>
<p>Private</p>
<ul>
<li>Não podem ser declarados no namespace (apenas dentro de uma classe)</li>
<li>Não permitem instâncias</li>
<li>Acesso aos membros apenas no bloco de declaração</li>
</ul>
</li>
<li>
<p>Sealed</p>
<ul>
<li>Podem ser declaradas no namespace</li>
<li>Permitem instanciamento (dependendo se for public, private ou protected)</li>
<li>Membros de instâncias podem ser acessados por meio dos seus objetos e métodos</li>
</ul>
</li>
</ul>
<p>Em uma análise básica, o private também é um tipo de controle. Mas o sealed permite que as classes ainda permitam que seus métodos sejam acessíveis às classes filhas sem que possam alterar seus membros e, no caso de uma classe selada, temos a vantagem de instanciamento e criação no namespace.</p>
<p>Abaixo temos um exemplo da implementação desses conceitos.
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ClassesSealed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Extensivel</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Primeiro</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Extensível: primeiro método.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Segundo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Extensível: segundo método.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Aqui temos uma classe estendível com dois procedimentos que apenas imprimem saídas no </span>
<span class="w">    </span><span class="c1">// terminal. Agora vamos acompanhar como podemos interagir com ela usando o token `sealed`. </span>

<span class="w">    </span><span class="c1">// classe com membro selado</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">MembroSelado</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Extensivel</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">sealed</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Primeiro</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Membro Selado: primeiro método.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Segundo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Membro Selado: segundo método.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// classe selada filha da classe de membros selados</span>
<span class="w">    </span><span class="k">sealed</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Selada</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">MembroSelado</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Tentativa de sobrepor um método selado</span>
<span class="w">        </span><span class="c1">// error: &#39;Selada.Primeiro()&#39;: cannot override inherited member &#39;MembroSelado.Primeiro()&#39;</span>
<span class="w">        </span><span class="k">protected</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Primeiro</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Selada: primeiro método.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// esse nao retorna erro</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Segundo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Selada: segundo método.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Tentativa de extender uma classe selada.</span>
<span class="w">    </span><span class="c1">// error: &#39;Sobreposição&#39;: cannot derive from sealed type &#39;Selada&#39;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Sobreposicao</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Selada</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">protected</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Primeiro</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Sobreposicao: primeiro método.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Segundo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Sobreposicao: segundo método.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">MainClass</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;O código não compila.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="polimorfismo-parametrico">Polimorfismo Paramétrico</h3>
<p>Tudo o que estudamos sobre polimorfismo que usa herança para reutilização de códigos com a estenção dos métodos é chamado do <strong>polimorfismo de inclusão</strong>. Agora, vamos aprender sobre outro tipo de polimorfismo.</p>
<p>Imagine que temos que resolver um problema em uma classe e, no processo de ponderação da solução, nos deparamos com uma outra classe que contém um método que resolve o nosso problema. Podemos reutilizar métodos entre classes que <strong>não</strong> compartilham a mesma hierarquia? A resposta é sim. Isso é o que chamamos de <strong>polimorfismo paramétrico</strong>.</p>
<p>Nesse tipo de polimorfismo, nós não precisamos instanciar um novo objeto a partir da classe. Podemos fazer uso diretamente dos métodos desse tipo especial de classe chamada de <strong>classe genérica</strong>.</p>
<h4 id="tipos-genericos">Tipos Genéricos</h4>
<p>Tal qual o polimorfismo de inclusão, teremos um novo token usado na construção das classes em que usaremos o polimorfismo paramétrico. Chamamos de <strong>classes genéricas</strong> as classes que são criadas sem um tipo de dados especificado. O tipo de dado que essa classe trabalhará será passado como um parâmetro<sup id="fnref:9"><a class="footnote-ref" href="#fn:9">9</a></sup>.</p>
<p>A declaração de uma classe genérica é feita do mesmo modo da declaração de uma classe normal com a inclusão do token <code>&lt;&gt;</code> após o nome da classe que dará a declaração do tipo.</p>
<p>A declaração de um objeto instanciado de uma classe genérica é feita com a passagem do parâmetro do tipo de dado a ser manipulado no objeto. Diferente das classes abstratas, não precisamos instanciar com a criação de um novo objeto nomeado. Podemos apenas passar o tipo de dado e fazer uso dos métodos da classe diretamente por meio de um ponto seguido do nome do método (<code>classeGenerica.metodo(new T)</code>).</p>
<p>Assim como os tipos abstratos, dentro de uma classe genérica podemos ter membros de classes (métodos, atributos e propriedades) passados como sendo de tipo genéricos. A única condição é que seja usada a variável declarada na assinatura da classe (ela está dentro dos sinais <code>&lt;&gt;</code>.</p>
<p>Abaixo temos um exemplo de construção de um programa que julga se dois conjuntos são disjuntos<sup id="fnref:10"><a class="footnote-ref" href="#fn:10">10</a></sup>.</p>
<p><strong>Comentário:</strong> Não se preocupe se não entender o algoritmo de primeira. Eu tentei ser bem generoso nos comentários mas esse programa é, na minha opinião, desafiador de ser compreendido por quem não tem um background de matemática e programação um pouco desenvolvido. Leia quantas vezes for necessário e, se a dúvida persistir, entra em contato comigo pela issue do github.</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Generics</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// criacao da classe generica</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Conjuntos</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// criacao de uma funcao como membro estatico</span>
<span class="w">        </span><span class="c1">// que retorna um booleano para os vetores &quot;s&quot; e &quot;w&quot;</span>
<span class="w">        </span><span class="c1">// do tipo de dado definido por &quot;&lt;T&gt;&quot;</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">disjuntos</span><span class="p">(</span><span class="n">T</span><span class="p">[]</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">[]</span><span class="w"> </span><span class="n">w</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// loop em todos os elementos do vetor &quot;s&quot;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// loop em todos so elementos do vetor &quot;w&quot;</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// Teste: O elemento s[i] é igual ao w[j]?</span>
<span class="w">                </span><span class="c1">// se sim, eles possuem algum elemento em comum</span>
<span class="w">                </span><span class="c1">// logo, nao sao conjuntos disjuntos!</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Equals</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// se nenhum dos elementos dos dois conjuntos</span>
<span class="w">        </span><span class="c1">// for igual ao do outro, entao sao conjuntos</span>
<span class="w">        </span><span class="c1">// disjuntos!</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Programa Principal</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">MainClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Conjuntos</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">.</span><span class="n">disjuntos</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">5</span><span class="p">},</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="m">2</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">6</span><span class="p">}))</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Conjuntos Disjuntos!&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;conjuntos não Disjuntos!&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
Perceba como usamos o método <code>disjuntos()</code> sem que houvesse a necessidade de instanciamento de um novo objeto com o token <code>new Conjuntos</code>. Só precisamos dizer qual o tipo de dado e construir diretamente no método os conjuntos que seriam avaliados pelo método.</p>
<h4 id="colecoes">Coleções</h4>
<p>Uma <strong>coleção</strong> ou <strong>collection</strong> é um objeto que agrupa múltiplos objetos. Elas padronizam o tratamento dos objetos dentro do programa por meio da uma interface genérica.</p>
<p>Mas paremos pra pensar 1 minuto. Nós já não tínhamos definido um conjunto de objetos como um <strong>namespace</strong>? Sim! Uma coleção é um namespace nativo que nos fornecem métodos otimizados para o tratamento de dados de maneira a tornar nossos programas o mais eficiente possível.</p>
<p><strong>Comentário:</strong> Eu gosto de pensar nas coleções como um "kit de ferramentas" que já nos fornecem maneiras de lidar com problemas comuns. Mais vale aprender bem quais ferramentas o .NET nos dá nativamente do que perder horas e horas reinventando a roda.</p>
<p>Aqui vamos aprender sobre algumas das coleções que certamente usaremos várias vezes ao longo da nossa trajetória de desenvolvedores c#. Mas antes de irmos direto para elas, vamos aprender algumas características em comum que podemos avaliar para definir quando e onde implementar alguns de seus objetos.</p>
<p>Podemos elencar as seguintes funcionalidades comuns às coleções:</p>
<ul>
<li>Adicionar itens</li>
<li>Remover itens</li>
<li>Pesquisar itens</li>
<li>Substituir itens</li>
<li>Copiar conjuntos de itens ou clonar</li>
<li>Retornar as propriedades de capacidade </li>
</ul>
<p><strong>Coleções em C#</strong></p>
<p>Existem 3 namespaces com as collections em c# (basta clicar para acessar a documentação oficial da microsoft):</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=net-6.0"><strong>System.Collections.Generic</strong></a> - Coleções genéricas usando polimorfismo paramétrico</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent?view=net-6.0"><strong>System.Collectons.Concurrent</strong></a> - Coleções genéricas para aplicações muilt-thread</li>
<li><a href="https://docs.microsoft.com/pt-br/dotnet/api/system.collections?view=net-6.0"><strong>System.Collections</strong></a> - Coleções não genéricas que usam polimorfismo de inclusão</li>
</ul>
<p>Aqui estão alguns objetos da coleção <code>System.Collections.Generic</code>:</p>
<ul>
<li><code>Dictionary&lt;TKey,TValue&gt;</code></li>
<li><code>List&lt;T&gt;</code></li>
<li><code>Queue&lt;T&gt;</code></li>
<li><code>SortedList&lt;TKey,TValue</code></li>
<li><code>Stack&lt;T&gt;</code></li>
</ul>
<p>Aqui estão alguns objetos da coleção <code>System.Collections.Concurrent</code>:</p>
<ul>
<li><code>BlockingCollection&lt;T&gt;</code></li>
<li><code>ConcurrentDictionary&lt;TKey,TValue&gt;</code></li>
<li><code>ConcurrentQueue&lt;T&gt;</code></li>
<li><code>ConcurrentStack&lt;T&gt;</code></li>
</ul>
<p>Aqui estão alguns objetos da coleção <code>System.Collections</code>:</p>
<ul>
<li><code>ArrayList</code></li>
<li><code>Hashtable</code></li>
<li><code>Queue</code></li>
<li><code>Stack</code></li>
</ul>
<p>Por agora, vamos apenas citar a existência dessas coleções mas é <strong>mandatório</strong> que saibamos usar esses objetos para uma produção de software mais profissional com c#.</p>
<p><strong>Classe Collection&lt;T></strong></p>
<p>Essa coleção fornece a base para implementação de tipos genéricos de dados. As classes anteriores manipulam os métodos fornecidos justamente por <code>Collection&lt;T&gt;</code>. A documentação oficial dessa classe pode ser encontrada nesse <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.collection-1?view=net-6.0">link</a>. Agora vamos aprender um pouco sobre essa classe.</p>
<p>Construtores: <br>
Podemos iniciar uma coleção vazia com <code>Collectoin&lt;T&gt;()</code> ou podemos passar os valores de um objeto anteriormente criado como, por exemplo, <code>Collection&lt;T&gt;(IList&lt;T&gt;)</code>.</p>
<p>Propriedades:</p>
<ul>
<li><code>Count</code> - Retorna o número de elementos</li>
<li><code>Items</code> - Retorna uma lista dos elementos do tipo <code>Ilist</code><sup id="fnref:13"><a class="footnote-ref" href="#fn:13">11</a></sup></li>
<li><code>Item[Int32]</code> - Retorna ou altera um elemento em uma posição da lista. Index inicial é 0.</li>
</ul>
<p>Métodos de manipulação de elementos:</p>
<ul>
<li><code>Add(T)</code> - Insere um elemento no final</li>
<li><code>Remove(T)</code> - Remove a primeira ocorrência do elemento</li>
<li><code>SetAt(Int32, T)</code> - Insere um elementa na posição</li>
<li><code>Remove(Int32)</code> - Remove um elemento na posição</li>
<li><code>IndexOf(T)</code> - Retorna o index de um elemento</li>
<li><code>Contains(T)</code> - Bolleano para verificar se um elemento está na coleção</li>
</ul>
<p>Métodos de manipulação de conjuntos de elementos:</p>
<ul>
<li><code>Clear()</code> - Remove todos os elementos</li>
<li><code>CopyTo(T[], Int32)</code> - Copia a Collection<T> para um vetor</li>
<li><code>Equals(Object)</code> - Compara duas coleções</li>
</ul>
<p>A vantagem do uso do <code>Collection&lt;T&gt;</code> é que o c# já sabe como otimizar o uso de memória para esse tipo genérico de dados. Isso retira a necessidade de gestão de armazenamento para soluções que envolvam manipulação de grandes volumes de dados.</p>
<h4 id="delegates-funcoes-lambda-e-eventos">Delegates, Funções Lambda e Eventos</h4>
<p>Para o fechamento da nossa unidade de polimorfismo paramétrico temos três conceitos avançados de programação.</p>
<h5 id="delegates-delegacoes">Delegates (Delegações)</h5>
<p>Essa estrutura nos permite passar uma referência de um método para outras classes. A sintaxe do método com delegação é parecida com a de um método qualquer com a adição do token <code>delegate</code>:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">public</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Exibir</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">mensagem</span><span class="p">);</span>
</code></pre></div>
Nós iniciamos o delegate passando o método como parâmetro. Por exemplo, se quisermos usar o método <code>Exibir()</code> acima para executar métodos que mostram mensagens. Podemos fazer do seguinte modo:
"
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Metodo que printa mensagem no console</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">MensagemConsole</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">mensagem</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">mensagem</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Delegate com o tipo string de input e</span>
<span class="w">    </span><span class="c1">// tipo void de metodo</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Mensageiro</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Exibir</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">mensagem</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Como o nosso delegate foi criado para um void com string</span>
<span class="w">    </span><span class="c1">// e o nosso metodo MensagemConsole tambem possui essas</span>
<span class="w">    </span><span class="c1">// caracteristicas, podemos &quot;puxar&quot; esse metodo para</span>
<span class="w">    </span><span class="c1">// o nosso procedimento delegado Mensageiro</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Mensageiro</span><span class="p">.</span><span class="n">Exibir</span><span class="w"> </span><span class="n">exibir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Mensageiro</span><span class="p">.</span><span class="n">Exibir</span><span class="p">(</span><span class="n">MensagemConsole</span><span class="p">);</span>
<span class="w">        </span><span class="n">exibir</span><span class="p">(</span><span class="s">&quot;Mensagem no console!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Alguns podem se perguntar qual a utilidade de se puxar um método de outra classe. Agora observe essa modificação do código:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Class1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Metodo que printa mensagem no console</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">MensagemConsole</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">mensagem</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">mensagem</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Delegate com o tipo string de input e</span>
<span class="w">        </span><span class="c1">// tipo void de metodo</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Mensageiro</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">public</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Exibir</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">mensagem</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Class2</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Como o nosso delegate foi criado para um void com string</span>
<span class="w">        </span><span class="c1">// e o nosso metodo MensagemConsole tambem possui essas</span>
<span class="w">        </span><span class="c1">// caracteristicas, podemos &quot;puxar&quot; esse metodo para</span>
<span class="w">        </span><span class="c1">// o nosso procedimento delegado Mensageiro</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Class1</span><span class="p">.</span><span class="n">Mensageiro</span><span class="p">.</span><span class="n">Exibir</span><span class="w"> </span><span class="n">exibir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Class1</span><span class="p">.</span><span class="n">Mensageiro</span><span class="p">.</span><span class="n">Exibir</span><span class="p">(</span><span class="n">Class1</span><span class="p">.</span><span class="n">MensagemConsole</span><span class="p">);</span>
<span class="w">            </span><span class="n">exibir</span><span class="p">(</span><span class="s">&quot;Mensagem no console!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Perceba que agora, estamos fazendo referência ao método <code>MensagemConsole</code> no delegate que estão em <strong>outra classe</strong> sem qualquer relação de hierarquia entre as classes 1 e 2! O poder do delegate está justamente na capacidade de passarmos métodos sem o vínculo formal das hierarquias.</p>
<p>A documentação oficial dessa estrutura é encontrada nesse <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/">link</a>.</p>
<h5 id="funcoes-anonimas-lambda">Funções Anônimas (Lambda)</h5>
<p>Essa é uma das estruturas que possuem várias implantações práticas. Até agora, todas as funções que criamos tinham de ter um nome associado. Entretanto, c# e outras linguagens modernas permitem criar funções específicas que podem ser executadas sem a necessidade de criação de um objeto para elas.</p>
<p>Temos algumas maneiras de usar as funções lambda em c#. A primeira delas é com uso do delegate:
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="n">classe</span><span class="w"> </span><span class="n">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// delegate com int e dois valores inteiros</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Soma</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// aqui estamos declarando a forma</span>
<span class="w">        </span><span class="c1">// funcional da funcao Soma(x,y)</span>
<span class="w">        </span><span class="c1">// sintaxe 1</span>
<span class="w">        </span><span class="n">Soma</span><span class="w"> </span><span class="n">soma1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// sintaxe 2</span>
<span class="w">        </span><span class="n">Soma</span><span class="w"> </span><span class="n">soma2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
Agora vamos aprender como usar funções lambdas com o uso da classe <code>Func&lt;T, TResult&gt;</code></p>
<div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// sintaxe 1</span>
<span class="w">        </span><span class="n">Func</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">soma1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// sintaxe 2</span>
<span class="w">        </span><span class="n">Func</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">soma2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="events">Events</h5>
<p>Por fim, vamos aprender como uma classe pode publicar notificações para classes assinantes. Isso mesmo, estamos falando aqui de comunicação entre classes. Esse modelo de comunicação é chamado de <strong>Publish-Subscribe (Pub-Sub)</strong> e funciona baseado em dois tipos de classes. As <strong>classes assinantes</strong> se registram na <strong>classe geradora</strong> dos eventos para que as mesmas sejam notificadas quando uma mudança de estado acontecer.</p>
<p>Os exemplos mais clássicos são relacionados à interação do usuário humano como: clique do mouse, novo email, teclas apertadas, cópia de arquivo finalizada e etc.</p>
<p>A classe assinante registra <strong>um método de chamada de retorno</strong>, denominado de <strong>callback</strong><sup id="fnref:11"><a class="footnote-ref" href="#fn:11">12</a></sup> que é executado quando a condição do evento é satisfeita na classe geradora.</p>
<p>Chamamos de <strong>hook</strong> o processo de adicionar um callback em um evento e, logicamente, chamamos o contrário disso de <strong>unhook</strong>.</p>
<p>Abaixo temos um exemplo em que "acordaremos" as classes registradas no alarme:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// c#</span>
<span class="c1">// Classe geradora</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Alarme</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// delegate Acordar que sera usado como</span>
<span class="w">    </span><span class="c1">// callback do evento</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Acordar</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// evento que vai chamar o metodo Acordar</span>
<span class="w">    </span><span class="c1">// em cada assinante sendo que sao as classes</span>
<span class="w">    </span><span class="c1">// assinantes que vao inserir os callbacks</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">Acordar</span><span class="w"> </span><span class="n">TempoEsgotado</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// void para disparar o evento</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">DisparaEvento</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">AoEsgotarTempo</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">AoEsgotarTempo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// verifica se existem assinantes do evento</span>
<span class="w">        </span><span class="c1">// se alguma classe tiver assinado por</span>
<span class="w">        </span><span class="c1">// meio do hook de callback o TempoEsgotado nao</span>
<span class="w">        </span><span class="c1">// vai ser null</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">TempoEsgotado</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">TempoEsgotado</span><span class="p">(</span><span class="s">&quot;Tempo Esgotado!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Classe assinante</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// callback da classe assinante</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">MensagemConsole</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">mensagem</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// programa</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Alarme</span><span class="w"> </span><span class="n">alarme</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Alarme</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// hook do callback no alarme com o</span>
<span class="w">        </span><span class="c1">// metodo MensagemConsole</span>
<span class="w">        </span><span class="n">alarme</span><span class="p">.</span><span class="n">TempoEsgotado</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">MensagemConsole</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// disparando o evento para receber</span>
<span class="w">        </span><span class="c1">// a mensagem do callback</span>
<span class="w">        </span><span class="n">alarme</span><span class="p">.</span><span class="n">DisparaEvento</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<strong>Comentário:</strong> De todas as seções desse microfundamento, essa é provavelmente a que mais contém conceitos que diferenciam os programadores .NET iniciantes dos mais experientes. O uso dessas três categorias de polimorfismo paramétrico fazem muita diferença na qualidade do seu código e devem ser entendidas muito profundamente.</p>
<h3 id="projeto-orientado-para-objetos">Projeto Orientado para Objetos</h3>
<p>O objetivo de qualquer programador profissional é produzir códigos de qualidade. Nessa última parte do microfundamento, vamos aprender sobre alguns normativos que regem os princípios e práticas para construção de programas com essas qualidades.</p>
<p>Os princípios que vamos aprender aqui são uma maneira de se produzir código fácil de ler, fácil de modificar e fácil de testar. De modo a permitir que um time de desenvolvedores atue de forma colaborativa.</p>
<p><strong>Comentário:</strong> Uma boa maneira de saber se estamos indo bem é sempre olhar os nossos códigos se perguntando "Outra pessoa poderia continuar o meu trabalho se eu sair desse projeto?" ou "Caso eu precise trabalhar com alguém, essa pessoa conseguirá entender o meu código apenas olhando diretamente para ele?".</p>
<h4 id="principios-solid">Princípios SOLID</h4>
<p>Os princípios que vamos estudar agora foram introduzidos por Robert C. Martin (também conhecido como Uncle Bob) no artigo <a href="http://staff.cs.utu.fi/staff/jouni.smed/doos_06/material/DesignPrinciplesAndPatterns.pdf">Design Principles and Design Patterns</a>. Posteriormente, os conceitos foram desenvolvidos por Michael Feathers e ganharam o acrônimo SOLID. Nos últimos 20 anos, esses princípios têm impacto fortemente o mundo das programação orientada à objetos e devem ser compreendidos e internalizados por quem se propõe a entrar nessa jornada.</p>
<p><img alt="36-uncle-bobo-e-feathers.jpg" src="../../../../assets/imgs/36-uncle-bobo-e-feathers.jpg" /></p>
<p>Os princípios SOLID são um conjunto de boas práticas de projeto de software que nos permitem construir sistemas com extensibilidade, reusabilidade, adaptabilidade e manutenibilidade. O objetivo é manter a complexidade de uma solução constante mesmo com o crescimento do tamanho dos módulos.</p>
<p>Os princípios SOLID são:</p>
<ul>
<li><strong>S</strong>ingle Responsability Principle (SRP)</li>
<li><strong>O</strong>pen/Closed Principle (OCP)</li>
<li><strong>L</strong>iskov Substitution Principle (LSP)</li>
<li><strong>I</strong>nterface Segregation Principle (ISP)</li>
<li><strong>D</strong>ependency Inversion Principle (DIP)</li>
</ul>
<p>Fonte: Martin, Robert Cecil (2002). Agile software development: principles, patterns, and practices. Upper Saddle  River, NJ: Pearson Education. ISBN 9780135974445.</p>
<p><strong>Single Responsability Principle - SRP</strong></p>
<p>"Uma classe deve ter apenas um motivo para mudar, o que significa que ele deve ter uma única função"</p>
<p>Se, na construção das classes, usarmos os outros princípios de coesão e encapsulamento que já aprendemos anteriormente, o SRP é consequência direta. Como cada classe deve ter uma razão de existir o mais específica e clara possível, cada classe deve ser facilmente definida e deve ter apenas uma função.</p>
<p>Para Roger Whitney, 2016, Advanced Object-Oriented Design \&amp; Programming, se você precisar de mais de 25 palavras (uma frase) com o uso dos conectivos "e" ou "ou" para definir o que é uma determinada classe, significa que o SRP já não foi observado.</p>
<p>As classes precisam ter uma razão objetiva e compacta para existir.</p>
<p><strong>Open/Closed Principle - OCP</strong></p>
<p>"Objetos ou entidades devem ser abertos para extensão, mas fechados para modificação"</p>
<p>Aberto para extensão significa que temos que pensar em classes abstratas e interfaces que permitam novas classes concretas que estendam suas funções sem que haja modificação nas classes anteriores. Isso evita termos que adaptar uma classe que seja referência para várias outras constantemente, evitando o risco de quebras em cascata por conflito de herança.</p>
<p><strong>Liskov Substitution Principle - LSP</strong></p>
<p>"Se q(x) é uma propriedade demonstrável dos objetos x de tipo T. então q(y) deve ser verdadeiro para objetos y de tipo S, onde S é subtipo de T"</p>
<p>Essa maneira de definir é derivada da formalização matemática mas, em resumo, se S e é uma subclasse de T. Se temos uma propriedade q() que funciona em T, essa propriedade deve ser herdada para S devido a sua herança.</p>
<p>Isso implica que podemos sempre Substituir objetos por seus subtipos sem prejuízo porque todos os métodos do objeto anterior devem ser herdados pelos objetos filhos.</p>
<p><strong>Interface Segregation Principle - ISP</strong></p>
<p>"Classes não devem ser forçadas a implementar uma interface que não usam, ou seja, não devem ser forçadas a depender de métodos que não usam"</p>
<p>Como contraponto ao LSP, uma classe não deve ter comportamentos (ou métodos) que não façam sentidos a ela. Esse controle é obtido pela separação em classes diferentes para que as classes sempre possuam apenas o necessário.</p>
<p><strong>Dependency Inversion Principle - DIP</strong></p>
<p>"Módulos de alto nível não devem depender de módulos de baixo nível. Ambos devem depender de abstrações"</p>
<p>Na construção de soluções complexas, temos que evitar referenciamento para objetos concretos. As referências devem ser sempre para tipos abstratos que podem ser instanciados em situações concretas de uso.</p>
<p>Outra implicação do DIP é que não devemos derivar classes de uma classe concreta. As classes base devem ser sempre abstratas porque assim permitem que as subclasses sejam expandidas a medida que novos problemas e melhorias são inseridas no processo.</p>
<p>Nenhum método deve sobrescrever os que foram herdados da sua classe base. Ao fazer isso, corremos o risco de violar o LSP porque aumentamos o risco da propriedade (ou método) da classe base não se comportar como o previsto na classe derivada após a sua modificação.</p>
<h4 id="padroes-de-projeto">Padrões de Projeto</h4>
<p>Para concluir nossa jornada (inicial) no mundo da programação modular, vamos aprender mais sobre <strong>Padrões de Projetos</strong> que são maneiras de organizar uma solução para resolver problemas relativamente comuns ao processo de Engenharia de Software. Eles são modelos que precisam ser adaptados aos casos concretos e não metodologias dogmáticas.</p>
<p>Um padrão foca apenas nos aspectos essenciais da construção do projeto e os detalhes são omitidos porque cada projeto possui especificidades únicas.</p>
<p>Fonte: Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. 1995. Design patterns: elements of reusable object-oriented software. Addison-Wesley Longman Publishing Co., Inc., USA.</p>
<p>O começo dos padrões computacionais é referido à Beck e Cunningham que apresentaram suas ideias na conferência OOPSLA (Object-Oriented Programming, Systems, Languages, and Applications) em 1987 para uma linguagem famosa na época chamada Smalltalk.</p>
<p>Posteriormente, os trabalhos de Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides que ficaram conhecidos como "Gang of Four" foram responsáveis pela popularização dessa linha de conhecimento no processo de construção de soluções. Os padrões apresentados por eles em 1995 ficaram conhecidos como GoF Patterns.</p>
<p>O foco dos padrões é a <strong>reutilização de código</strong>. Esse objetivo é alcançado porque os padrões capturam anos de experência em Engenharia de Software e fornecem soluções para definição da Arquitetura dos sistemas. Como o insumo desse conhecimento é a prática de vários profissionais, o resultado da utilização desses padrões costuma ser satisfatório se seguido da maneira correta.</p>
<p><strong>Estrutura de um Padrão de Projeto</strong></p>
<p>Existe uma lista de elementos comuns em um padrão de projeto:</p>
<ul>
<li><strong>Nome</strong>: Resume a proposta da solução</li>
<li><strong>Problema</strong>: Resumo o objetivo a ser resolvido</li>
<li><strong>Contexto</strong>: Situações de aplicação ideal</li>
<li><strong>Solução</strong>: Relacionamento entre as entidades</li>
<li><strong>Exemplo</strong>: Diagramas ilustrativos da solução</li>
</ul>
<p>A capacidade de reutilização dos padrões de projeto é devida a duas características centras nas linguagens orientadas à objeto: composição e herança.</p>
<p>A <strong>composição</strong> é entendida como o reuso por <strong>delegação</strong>. Se um objeto não pode executar determinada tarefa (porque poderíamos ferir um princípio SOLID, por exemplo) ele delega essa função a outro objeto através da troca de mensagens. Desse modo podemos ter o reuso de funções entre objetos que não compartilham graus de hierarquia. Padrões com foco em composição são chamados de <strong>padrões de escopo de objeto</strong>.</p>
<p>A <strong>herança</strong> é uma abordagem que usa so vínculos entre subclasses e superclasses. Esse tipo de reuso costuma ser mais simples de implementar porque a lógica é mais natural e intuitiva, contudo, temos que tomar bastante cuidado para não violarmos os princípios da ocultação da informação nessa dinâmica entre classes derivadas e classes principais. Outro risco é a violação do LSP<sup id="fnref:12"><a class="footnote-ref" href="#fn:12">13</a></sup>. Padrões com foco na herança são chamados de <strong>padrões de escopo de classe</strong>.</p>
<p>Existe uma regra de bolso no mercado que é incorporada na frase "favorecer composição sobre herança". Mesmo que o c# permita uma ampla flexibilidade nessas duas abordagens, as vezes é melhor abrir mão de funcionalidades disponíveis em favor de um maior controle de gestão das soluções desenvolvidas.</p>
<p><strong>Tipos de Padrões</strong></p>
<p>No livro da Gang of Four (1995) temos a classificação dos pradrões em 3 grandes grupos: Criacionais, Estruturais e Comportamentais.</p>
<p>Padrões <strong>Criacionais</strong> são padrões que focam na abstração do processo de criação de objetos. Costumam ser mais relacionados à inicialização e configuração de objetos. Alguns exemplos de padrões desse grupo são: Abstract Factory, Builder, Prototype, Singleton.</p>
<p>Padrões <strong>Estruturais</strong> tratam do desacoplamento entre interface e implmentação dos objetos. Estão mais relacionados à composição de objetos. Exemplos de padrões desse tipos são: Object Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.</p>
<p>Padrões <strong>Comportamentais</strong> são focados na definição de mecanismos de colaboração entre objetos. Mais relacionados à distribuição de responsabilidades e padronização de comunicações. Exemplos de padrões desse tipos são: Chain of Responsability, Comand Iterator, Mediator, Memento, Observer, State, Strategy, Visitor.</p>
<p><strong>Comentário:</strong> Essa parte final é só uma introdução geral aos conceitos de padrões de projeto. Existe um mundo a ser explorado nesse tópico mas agora estamos cientes da existência dele e já temos algumas referências iniciais para aprofundarmos o conhecimento.</p>
<h2 id="bibliografia">Bibliografia</h2>
<ul>
<li>MCGEE, Pat. <strong>C#: A Beginner's Guide</strong>. New York: McGraw-Hill Education, 2014 (O’Reilly Media).</li>
<li>MARTIN, Robert C.; MARTIN, Micah; TORTELLO, João E. N. <strong>Princípios, padrões e práticas ágeis em C#</strong>. Porto Alegre: Bookman, 2011. E-book ISBN 9788577808427.</li>
<li>GAMMA, Erich et al. Padrões de projeto: soluções reutilizáveis de software orientado a objetos. Porto Alegre: Bookman, 2000. E-book. ISBN 9788577800469.</li>
<li>LISKOV, Barbara: <strong>Data abstraction and hierarchy</strong>, 1987.</li>
<li>MARTIN, Robert C. <strong>Agile software development: principles, patterns, and practices</strong>. Upper Saddle River, NJ: Pearson Education. 2002. ISBN 9780135974445.</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Esse conceito é visto no estudo das funções matemáticas.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Usaremos muitas vezes esse conceito ao longo dessa matéria.&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>Uma das definições da palavra instância no contexto da ciência da computação é justamente "um objeto cujo comportamento e estado são definidos por uma classe".&#160;<a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Só prossiga quando essa frase tiver pleno sentido na sua mente.&#160;<a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>Que também podemos chamar de classe.&#160;<a class="footnote-backref" href="#fnref:5" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>Ou seja, atributo ou método da classe.&#160;<a class="footnote-backref" href="#fnref:6" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>Os manuais de qualidade de código ainda impõe um limite máximo de 100 linhas para essas implementações. Programador bom é programador que resolve o problema com <strong>poucas</strong> linhas de código.&#160;<a class="footnote-backref" href="#fnref:7" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:8">
<p>Ele vai funcionar parecido com o token de referência this, por exemplo, base.function().&#160;<a class="footnote-backref" href="#fnref:8" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:9">
<p>Dai o nome paramétrico.&#160;<a class="footnote-backref" href="#fnref:9" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
<li id="fn:10">
<p>Ou seja, se não possuem nenhum elemento em comum.&#160;<a class="footnote-backref" href="#fnref:10" title="Jump back to footnote 10 in the text">&#8617;</a></p>
</li>
<li id="fn:13">
<p>A documentação desse tipo de lista pode ser lida <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.ilist?source=recommendations&amp;view=net-6.0">aqui</a>.&#160;<a class="footnote-backref" href="#fnref:13" title="Jump back to footnote 11 in the text">&#8617;</a></p>
</li>
<li id="fn:11">
<p>Esse termo é MUITO comum em vários contextos além desse. Agora você tem o conhecimento para entender muitas outras relações complexas em várias linguagens de programação.&#160;<a class="footnote-backref" href="#fnref:11" title="Jump back to footnote 12 in the text">&#8617;</a></p>
</li>
<li id="fn:12">
<p>Liskov Substitution Principle pois a classe derivada pode tentar sobrescrever uma propriedade da classe pai.&#160;<a class="footnote-backref" href="#fnref:12" title="Jump back to footnote 13 in the text">&#8617;</a></p>
</li>
</ol>
</div></p>
    </article>
</section>
<!-- endblock -->
            </main>

            
                    <!-- block preview -->
        <div class="row row-cols-md-3 text-center pt-md-3" id="component-preview">
            <div class="col themed-grid-col">
                <a rel="prev" href="../design_interacao/" class="nav-link">
                    <i class="fa fa-arrow-left"></i> Previous
                </a>
            </div>
            <div class="col themed-grid-col"></div>
            <div class="col themed-grid-col">
                <a rel="next" href="../dev_web_backend/" class="nav-link">
                    Next <i class="fa fa-arrow-right"></i>
                </a>
            </div>
        </div>
<!-- endblock -->
            

            
                    <!-- block footer -->
<footer class="pt-4 my-md-5 pt-md-5 border-top" id="component-footer">
    <div class="row">
        <div class="col-12 col-md">
                <!-- block copyright -->
    <small class="d-block mb-3">Bruno de Melo Ruas</small>

    <small class="d-block mb-3">
        Made with
        <a href="https://github.com/FernandoCelmer/mkdocs-simple-blog" target="_blank" rel="noopener">
            Simple Blog for MkDocs
        </a>
    </small>

<!-- endblock -->
        </div>
    </div>
</footer>
<!-- endblock -->
            
        </div>

            <script>var base_url = '../../../..';</script>
            <script src="../../../../assets/js/jquery-3.3.1.slim.min.js""></script>
            <script src="../../../../assets/js/bootstrap.bundle.min.js""></script>
            <script src="../../../../assets/js/main.min.js""></script>
                <script src="../../../../javascripts/config.js" defer></script>
                <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
                <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
                <script src="../../../../search/main.js" defer></script>
    </body>

</html>