{"searchDocs":[{"title":"Abrindo Chrome em Modo Debugg","type":0,"sectionRef":"#","url":"/CC_site/blog/chrome-debugger","content":"Code snippet para abrir chrome em modo debugg start chrome.exe --remote-debugging-port=9222 ","keywords":"","version":null},{"title":"Small Blog Post Model","type":0,"sectionRef":"#","url":"/CC_site/blog/first-blog-post","content":"Lorem ipsum dolor sit amet... ...consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"Long Blog Post Model","type":0,"sectionRef":"#","url":"/CC_site/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"MDX Blog Post Model","type":0,"sectionRef":"#","url":"/CC_site/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. dica Use the power of React to create interactive blog posts. For example, use JSX to create an interactive button: &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":"","version":null},{"title":"Template para State Diagram no Mermaid","type":0,"sectionRef":"#","url":"/CC_site/blog/mermaid-state-diagram-template","content":"Template de aplicação de Policy para tentativas em processos iterados. mermaid stateDiagram-V2 %% statements %% aliases %% subprocesses %% workflow ","keywords":"","version":null},{"title":"Template de Retry para processos iterados em .NET","type":0,"sectionRef":"#","url":"/CC_site/blog/template-retry-dotnet","content":"Template de aplicação de Policy para tentativas em processos iterados. private static TimeSpan GetIntervalInLoop(int retry) =&gt; TimeSpan.FromSeconds(Math.Pow(2, retry)); await Policy .Handle&lt;Exception&gt;() .WaitAndRetryAsync(N_TENTATIVAS, (x) =&gt; GetIntervalInLoop(x)) .ExecuteAsync(async () =&gt; { // bloco de código a ser executado }); ","keywords":"","version":null},{"title":"Pensamentos e Rascunhos","type":0,"sectionRef":"#","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/notes","content":"","keywords":"","version":"Next"},{"title":"Machine Learning Tradicional x IA Generativa​","type":1,"pageTitle":"Pensamentos e Rascunhos","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/notes#machine-learning-tradicional-x-ia-generativa","content":" ML Tradicional -&gt; mapping de um conjunto pra outro Gen AI -&gt; tem foco em prever o próximo token (modelo fundacional)  ","version":"Next","tagName":"h2"},{"title":"Tools​","type":1,"pageTitle":"Pensamentos e Rascunhos","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/notes#tools","content":" Bedrock -&gt; AWS interface para IA Langchain -&gt; ? Langgraph -&gt; ? Streamlit -&gt; ? ","version":"Next","tagName":"h2"},{"title":"Complex Long Blog Post Model","type":0,"sectionRef":"#","url":"/CC_site/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Here are a few tips you might find useful. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":"","version":null},{"title":"Terminologia","type":0,"sectionRef":"#","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia","content":"","keywords":"","version":"Next"},{"title":"Conceitos​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#conceitos","content":" ","version":"Next","tagName":"h2"},{"title":"Prompt Engineering​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#prompt-engineering","content":" É a arte de criar inputs para os modelos que produzam resultados acurados, constantes e úteis. Normalmente, usando contexto, instrução e exemplo para direcionar o resultado corretamente.  Fontes: Youtube, Roadmap  ","version":"Next","tagName":"h3"},{"title":"Retrieval-Augmented Generation - RAG​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#retrieval-augmented-generation---rag","content":" Abordagem que combina a recuperação de informação com um modelo para criar retornos contextualizados. Primeiro, coletamos informação relevante em uma knowledge base para, depois, consultar o LLM para gerar respostas baseadas nessa informação.  Fontes: Datacamp, Google, Youtube  ","version":"Next","tagName":"h3"},{"title":"AI Agents​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#ai-agents","content":" Criados por instruções, conhecimento e ações. São softwares criados para executar tarefas mas que possuem uma ampla habilidade de decidir o &quot;como&quot; fazer essas tarefas. No core de um agent estão as LLMs que, por si só, não produzem nada além de texto.  Fontes: Youtube, Play.ht, Langchain  ","version":"Next","tagName":"h3"},{"title":"AI Agent Developer​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#ai-agent-developer","content":" Alguém que é responsável por customizar LLMs contidas em AI Agents para processos dedicados e internos como empresas de modo que a AI consegue ter acesso à ferramentas, conhecimento, infra necessária para realmente ter impacto nas empresas.  Fontes: Youtube, Play.ht, Langchain  ","version":"Next","tagName":"h3"},{"title":"Vector Databases​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#vector-databases","content":" São modelos de banco de dados otimizados para encontrar proximidade entre seus elementos uma vez que guardam valores baseados em uma lista de números. Além disso, permitem long term memory para modelos de aprendizado de máquina existentes de modo que, sem eles, seria necessário fazer o treinamento específico (chamado de fine-tuning) para adicionar novos conhecimentos aos LLMs. São centrais para RAG também.  Fontes: Cloudflare, Mongodb  ","version":"Next","tagName":"h3"},{"title":"Embedding​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#embedding","content":" Processo de converter inputs em vetores numéricos de várias dimensões. Desse modo, os modelos conseguem encontrar relações de similaridade baseado nos valores dos vetores.  Fontes: Youtube,Cloudflare,IBM  ","version":"Next","tagName":"h3"},{"title":"Model Training​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#model-training","content":" É o processo de usar um dataset para consumo de um algoritmo de ML de modo que o resultado da ingestão da informação é comparado com o resultado da amostra para que o modelo produza resultados próximos do esperado. Pode ser supervisionado ou não.  Fontes: AWS Documentation, Domino AI Blog, Oden Glossary  ","version":"Next","tagName":"h3"},{"title":"Inferência​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#inferência","content":" É o processo que um modelo já treinado usa para definir o output para dados novos. Diferente do treinamento, a inferência não possui gabarito1.  Fontes: Cloudflare, Hazelcast Foundations, DataCamp Blog  ","version":"Next","tagName":"h3"},{"title":"Large Language Models - LLM​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#large-language-models---llm","content":" Programa de AI treinado em um conjunto de dados massivo (centenas ou milhões de gigas) que são construídos através de machine learning, mais especificamente, por um tipo de rede neural (neural network) chamada transformer model e que possuem a capacidade de receber e gerar text.  Fontes: Cloudflare, YouTube, YouTube  ","version":"Next","tagName":"h3"},{"title":"Artificial Intelligence - AI​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#artificial-intelligence---ai","content":" Artificial Intelligence é um conjunto de várias subáreas. A ideia é superar ou equiparar a capacidade de um ser humano em descobrir informações novas, inferir dados baseados em inputs e capacidade de ponderar cenários e resultados.  Fonte: Youtube  ","version":"Next","tagName":"h3"},{"title":"Machine Learning - ML​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#machine-learning---ml","content":" Uma das áreas da AI é o Machine Learning que se refere ao treinamento de programas através da ingestão de dados para identificar features sem intervenção humana direta no &quot;como&quot; identificar. Pode ser com supervisão humana para avaliar os resultados ou não.  Fonte: Youtube  ","version":"Next","tagName":"h3"},{"title":"Deep Learning e Neural Networks​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#deep-learning-e-neural-networks","content":" Deep Learning é um tipo de ML que usa probabilidade e camadas para que o modelo se treine sem contato direto humano. Por sua vez, Neural Network é a arquitetura dos modelos que usam um sistema &quot;parecido&quot; com um cérebro humano.  Fontes: Cloudflare  ","version":"Next","tagName":"h3"},{"title":"AI vs AGI​","type":1,"pageTitle":"Terminologia","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/Terminologia#ai-vs-agi","content":" Artificial General Intelligence (AGI) é um campo teórico de pesquisa que tem como objetivo criar software com capacidade de inteligência comparada à humana e capacidade de autoensino, basicamente, um programa que pode aprender qualquer coisa. AI já possui um escopo fechado onde os programas utilização restrições (como a quantidade de parâmetros) para resolver tarefas pré-definidas e que foram treinad.  Fontes: AWS - Artificial General Intelligence, Forbes - Difference Between AI and AGI    Footnotes​ Nem sempre tem gabarito para os treinamentos também, vide aprendizado não supervisionado. ↩ ","version":"Next","tagName":"h3"},{"title":"AI Engineer ou ML Engineer?","type":0,"sectionRef":"#","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/ai-ml","content":"","keywords":"","version":"Next"},{"title":"Conceitos​","type":1,"pageTitle":"AI Engineer ou ML Engineer?","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/ai-ml#conceitos","content":" Já vimos os conceitos de AI e ML. De modo que, já sabemos que AI é um conjunto maior que contém o subconjunto ML. Dessa feita, não é estranho supor que as atividades desses dois tipos de engenheiros se sobreponham mas que também tenham escopos diferentes.  ","version":"Next","tagName":"h2"},{"title":"AI Engineer​","type":1,"pageTitle":"AI Engineer ou ML Engineer?","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/ai-ml#ai-engineer","content":" Podemos elencar algumas atividades:  Melhorar os fluxos de negócio através de softwareReduzir custosAumentar o valor agregado da entrega da empresa para os clientesDesenhar data pipelines para os processos de AIDesenvolver AI solutions que auxiliem ou substituam tarefas humanasCriar ferramentas de recomendação  Bem geral né? Mas basicamente ele tem que juntar engenharia de software e data science para guiar a empresa para inovação.  ","version":"Next","tagName":"h2"},{"title":"ML Engineer​","type":1,"pageTitle":"AI Engineer ou ML Engineer?","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/ai-ml#ml-engineer","content":" O escopo de um engenheiro de ML é um pouco mais fechado:  Criar algoritmo de MLExecutar sistemas de AI para testes e experimentosPerformar análises estatísticas  ","version":"Next","tagName":"h3"},{"title":"Fontes​","type":1,"pageTitle":"AI Engineer ou ML Engineer?","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/intro/ai-ml#fontes","content":" YouTube - VideoCoursera - Machine Learning EngineerCodecademy - AI Engineer ","version":"Next","tagName":"h2"},{"title":"Template para teste unitário em projetos .NET","type":0,"sectionRef":"#","url":"/CC_site/blog/template-unit-test-dotnet","content":"Melhor template de teste unitário que eu conheço para projeto .NET using Microsoft.Extensions.Configuration; using Moq.AutoMock; using Xunit; using AutoFixture; using Moq; private readonly IConfiguration _configuration = GetIConfiguration(); public static IConfiguration GetIConfiguration() { return (IConfiguration)new ConfigurationBuilder() .SetBasePath(Regex.Replace(Directory.GetCurrentDirectory(), &quot;\\\\\\\\bin.+&quot;, &quot;&quot;)) .AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true) .Build(); } public void First_template() { // Arrange var autoMocker = new AutoMocker(); var fixture = new Fixture(); fixture.Behaviors.Add(new OmitOnRecursionBehavior()); fixture.Behaviors.Remove(new ThrowingRecursionBehavior()); fixture.Inject(_configuration); // create the SUT class with all injection config mocked allready var SUT = autoMocker.CreateInstance&lt;ClassOfSut&gt;(); // if you need mock some injection configured behavior var someInjectedDependence = autoMocker.GetMock&lt;ClassOfInjectedDependecy&gt;(); someInjectedDependence.Setup().Returns(); // to create some object var someObject = fixture.Build&lt;ObjectClass&gt;() .With(x =&gt; x.SomePropertie, AsignedValue) .Create(); // to create a list of objects int qtdToCreate = 10; var listObjects = fixture.CreateMany&lt;classObjects&gt;(qtd) .Cast&lt;anotherClassIfNeeded&gt;() .ToList(); // rest of the test } public void Second_template() { // Arrange var autoMocker = new AutoMocker(); var fixture = new Fixture(); fixture.Behaviors.Add(new OmitOnRecursionBehavior()); fixture.Behaviors.Remove(new ThrowingRecursionBehavior()); fixture.Inject(_configuration); // create mocks for each param in this fashion var param1Mock = autoMocker.GetMock&lt;param1&gt;().Object; // create the SUT class with params mocked var SUT = new ClassToSut(param1Mock); // rest of the test } ","keywords":"","version":null},{"title":"Tickets","type":0,"sectionRef":"#","url":"/CC_site/docs/backlog","content":"","keywords":"","version":"Next"},{"title":"Aviso​","type":1,"pageTitle":"Tickets","url":"/CC_site/docs/backlog#aviso","content":" As informações aqui são meio genéricas de propósito porque eu não posso fornecer detalhes dos meus esforços alocados dentro de clientes. Por esse motivo, eu posso registrar apenas informações gerais mas que ainda podem mostrar um pouco da rotina de um desenvolvedor no mundo real.  Abaixo segue apenas uma amostragem do que eu venho enfrentado ao longo dos meus dias de desenvolvedor de software.  ","version":"Next","tagName":"h2"},{"title":"Backlog​","type":1,"pageTitle":"Tickets","url":"/CC_site/docs/backlog#backlog","content":"   DATA\tPROBLEMA/MELHORIA\tENTREGA\tCOMENTÁRIO01/2025\tProjeto Regulatório\tProjeto de Auditoria de cadastros\tRabbitMQ, sidecars, muito conhecimento de negócio, mapeamento de processos 12/2024\tProjeto\tEvolução relevante em serviço GoLang\tSNS, SQS, Policies AWS, Cloudformation, GoLang, Observabilidade, Métricas, Paralelismo 02/2024-11/2024\tProjeto\tEvolução relevante em serviço AngularReact + ASP.NET\tAuth Angular, permissionamento e Azure AD 01/2024\tFeat de integração SQS\tEvolução de projeto para integração SQS\tCI/CD azure pipe, RDS, SQS, SNS e Gestão de custo AWS 12/2023\tErro em save no banco\tFix nas telas do front com maxlength de string\tFluent validation 12/2023\tErro em save no banco\tFix no critério de update/save no backend 12/2023\tErro de front Angular+React\tFix no app\tAqui eu percebi que precisava me aprofundar nas regras de negócio 11/2023\tErro em rotina de batch\tFix no caso impactado 11/2023\tErro em busca\tFix no critério de bypass 11/2023\tErro no comportamento de cronjob\tFix em rotina impactada 10/2023\tSaneamento de dados\tRotina de RPA para update em endpoint 09/2023\tErro de concorrência\tFix para reconsulta de contrato nos steps\tEsse tipo de problema é bem complexo de debugar e encontrar 09/2023\tErro na info de um dashboard\tFix consulta SQL\tMeu primeiro contato com Presto 08/2023\tErro no retorno de uma pesquisa\tFix consulta elasticsearch 08/2023\tErro no retorno do GraphQL\tFix query GraphQL 07/2023\tConsulta num lake de dados Athena\tEndpoint, Service, Respository e update em um projeto Python\tTive que atuar tanto FastAPI quanto ASP.NET ","version":"Next","tagName":"h2"},{"title":"Sobre o Roadmap","type":0,"sectionRef":"#","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/sobre","content":"","keywords":"","version":"Next"},{"title":"AI Engineer​","type":1,"pageTitle":"Sobre o Roadmap","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/sobre#ai-engineer","content":" Como consta como resposta à pergunta &quot;What is an AI Engineer?&quot; no próprio roadmap:  An AI Engineer uses pre-trained models and existing AI tools to improve user experiences. They focus on applying AI in practical ways, without building models from scratch. This is different from AI Researchers and ML Engineers, who focus more on creating new models or developing AI theory. The advantages and disadvantages of AI are key considerations that AI Engineers must understand to effectively implement solutions.  Podemos ver que o objetivo aqui é aprender a usar IA mais do que criar IA. Então o foco aqui é aprender a construir coisas com modelos e ferramentas criadas e não construir modelos de AI do zero.  Atenção Eu só estou usando esse material porque o Akita usou o de backend na série de vídeos que ele fez sobre carreiras em dev. Mas no fim do dia, o que importa mesmo é começar e depois ir ajustando ao longo do curso.  ","version":"Next","tagName":"h2"},{"title":"Roadmap do projeto​","type":1,"pageTitle":"Sobre o Roadmap","url":"/CC_site/docs/archive/roadmapsh/ai-engineer/sobre#roadmap-do-projeto","content":"  Introduction AI Engineer vs ML Engineer Common Terminology Pre-trained Models Open AI Models Anthropic's Claude Google's Gemini Azure AI AWS Sagemaker Hugging Face MOdels Mistral AI Cohere Replicate OpenAI API Writing Prompts Managing Tokens Open AI Playground Fine-tuning Prompt Engineering Roadmap AI Safety and Ethics Prompt Injection Security and Privacy Bias and Fareness OpenSource AI Hugging Face Ollama Embeddings Semantic Search Data Classification Recommendation Systems Anomaly Detection Open AI Embeddings API Embedding Models Open-Source Embeddings Sentence Transformers Models on Hugging Faces Vector Databases Popular Vector DBs Implementing Vector Search RAG Implementing RAG Way of Implementing RAG AI Agents Agents Usecases ReAct Prompting Building AI Agents Multimodal AI Implementing Multimodal AI Usecases Multimodal AI Tasks Development Tools AI Code Editors Code Completion Tools ","version":"Next","tagName":"h2"},{"title":"Panorama do Curso","type":0,"sectionRef":"#","url":"/CC_site/docs/cursos/arquitetura-software/intro","content":"","keywords":"","version":"Next"},{"title":"Parte 1 - Fundamentos​","type":1,"pageTitle":"Panorama do Curso","url":"/CC_site/docs/cursos/arquitetura-software/intro#parte-1---fundamentos","content":" Em criação  ","version":"Next","tagName":"h2"},{"title":"Parte 2 - Domínios Ricos​","type":1,"pageTitle":"Panorama do Curso","url":"/CC_site/docs/cursos/arquitetura-software/intro#parte-2---domínios-ricos","content":" Em criação  ","version":"Next","tagName":"h2"},{"title":"Parte 3 - Testes de Software​","type":1,"pageTitle":"Panorama do Curso","url":"/CC_site/docs/cursos/arquitetura-software/intro#parte-3---testes-de-software","content":" Em criação ","version":"Next","tagName":"h2"},{"title":"Programação Orientada à Objetos","type":0,"sectionRef":"#","url":"/CC_site/docs/cursos/arquitetura-software/fundamentos-arq-soft/Object Orientation Programming","content":"","keywords":"","version":"Next"},{"title":"Principais Conceitos​","type":1,"pageTitle":"Programação Orientada à Objetos","url":"/CC_site/docs/cursos/arquitetura-software/fundamentos-arq-soft/Object Orientation Programming#principais-conceitos","content":" Aviso Não saia dessa seção sem decorar cada um dos conceitos que vamos elencar aqui.  A principal meta de qualquer implementação OOP é, basicamente, &quot;reduzir acoplamento e aumentar coesão&quot;. Pois bem, vamos definir cada um desses pontos.  Podemos definir acoplamento como a dependência entre objetos, ou seja, se um deles for alterado, os objetos dependentes também sofrerão mudanças.  Chamamos de coesão o oposto do acoplamento. Onde objetos podem trabalhar livremente lado a lado de modo que os componentes do sistema sejam livres para mudar e evoluir enquanto &quot;servem&quot; seus métodos e procedimentos uns para os outros.  Chamamos de classe a declaração de um objeto com propriedades. Por sua vez, um objeto é a instanciação da classe alocada na memória que será utilizada em tempo de execução.  Chamamos de estado as propriedades contidas em um determinado objeto. Por sua vez, chamamos de comportamento as funções e procedimentos contidos em um objeto  Exemplo de Estado e Comportamento // Exemplo de estado e comportamento em OOP using System namespace AulaConceitos { public class Objeto { public string Estado1 { get; set; } public int Estado2 { get; set; } public int Comportamento1(int param1, int param2) { int result; // logica do comportamento return result; } // Aqui temos um exemplo de um Comportamento que altera um Estado public void AtualizaEstado1(string novoValor) { Estado1 = novoValor; } } }  ","version":"Next","tagName":"h2"},{"title":"Getting Starter","type":0,"sectionRef":"#","url":"/CC_site/docs/cursos/nvim/first-step","content":"Getting Starter A primeira coisa que eu fiz foi ver um vídeo do fireship que indicou o canal do youtube de um dos core maintainers do Neo Vim. Primeiro vídeo que indica como fazer uma instalação do zero com um quick start -&gt; link aqui. Link do quick starter Roadmap: Ler o Friendly Manual Entender o arquivo init.lua com foco nas notes Entender o uso para vim.opt.config Decorar o básico das keymaps Autocommands com seus callbacks Plugin Manager lazy.nvim Fuzzy Finder telescope Language Server Protocol Mason for install LSP Autoformat Autocompletion and nvim compl mini.nvim treesitter Informanção Para ler a config de um keymap é sempre assim: Modo + Key + Vim Function.","keywords":"","version":"Next"},{"title":"Introdução","type":0,"sectionRef":"#","url":"/CC_site/docs/cursos/arquitetura-software/fundamentos-arq-soft/introducao","content":"","keywords":"","version":"Next"},{"title":"O que é Arquitetura de Software?​","type":1,"pageTitle":"Introdução","url":"/CC_site/docs/cursos/arquitetura-software/fundamentos-arq-soft/introducao#o-que-é-arquitetura-de-software","content":" Podemos usar essa resposta do stack overflow como um ponto de partida para nossa discussão.  Como regra de bolso, podemos pensar que a Engenharia de Software é o grande conjunto das habilidades de construção de programas e sistemas desde sua concepção até a entrega e manutenção. Por sua vez, a Arquitetura de Software é uma sub-área da engenharia que lida com o desenho e definição dos componentes que farão parte da solução entregue.  Pela ISO/IEEE 42010-2011, podemos conceituar Arquitetura como:  A organização fundamental de um sistema incorporada em seus componentes, relacionamentos com o ambiente e os princípios que conduzem o seu design e evolução.  ","version":"Next","tagName":"h2"},{"title":"Qual o momento ideal para aprender sobre Arquitetura?​","type":1,"pageTitle":"Introdução","url":"/CC_site/docs/cursos/arquitetura-software/fundamentos-arq-soft/introducao#qual-o-momento-ideal-para-aprender-sobre-arquitetura","content":" Na minha opinião, o momento ideal para aprender a arte de planejar soluções de software é após a fase em que você é capaz de construir software minimamente útil e funcional. Mais especificamente, na fronteira entre júnior e pleno.  Para ser mais claro, depois que você tiver terminado de estudar pelo menos o ciclo básico1 e também tenha alguma vivência do mundo real2.  ","version":"Next","tagName":"h2"},{"title":"Contexto Histórico​","type":1,"pageTitle":"Introdução","url":"/CC_site/docs/cursos/arquitetura-software/fundamentos-arq-soft/introducao#contexto-histórico","content":" Antigamente, a maneira de se hospedar aplicações (principalmente no ambiente corporativo) era bem diferente de como é feito hoje com a chegada do cloud como principal meio de hospedagem.  Aliado à evolução de &quot;onde&quot; colocar seus programas, vieram também as mudanças em &quot;como&quot; o processo de construção de sistemas é feito (por exemplo, o surgimento das metodologias ágeis).    Não se engane. A depender de onde você vai trabalhar, é plenamente possível encontrar demandas que ainda envolvam aplicações monolíticas em servidores físicos3.  ","version":"Next","tagName":"h2"},{"title":"Perfil de Arquiteto​","type":1,"pageTitle":"Introdução","url":"/CC_site/docs/cursos/arquitetura-software/fundamentos-arq-soft/introducao#perfil-de-arquiteto","content":" No geral, um arquiteto tem que ser capaz de pensar acima do simples fato de produzir código executável para uma camada de abstração de como criar soluções.  Existem alguns tipos de enfoques possíveis a depender da responsabilidade que a pessoa irá executar. A ISA elenca os seguintes tipos no seu site:  Solution ArchitectBusiness ArchitectSoftware ArchitectAI ArchitectIntegration ArchitectAgile ArchitectHybrid Infrastructure Architect  Nas nossas aulas, vamos focar no papel desempenhado pelo Arquiteto de Software.  ","version":"Next","tagName":"h2"},{"title":"Arquiteto de Software​","type":1,"pageTitle":"Introdução","url":"/CC_site/docs/cursos/arquitetura-software/fundamentos-arq-soft/introducao#arquiteto-de-software","content":" Esse perfil de Arquiteto tem como objetivo a projeção de aplicações baseada em boas práticas de desenvolvimento. Tem como artefatos os modelos de referência para produção de soluções dentro da empresa.  Está fortemente alinhado com a área de negócio e a gestão estratégica da empresa visto que existem restrições de negócio que podem 4 impactar no desenho da solução necessária.  Como Hard Skills, podemos elencar:  Profundo conhecimento em programação e, principalmente, componentizaçãoDomínio de alguma plataforma de desenvolvimento5, frameworks, IDEs, ferramentas e etcConhecer os tipos de arquitetura e padrões de problem solvingDomínio de design de código e qualidade  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Introdução","url":"/CC_site/docs/cursos/arquitetura-software/fundamentos-arq-soft/introducao#bibliografia","content":" The Open Group Architecture Framework (TOGAF). link aqui. É o manual mais completo e complexo sobre todo o processo de arquitetura.ISO 42010/2011. link aquiSite da Global IT Architects Association    Footnotes​ Como o material do Tecnólogo em ADS aqui do site ☺️. ↩ Seja trabalhando ou fazendo freelance. ↩ E você deve ficar contente com a oportunidade de &quot;tocar&quot; no passado para ver como o modelo atual é melhor. ↩ E provavelmente, vão. ↩ Exemplo ASP.NET, NodeJs e etc ↩ ","version":"Next","tagName":"h2"},{"title":"Cloud Acquisiton","type":0,"sectionRef":"#","url":"/CC_site/docs/cursos/skill-builder/cloud-acquisition","content":"","keywords":"","version":"Next"},{"title":"Procurement Foundations​","type":1,"pageTitle":"Cloud Acquisiton","url":"/CC_site/docs/cursos/skill-builder/cloud-acquisition#procurement-foundations","content":" The cloud can be bought in different ways:  Direct (AWS) aka you do the work to buildIndirect (Cloud-managed service providers aka &quot;CSP&quot; or resellers) who do the work for you (for a price)  Selling a single model -&gt; the contract of a Cloud service is one-to-many so the buyer is responsible either building the services in cloud or find a AWS Partner Network (APN) to do the job  procurement of cloud services x procurement of labor to use cloud services  Cloud Service Providers (CSP):  Cloud XaaSProfessional ServicesTrainingSupportMarketplace  CSP Partner/Resellers:  Requirement AnalysisStrategy and RoadmapSolution DesignTech Review and AuditMigration and Implementation  ","version":"Next","tagName":"h2"},{"title":"Key Aspects of Procurement​","type":1,"pageTitle":"Cloud Acquisiton","url":"/CC_site/docs/cursos/skill-builder/cloud-acquisition#key-aspects-of-procurement","content":" ","version":"Next","tagName":"h2"},{"title":"Pricing​","type":1,"pageTitle":"Cloud Acquisiton","url":"/CC_site/docs/cursos/skill-builder/cloud-acquisition#pricing","content":" Format of pricing Based on vendor not on customerSame price structure for all costumersPrice is variable Format of reserve On-demand (no reserved instance at all, pay full price by usage)Reserved Instances No upfront\\adiantado payment, billed by hour of use (little less then price of on-demand)Partial upfront (pay a % upfront with a discount, the rest by hour of use)All upfront (pay all in advance with a great discount, use without adicional cost) Discount AWS Enterprise Discount Program (EDP) For big enterprises that uses A LOT of aws resources Reserved Instances After a while of use, you can learn the patterns of demand and reserve some resources to access discounts (upfront payment over a 1 or 3 year term) Saving Plans Flexible pricing model that can save up to 72% in EC2 , Fargate and Lambda in exchange for a commitment to use specific amount of compute power for a 1 or 3 year period  ","version":"Next","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Cloud Acquisiton","url":"/CC_site/docs/cursos/skill-builder/cloud-acquisition#security","content":" Shared security responsibilitiesCustomer Responsibility Customer dataIdentity and Access managementOS, Network and Firewall AWS Responsibility Global infraComputeStorageDatabaseNetworking  ","version":"Next","tagName":"h3"},{"title":"Data Sovereignty and Data Residency​","type":1,"pageTitle":"Cloud Acquisiton","url":"/CC_site/docs/cursos/skill-builder/cloud-acquisition#data-sovereignty-and-data-residency","content":" Customers continue to own their dataCustomers choose the geographic location in which to store their dataCustomers can download or delete their data whenever they likeCustomer can &quot;crypto-delete&quot; their data  ","version":"Next","tagName":"h3"},{"title":"Governance and Operationalization​","type":1,"pageTitle":"Cloud Acquisiton","url":"/CC_site/docs/cursos/skill-builder/cloud-acquisition#governance-and-operationalization","content":" Traditional Way of Thinking​  Business case -&gt; Finance sign-off -&gt; sec and legal check -&gt; Start a new project. A lot of steps before the real deploy of project.  Cloud Way of Thinking​  All the steps are include in the AWS tools and cloud offerings. This way you can deploy a new project in minutes.  ","version":"Next","tagName":"h3"},{"title":"Terms and Condition​","type":1,"pageTitle":"Cloud Acquisiton","url":"/CC_site/docs/cursos/skill-builder/cloud-acquisition#terms-and-condition","content":" One-to-many scale and terms of serviceAWS has 2 agreement forms Online Customer Agreement The vast majority usesAWS can update these terms anytime AWS Enterprise Agreement For big clients that needs a tailor agreement for a better suit  ","version":"Next","tagName":"h3"},{"title":"Working with AWS Partner Network (APN)​","type":1,"pageTitle":"Cloud Acquisiton","url":"/CC_site/docs/cursos/skill-builder/cloud-acquisition#working-with-aws-partner-network-apn","content":" A Global Partner Program for consulting businesses that use Amazon Web Services to build solutions and services for customers. The APN helps customers to find a AWS Partner with expertise.  ","version":"Next","tagName":"h2"},{"title":"Partner types​","type":1,"pageTitle":"Cloud Acquisiton","url":"/CC_site/docs/cursos/skill-builder/cloud-acquisition#partner-types","content":" Consulting Partners - professional servicesTechnology Partners - software solutions ","version":"Next","tagName":"h3"},{"title":"Billing and Cost","type":0,"sectionRef":"#","url":"/CC_site/docs/cursos/skill-builder/billing-cost","content":"","keywords":"","version":"Next"},{"title":"AWS Billing Dashboard​","type":1,"pageTitle":"Billing and Cost","url":"/CC_site/docs/cursos/skill-builder/billing-cost#aws-billing-dashboard","content":" Search do Billing and select the first option. The main parts of the dashboard are:  AWS SummaryHighest CostCost Trend by top 5 servicesAccount cost trendBilling Section MenuCost Management Section Menu  The Billing dashboard is focused in the ongoing payments and generate reports.  ","version":"Next","tagName":"h2"},{"title":"AWS Cost Management Console​","type":1,"pageTitle":"Billing and Cost","url":"/CC_site/docs/cursos/skill-builder/billing-cost#aws-cost-management-console","content":" Here, the focus is optimize future costs by a range of tools like: AWS Cost Explorer, AWS Budgets and AWS Cost Anomaly Detection.  ","version":"Next","tagName":"h2"},{"title":"AWS Cost Explorer​","type":1,"pageTitle":"Billing and Cost","url":"/CC_site/docs/cursos/skill-builder/billing-cost#aws-cost-explorer","content":" Can review the historial data for the last 12 months and forecast by it. Its free of charge using from the console and can be used grammatically by Cost Explorer API.  It's used by Reports that can be create by the user and some are included by default.  ","version":"Next","tagName":"h3"},{"title":"AWS Budgets​","type":1,"pageTitle":"Billing and Cost","url":"/CC_site/docs/cursos/skill-builder/billing-cost#aws-budgets","content":" Creating a budget is create an upper boundary for cost in a configured period of time. By creating a budget, we can create alerts thresholds by percentage of an amount or absolute value.  If the spend reaches de limit, AWS send me an email and/or SNS topic. We can configure AWS to send periodic reports on a daily, weekly or monthly basis.  Updated 3x a day.  ","version":"Next","tagName":"h3"},{"title":"AWS Anomaly Detection​","type":1,"pageTitle":"Billing and Cost","url":"/CC_site/docs/cursos/skill-builder/billing-cost#aws-anomaly-detection","content":" A machine learning tool that keep monitoring your cost and reacts when a deviant pattern occurs. It's activate together with AWS Cost Explorer ","version":"Next","tagName":"h3"},{"title":"Congratulations!","type":0,"sectionRef":"#","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/congratulations","content":"","keywords":"","version":"Next"},{"title":"What's next?​","type":1,"pageTitle":"Congratulations!","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/congratulations#whats-next","content":" Read the official documentationModify your site configuration with docusaurus.config.jsAdd navbar and footer items with themeConfigAdd a custom Design and LayoutAdd a search barFind inspirations in the Docusaurus showcaseGet involved in the Docusaurus Community ","version":"Next","tagName":"h2"},{"title":"Cloud Practioner","type":0,"sectionRef":"#","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner","content":"","keywords":"","version":"Next"},{"title":"Notas Rápidas de Estudo AWS​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#notas-rápidas-de-estudo-aws","content":" ","version":"Next","tagName":"h2"},{"title":"Module 1 - Intro + Module 2 - The Cloud​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#module-1---intro--module-2---the-cloud","content":" Cloud computing -&gt; pay as you go withou pay beforehand.  Ec2 (elastic cloud computing).  Ec2 types -&gt; general, compute, memory, accelerated and storage.  Ec2 pricing -&gt; on-demand, reserved (type, plataform or tenancy), saving plans (1 or 3 years), spot (90% off, runs in not used machines at time) and dedicated hosts.  Load balance  Lambda  SNS -&gt; Topic post  SQS -&gt; Message broker  ECS -&gt; EKS da amazon  EKS -&gt; orquestrador de containers docker  AWS Fargate (serveless para containers)  ","version":"Next","tagName":"h3"},{"title":"Module 3 - Global Infra and Reliability​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#module-3---global-infra-and-reliability","content":" 4 factors to chose region (compliance, proximity, features and price).  Availability Zone (AZ) -&gt; group of data centers indicates in final of a region ex es-east-1a, b or c.  AWS Regions -&gt; group of az isolated geographically  Edge Location -&gt; cache coping to places there are not close to a region to reduce the latency that use AWS Cloudfront to deliver.  AWS Cloudfront -&gt; CDN da amazon.  AWS Route 53 -&gt; DNS da amazon.  AWS Outpost -&gt; an kind of mini region run by amazon inside our building.  how to create/update aws resources -&gt; AWS Management Console (Browser), AWS CLI, AWS SDKs, AWS Elastic Beastalk and AWS Cloudformation.  AWS Elastic Beanstalk -&gt; Ferramenta que faz deploy de app php, .net, java, python e etc. Baseados em alguns presets.  AWS Cloudformation -&gt; Infra as code tool (yaml or json).  Advice: run at least across 2 AZ in each region.  ","version":"Next","tagName":"h3"},{"title":"Module 4 - Networking​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#module-4---networking","content":" AWS VPC -&gt; Provision of isolated aws cloud separated by subnets that contains resources.  Subnet -&gt; A group of resources based on security or operacional needs. Can be public (through a internet gateway) or private (through a vpc).  Internet Gateway (IGW) -&gt; Used to allow internet access to a VPC.  AWS Virtual Private Gateway -&gt; A virtual VPN to my vpc and a private network (aka intranet).  AWS Direct Connect -&gt; Dedicated private connection fiber with a AWS Direct Connect endpoint.  Packet -&gt; A unit of data sent over the internet or network  Acces Control List (ACL) -&gt; The component that checks packets permitions for subnets. Default is to allow in and out traffic.  Security Group -&gt; The component that check packets permission for aws components (like ec2). Is Stateful and returns always allowed. Default is block in and allow out traffic.  Edge Location  AWS Cloudfront  AWS Route 53  Types of Load Balances:  Application -&gt; Flexible feature set with HTTP and HTTPS traffic.Network -&gt; Ultra-high performance. TLS. UDP. Static IP and so on. Capable to handle millions of requests per second.Gateway -&gt; Deploy and manage third-party virtual apps that suports GENEVE.Classic  ","version":"Next","tagName":"h3"},{"title":"Module 5 - Databases and Storage​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#module-5---databases-and-storage","content":" Block Level Storage -&gt; Place to store file in a way that can be updated block by block and not by the hole file  EC2 Storage -&gt; Instance Store Volumens that dies within the ec2 machine  AWS Elastic Block Store (EBS) -&gt; A way to save persistence data for ec2 instances. Block storage that can be updated partially. Run in a AZ (not region). Kind of SSD/HDD for EC2.  Snapshots -&gt; Incremental backups for EBS  AWS Simple Store Service (S3) -&gt; Store data as objects with versions in buckets (like a file equivalent). Can receive objects until 5TB!  S3 Lifecycle Policies -&gt; Rules that can move data for s3 tiers automatically for better storage and cost  S3 Classes aka Tiers -&gt;  Standard (99.9999999% prob of availability in a year)Static Website HostingStandard-Infrequent Access Data aka Standard-IA (not so frequently until we need it, like a backup)Glacier Flexible Retrieval (Retain data for audit or compliance in valts). Accept policies like Write one - read many (worm)  AWS Elastic File System (EFS) -&gt; Is a serverless shared file system. Scales automatically. Run in a region. Can be access by premises by AWS Direct Connect.  AWS Relational Database Service (RDS) -&gt; Support dbms with automated patching, backups, redundancy, fail over and disaster recovery  lift-and-shift -&gt; Migrate from an on-premisses dbms  AWS RDS database engines -&gt;  AWS Aurora (compatible with MySQL and PostegreSQL)MySQLPostegreSQLMariaDBOracleMSSQLServer  AWS DynamoDB -&gt; Serverless database. NoSQL with item + attribute. Purpose built.  Data warehouses -&gt; Storage of data to post ante analysis with focus in the past data and not real time updates.  AWS Redshift -&gt; Focus in data analysis. Data warehouse as a service. 10x faster than traditional databases for queries in multiple databases.  AWS Database Migration Service (DMS) -&gt; A way to migrate onpremisses databases to aws cloud solutions (with source db still in use!). Can be homogeneous or heterogeneous (with need a aditional convert step). Can be used to bring to dev env the prod data, consolidate multiple db into one and continous replication of on db into many targets.  Other Database Services -&gt; AWS DocumentDB (with mongoDB compatibility), AWS Neptune (graph database), AWS Managed Blockchain, AWS QLDB (Quantum Ledger DB), Database Acelerators (with AWS Elasticache) or DAX (DynamoDB Acelerator)  ","version":"Next","tagName":"h3"},{"title":"Module 6 - Security​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#module-6---security","content":" Share Responsability Model -&gt; aws resp &quot;of the cloud&quot; + user resp &quot;in the cloud&quot;  AWS part -&gt; physical + network + hypervisor  user part -&gt; Operation System + Application + Data  AWS Root User -&gt; Owner of the aws account  Multifactor Authoriation (MFA)  AWS Identity and Access Management (IAM) -&gt; Least privileged principle (user start of zero allowed powers)  Policies -&gt; Permition json that effect (allow or deny) + action (api call) + resource  IAM Groups -&gt; a better way to manage the permitions by attach users in groups  IAM Roles -&gt; temporary permitions  AWS Organizations -&gt;  Central local to manage multiple AWS accountsConsolidade billingHierarchical group accountsControl AWS Service and API Actions (Service Control Polices - SCP)  Organization Units -&gt; The name of each AWS organization  AWS Compliance -&gt; A LOT of best practices that AWS already follow  AWS Artifact -&gt; Service that provide on-demand access to AWS Security and compliance reports  Denial-of-service Attacks -&gt;  UDF Flood (api weather)HTTP Level Attacks (multiple http clients)Slowloris Attack (slow connection fake to stop de queue)  Defenses of DDoS by AWS -&gt;  Security Groups (the bad api calls does not reach the server)AWS Shield with AWS WAF (Machine learning and other stuff)Elastic Load Balancer (each track is segregated)  AWS Shield -&gt; Service that protects applications against DDoS attacks (two levels: stantad -no cost- and advanced)  Encryption -&gt; A way to ensure that only permitioned peaple can access to the data  AWS Key Management Service (KMS) -&gt; Encryption operations by a key  AWS WAF -&gt; web applicatoin firewall that checks that the request is not from a bloqued IP addr  AWS Inspector -&gt; Automated security assessments to avaluate your app and give some advices to improve the security  AWS GuardDuty -&gt; Inteligent threat detection by monitoring the network activity and account behavior  There are services that permits security assessments or penetration tests without a prior approval of AWS:  EC2RDSCloudfrontAuroraAPI GatewayLambdaLightsailElastic Beanstalk  But there some services which a prior approval is required:  DNS via Route 53DDoS attacksPort floodingProtocol floodingRequest flooding  AWS Security Tools with IA:  Macie -&gt; Machine Learning to discover, classify and protect sensive data.Rekognition -&gt; Same as Macie but used to image and videos analysis.GuardDuty -&gt; Threat detection service.Cognito -&gt; Sign-in tool for web and mobile apps.  ","version":"Next","tagName":"h3"},{"title":"Module 7 - Monitoring​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#module-7---monitoring","content":" AWS CloudWatch -&gt; Monitoring your aws infra by metrics. Reduce Mean Time To Resolution (MTTR) and improve Total Costume Ownership (TCO)  Cloudwatch Alarm -&gt; An alert that can be integrated with sns  Cloudwatch Dashboard -&gt; a dashboard, simple as it  AWS CloudTrail -&gt; A compreensive api for audition. Every call in aws saves a log in cloudtrail that can be save in s3 buckets  CloudTrail Insigns -&gt; Automatic detect unusual API activities in my aws account  AWS Trusted Advisor -&gt; Avaluate by 5 pillars: Cost optmization, Performance, Security, Fault tolerance and Service limits. Some are free and others paid. 3 actions: Action recomendation, Investigation recomendation and alright.  AWS Health page -&gt; A page that alerts when AWS is having some difficult that may impact your applications.  AWS Database Migration Service (AWS DMS) -&gt; Tool for migrate the on-premisses database to AWS RDS.  ","version":"Next","tagName":"h3"},{"title":"Module 8 - Billing​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#module-8---billing","content":" AWS Free Tier -&gt; 3 ways: aways free, 12 months free and trial  How AWS price works -&gt;  Pay for what you userPay less when you reservePay less with volumed-based discounts when you use more  AWS Princing Calculator  AWS Billing Dashboard -&gt; Painel to pay the aws bill  AWS Consolidate Billing -&gt; Centralize the bill process + share saving across accounts + it's free  AWS Budged -&gt; 4 types: cost, usage, reservation and saving plans. Custom alerts to keep the control on time  AWS Cost explore -&gt; drill down to know where you are allocating the cost. Can be group by tag to keep track of projects or other group of services  AWS Support plans -&gt;  Basic support: 24/7 customer servicedocumentationwhitepapersaws trusted advisoraws personal health dashboard Developer support: Email support 24 hours to response Business support: aws trusted advisor full powerdirect phone to cloud support team (4 hour to response) Enterprise On-Ramp support: 30 minutes response for critical workloadaccess to a pool of Technical Account Managers (TAMs) Enterprise support: 15 minutes responseDesignated Technical Account Manager (TAM)  Technical Account Manager (TAM) -&gt; A consigliere to keep the aws account running in conformity of the 6 pillars of well-architectured framework (more in module 10):  Operational ExcellenceSecurityReliabilityPerformance EfficiencyCost OptimizationSustainability  AWS Marketplace -&gt; A market for enterprise services of third parties in a bunch of categories like devops, infra, Iot, machine learning and more  ","version":"Next","tagName":"h3"},{"title":"Module 9 - Migration and Innovation​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#module-9---migration-and-innovation","content":" AWS Adoption Framework (CAF) -&gt; Advice to make a smooth change for cloud in 6 perspectives:  BusinessPeople -&gt; Bridge between tech and business.Governance -&gt; Orchestration cloud initiatives, max benefits and low the risks.PlatformSecurity -&gt; Data and workload sec.Operations -&gt; Cloud services that meet business need with involving of stakeholders like infra and operations leaders.  The first 3 focus on business and the last 3 focus on technical capabilities  AWS CAF Action Plan -&gt; Guide to make a migration  Migration Strategies (6 R's) -&gt;  Re-hosting (lift and shift)Re-platforming (lift, tinker and shift)Retire (die apps not needed anymore)Retain (make app life only for a short period of time on premisses until then die)Repurchasing (buy new software inted of use the old ones)Refactoring (re-code part of your software)  AWS Snow Family -&gt;  AWS Snowcone - A hardware that you receive from amazon, plug in your data center, copy the data and send back to amazon to send this to the cloud. Store up to 14TBAWS Snowball Edge - A device suited for large-scale data migrations. Can be Storage focused or Compute focused. 80TBAWS Snowmobile - 100PB. Like a container to plug in your on-premises data center  Innovation in AWS -&gt; VMWare Cloud AWS, Amazon SageMakes (machine learning pre-trained models), Amazon Augmented AI (2AI), Amazon Lex (the heart of Alexa), Amazon Textract (extract text), AWS DeepRacer, Iot, AWS Groud Station (for satelities)  AWS Q Developer -&gt; TODO: Search this topic  AWS Code Control:  AWS CodeCommitAWS CodeBuildAWS CodePipelineAWS CodeDeploy  ","version":"Next","tagName":"h3"},{"title":"Module 10 - The Cloud Journey​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#module-10---the-cloud-journey","content":" 6 pillars of Well-Architectured framework -&gt;  Operational Excellence (running and monitoring systems)Security (integrity of data and users)Reliability (recovery plannings and handle changes)Performance Efficiency (compute resources used in the best way)Cost Optimization (optimize full cost)Sustainability (minimize the environmental impact)  Well-Architectured tool -&gt; A service that evaluate your aws account by the 6 pillars above by a form of questions  6 main benefits to use cloud -&gt;  pay as you use (not upfront cost) and the cost is not fixedbenefit from massive scalestop guessing capacity and scale fast when neededincrease speed and agility by trying and failing fast and cheapstop wasting money hosting data centers and focus on the businessgo global in minutes  ","version":"Next","tagName":"h3"},{"title":"Module 11 - AWS Certified Cloud Practitioner Basics​","type":1,"pageTitle":"Cloud Practioner","url":"/CC_site/docs/cursos/skill-builder/cloud-practictioner#module-11---aws-certified-cloud-practitioner-basics","content":" There are 12 AWS Certifications.  4 Domains -&gt;  Cloud Concepts (24%)Security and Compliance (30%)Technology (34%)Billing and Pricing (12%)  Exam Details -&gt;  65 questions90 minutesMinimum score is 700Two types of questions (multiple-choice and multiple-response)  Exam Strategies -&gt;  Read the full questionPredict the answers before reading the optionsEliminate the wrong options ","version":"Next","tagName":"h3"},{"title":"Create a Page","type":0,"sectionRef":"#","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/create-a-page","content":"","keywords":"","version":"Next"},{"title":"Create your first React Page​","type":1,"pageTitle":"Create a Page","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/create-a-page#create-your-first-react-page","content":" Create a file at src/pages/my-react-page.js:  src/pages/my-react-page.js import React from 'react'; import Layout from '@theme/Layout'; export default function MyReactPage() { return ( &lt;Layout&gt; &lt;h1&gt;My React page&lt;/h1&gt; &lt;p&gt;This is a React page&lt;/p&gt; &lt;/Layout&gt; ); }   A new page is now available at http://localhost:3000/my-react-page.  ","version":"Next","tagName":"h2"},{"title":"Create your first Markdown Page​","type":1,"pageTitle":"Create a Page","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/create-a-page#create-your-first-markdown-page","content":" Create a file at src/pages/my-markdown-page.md:  src/pages/my-markdown-page.md # My Markdown page This is a Markdown page   A new page is now available at http://localhost:3000/my-markdown-page. ","version":"Next","tagName":"h2"},{"title":"Create a Document","type":0,"sectionRef":"#","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/create-a-document","content":"","keywords":"","version":"Next"},{"title":"Create your first Doc​","type":1,"pageTitle":"Create a Document","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/create-a-document#create-your-first-doc","content":" Create a Markdown file at docs/hello.md:  docs/hello.md # Hello This is my **first Docusaurus document**!   A new document is now available at http://localhost:3000/docs/hello.  ","version":"Next","tagName":"h2"},{"title":"Configure the Sidebar​","type":1,"pageTitle":"Create a Document","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/create-a-document#configure-the-sidebar","content":" Docusaurus automatically creates a sidebar from the docs folder.  Add metadata to customize the sidebar label and position:  docs/hello.md --- sidebar_label: 'Hi!' sidebar_position: 3 --- # Hello This is my **first Docusaurus document**!   It is also possible to create your sidebar explicitly in sidebars.js:  sidebars.js export default { tutorialSidebar: [ 'intro', 'hello', { type: 'category', label: 'Tutorial', items: ['tutorial-basics/create-a-document'], }, ], };  ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/CC_site/docs/cursos/skill-builder/getting-started","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Getting Started","url":"/CC_site/docs/cursos/skill-builder/getting-started#overview","content":" CLOUD = Programmable Resources + Dynamic Abilities + Pay as you go  Ways to interact with AWS:  AWS Management Console (site)AWS Command Line Interface (AWS CLI)AWS System Development Kits (AWS SDKs)  AWS Core Areas  ComputeStorageDatabasesNetworkingSecurity  ","version":"Next","tagName":"h2"},{"title":"Understanding the AWS Global Infra​","type":1,"pageTitle":"Getting Started","url":"/CC_site/docs/cursos/skill-builder/getting-started#understanding-the-aws-global-infra","content":" Data Center -&gt; Availability Zone -&gt; AWS Region  ","version":"Next","tagName":"h2"},{"title":"Core Services Overview​","type":1,"pageTitle":"Getting Started","url":"/CC_site/docs/cursos/skill-builder/getting-started#core-services-overview","content":" ","version":"Next","tagName":"h2"},{"title":"Compute​","type":1,"pageTitle":"Getting Started","url":"/CC_site/docs/cursos/skill-builder/getting-started#compute","content":" There are some options of cloud compute, to list a fell:  Virtual MachinesContainersBatch Processing Compute ResourcesServerless Compute  Amazon Elastic Compute Cloud (EC2) -&gt; The principal option of virtual machine in aws ecosystem.  EC2 types​  Link da documentação oficial  Memory Optimized (focus on RAM) Types: r4, r5, x1, z1Use Case: Open-source databases, in-memory caches, and real-time big data analytics Accelerated Computing (focus on GPU) Types: f1, g3, g4, p2, p3Use Case: ML models, computational fluid dynamics, graphical workloads Storage Types: d2, h1, i3Use Case: I/O intensive and business-critical workloads General Types: a1, m4, m5, t2, t3Use Case: Web servers and code repositores Compute (focus on CPU) Types: c4, c5Use Case: High performance web servers, high performance computing (HPC), scientific modeling, dedicated gaming servers and ad server engines, machine learning inference High Performance Computing (HPC) Types: Hpc6a, Hpc6idUse Case: Large, complex simulations and deep learning overloads  Amazon EC2 Auto Scaling​  The same content we learned before.  Severless​  Building and running applications without managing servers at al!  Keep in mind that serverless doesn't run idle resources, so you pay what you need.  AWS Lambda​  Some benefits:  Multiple languagesStateless codeCode can run on schedule or by triggerPricing by milisec of usageEvent-driven architecturesTotally scalableHigh availability  Some exemples of usage:  Web appsBackendData processingChatbotsAlexaIT automation  Containers​  There are 2 main types of containger orchestration services offer by AWS:  Amazon Elastic Container Service (AWS ECS)Amazon Elastic Kubernetes Service (AWS EKS)  Not much information was given in the material (need to deeper in the future).  ","version":"Next","tagName":"h3"},{"title":"Storage​","type":1,"pageTitle":"Getting Started","url":"/CC_site/docs/cursos/skill-builder/getting-started#storage","content":" Amazon Simple Storage Service (AWS S3)​  We can aggregate the S3 benefits in two main categories:  Durability of 99.999999999 (this is the actual number, no joke)Support for event triggers that be able to be used in event-driven applications with usage of lambda for example  S3 classes​  Link for official documentation  There are four classes that can be used to improve the benefits of S3 usage and maintain de cost at minimum possible.  Standard: Low latency and high throughputIntelligent-Tiering: Tries to low the cost automatically moving the data to less-expensive s3 classes by volume of requests. Latency of milliseconds and high performance.Express One Zone: Runs in only one AZ. One digit milliseconds latency.Standard-IA: For data with infrequent access by low latency when necessary.One Zone-IA: Same of standard by runs in a single AZ with a reduce in 20% of the cost.Glacier Instant Retrieval: Low cost for data with long storage prevision but required milliseconds latency when necessary.Glacier Flexible Retrieval: For data needed one or two times a year and with high latency. 10% less expensive if compared with Glacier instant retrieval.Glacier Deep Archive: For clients that need to store data up do 7 years for due diligence or accountability purposes.Outposts: For data that need to be on-premises, AWS offers a way to run a kind of local AWS server locally and still have the AWS APIs to interact with the infra.  Use Cases​  Content storage and distributionBackup and archivingBuild a data lakeBackup and restore critical dataArchive dataRun cloud-native apps  Amazon Elastic Block Store (AWS EBS)​  EC2 instances didn't have persistence in data. When the EC2 instance dies, the data is gone. But with EBS you can persist data which can be used by EC2 instances.  Has incremental snapshots.  Has encrypt option to all the data in the volume. And data traveling between instance and EBS is encrypt as well. Even the past data stored in snapshots become encrypted.  The amount of SSD/HDD volume can be defined and scale only if needed.  To remember: EBS is like a virtual SSD for EC2 instances.  Amazon Elastic File System (AWS EFS)​  If you need a serverless shared file system solution, you will need AWS EFS.  Four types:  NetApp ONTAPOpen ZFSWindows File ServerLustre  ","version":"Next","tagName":"h3"},{"title":"Databases​","type":1,"pageTitle":"Getting Started","url":"/CC_site/docs/cursos/skill-builder/getting-started#databases","content":" Overview​  There's a lot of database solutions on AWS. We will do some brief overlook in the types and solutions available in the AWS Ecosystem.  Relational Databases​  The more tradicional type of DBMS. Works with traditional applications, ERPs, CRMs and other types of well-know demands.  Amazon Aurora: MySQL or PostgreSQL compatible relational database for cloud that can run in multi AZ replicas.Amazon RDS: A web service that can run in multiple AZs for high availability. You can user RDS with a lot of engines like Aurora (MySQL or PostegreSQL), MariaDB, Oracle, SQL Server, MySQL and PostegreSQL.Amazon Redshift: A data warehouse that uses columnar storage that enable complex queries over analytical data workloads.  Key-value Databases​  Well suited for high-traffic web apps, e-commerce systems and gaming.  Amazon DynamoDB: Achieve a single digit millisecond latency serverless non-relational database.  In-memory Databases​  For demands of really fast response and not long term storage like caching, session management, gaming leaderboards, geospatial apps.  Amazon ElastiCache: Microsecond latency scalable caching service.Amazon MemoryDB for Redis: The redis approaching in the AWS ecosystem.  Document Databases​  Content management, catalogs, user profiles are some of example of usage.  Amazon DocumentDB: With MongoDB compatibility, can scale JSON workloads.  Wide Column Databases​  Here is a link for an article that discuss what is a wide column database. In (really) short, is a type of column database that is better suited for infrequent attributes in each entry (like attributes of products in a e-commerce SaaS).  Amazon Keyspaces  Graph Databases​  Better suited for fraud detection, social networking, recommendations engines and so on.  Amazon Neptune: Focus on relationship between data for highly connected datasets.  Time Series Databases​  For really intensive metrics over time like IoT, DevOps, Telemetry per exemple.  Amazon Timestream: Can store and analyse trillions of events per day.  Ledger Databases​  Systems of record, supply chain, registrations, banking transactions are some applications.  Amazon Quantum Ledger Database (AWS QLDB): Transparent, immutable and cryptographically verificable.  ","version":"Next","tagName":"h3"},{"title":"Networking​","type":1,"pageTitle":"Getting Started","url":"/CC_site/docs/cursos/skill-builder/getting-started#networking","content":" Amazon VPC​  Is a private network that provides logical isolation for the workloads. You can control the traffic in and out a VPC.  The gate of a VPC is a Internet Gateway.  Amazon Route 53​  A high available cloud DNS service. Can be used to domain registration, DNS routing and heal checking.  Elastic Load Balancing​  Like others Load Balance applications, the Elastic Load Balancing is a web service that control de inflow of traffic and redirect between the EC2 instances available (and can escalate the instances if necessary) in one ou more AZs.  ","version":"Next","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Getting Started","url":"/CC_site/docs/cursos/skill-builder/getting-started#security","content":" Shared Responsibility Model​  Even the AWS and the client are responsible for the security either in the cloud and of the cloud. The each share of responsibility is defined by the so called Shared Responsibility Model.  Customer Responsibility​  Basically, the customer is responsible for the security of the cloud. To list some of his part:  Platform, apps and identity access managementOperation system, network and firewall configClient-side data and data integrity authServer-side encryptionNetwork traffic protection  and so on.  AWS Responsibility​  The AWS' part is the infrastructure of the cloud:  AWS softwareHardware and AWS global infra  AWS Compliance​  To permit that the client achieve their goal of maintain the security in the cloud. AWS create a handful Security Services:  AWS Identity and Access Management (AWS IAM) to control accessAWS Artifact to generate on-demand compliance reportsAWS Key Management Service (AWS KMS) to generate, manage and rotate encryption keysAWS Shield to protect from DDoS attacks  AWS Trust Advisor​  Service that help the customer to reduce cost, increase performance, fault tolerance, services quotas and improve security by recommendations that help the customer to achieve the best practices.  ","version":"Next","tagName":"h3"},{"title":"Pricing​","type":1,"pageTitle":"Getting Started","url":"/CC_site/docs/cursos/skill-builder/getting-started#pricing","content":" Pricing concepts used by AWS:  Pay for what you usePay less when you reservePay less with volume-based discountsPay even less as AWS grows  EC2 Pricing​  There are three categories of purchasing:  On-demand instances: Charged per hourShort-termBest fit on unpredictable workloads Reserved Instances/Saving Plans Discount by 1 or 3 year commitmentsLarger the upfront payment, lager the discountTwo offering classes: Standard Reserved Instances -&gt; you can modify AZ, scope, networking type and instance size in the same EC2 familyConvertible Reserved Instances -&gt; you can exchange EC2 instances of different EC2 family, OS and tenancy Spot Instances Up to 90% discountBest fir for aplication with flexible start and end  AWS Free Tiers​  There are three types:  Always free12 months freeFree trials  ","version":"Next","tagName":"h3"},{"title":"Next Steps​","type":1,"pageTitle":"Getting Started","url":"/CC_site/docs/cursos/skill-builder/getting-started#next-steps","content":" There are 12 AWS certifications.  There are four levels of expertise in AWS certifications:  FoundationalAssociateProfessionalSpecialty ","version":"Next","tagName":"h2"},{"title":"Create a Blog Post","type":0,"sectionRef":"#","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/create-a-blog-post","content":"","keywords":"","version":"Next"},{"title":"Create your first Post​","type":1,"pageTitle":"Create a Blog Post","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/create-a-blog-post#create-your-first-post","content":" Create a file at blog/2021-02-28-greetings.md:  blog/2021-02-28-greetings.md --- slug: greetings title: Greetings! authors: - name: Joel Marcey title: Co-creator of Docusaurus 1 url: https://github.com/JoelMarcey image_url: https://github.com/JoelMarcey.png - name: Sébastien Lorber title: Docusaurus maintainer url: https://sebastienlorber.com image_url: https://github.com/slorber.png tags: [greetings] --- Congratulations, you have made your first post! Feel free to play around and edit this post as much as you like.   A new blog post is now available at http://localhost:3000/blog/greetings. ","version":"Next","tagName":"h2"},{"title":"Deploy your site","type":0,"sectionRef":"#","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/deploy-your-site","content":"","keywords":"","version":"Next"},{"title":"Build your site​","type":1,"pageTitle":"Deploy your site","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/deploy-your-site#build-your-site","content":" Build your site for production:  npm run build   The static files are generated in the build folder.  ","version":"Next","tagName":"h2"},{"title":"Deploy your site​","type":1,"pageTitle":"Deploy your site","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/deploy-your-site#deploy-your-site-1","content":" Test your production build locally:  npm run serve   The build folder is now served at http://localhost:3000/.  You can now deploy the build folder almost anywhere easily, for free or very small cost (read the Deployment Guide). ","version":"Next","tagName":"h2"},{"title":"Manage Docs Versions","type":0,"sectionRef":"#","url":"/CC_site/docs/docusaurus-tutorial/tutorial-extras/manage-docs-versions","content":"","keywords":"","version":"Next"},{"title":"Create a docs version​","type":1,"pageTitle":"Manage Docs Versions","url":"/CC_site/docs/docusaurus-tutorial/tutorial-extras/manage-docs-versions#create-a-docs-version","content":" Release a version 1.0 of your project:  npm run docusaurus docs:version 1.0   The docs folder is copied into versioned_docs/version-1.0 and versions.json is created.  Your docs now have 2 versions:  1.0 at http://localhost:3000/docs/ for the version 1.0 docscurrent at http://localhost:3000/docs/next/ for the upcoming, unreleased docs  ","version":"Next","tagName":"h2"},{"title":"Add a Version Dropdown​","type":1,"pageTitle":"Manage Docs Versions","url":"/CC_site/docs/docusaurus-tutorial/tutorial-extras/manage-docs-versions#add-a-version-dropdown","content":" To navigate seamlessly across versions, add a version dropdown.  Modify the docusaurus.config.js file:  docusaurus.config.js export default { themeConfig: { navbar: { items: [ { type: 'docsVersionDropdown', }, ], }, }, };   The docs version dropdown appears in your navbar:    ","version":"Next","tagName":"h2"},{"title":"Update an existing version​","type":1,"pageTitle":"Manage Docs Versions","url":"/CC_site/docs/docusaurus-tutorial/tutorial-extras/manage-docs-versions#update-an-existing-version","content":" It is possible to edit versioned docs in their respective folder:  versioned_docs/version-1.0/hello.md updates http://localhost:3000/docs/hellodocs/hello.md updates http://localhost:3000/docs/next/hello ","version":"Next","tagName":"h2"},{"title":"Bem Vindo(a)!","type":0,"sectionRef":"#","url":"/CC_site/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Materiais​","type":1,"pageTitle":"Bem Vindo(a)!","url":"/CC_site/docs/intro#materiais","content":"   ","version":"Next","tagName":"h2"},{"title":"Quem sou eu​","type":1,"pageTitle":"Bem Vindo(a)!","url":"/CC_site/docs/intro#quem-sou-eu","content":" Eu me chamo Bruno de Melo Ruas.  Sou formado em Análise e Desenvolvimento de Sistemas pela Pontifícia Universidade Católica de Minas Gerais (PUC-MG). Bacharel em Economia pela Universidade do Estado do Amazonas (UEA). Especialista em Gestão Financeira pela Fundação Getúlio Vargas (FGV).  Eu comecei a programar em meados de 2017. Na época aprendendo Econometria usando uma linguagem de programação chamada R. Ao longo do tempo, fui aprendendo novas técnicas como Robot Process Automation (RPA), Web Scraping e fui tomando cada vez mais gosto pela área de tecnologia. Em julho de 2023 eu migrei definitivamente a carreira de Economista para Desenvolvedor de Software. A timeline completa está logo abaixo.  Atualmente sou desenvolvedor com foco em Backend na GFT Technologies onde estou alocado em um dos maiores bancos da América Latina. Esse material me serviu para chegar até aqui. Espero que também ajude você!  Se quiser, pode me seguir nas minhas redes: Linkedin, Twitter, Github  ","version":"Next","tagName":"h2"},{"title":"Fontes e Avisos​","type":1,"pageTitle":"Bem Vindo(a)!","url":"/CC_site/docs/intro#fontes-e-avisos","content":" Meu objetivo com esse projeto é construir um tipo de segundo cérebro para consultas pontuais sempre que eu precisar revisar um conteúdo já estudado e também ajudar as outras pessoas (principalmente os iniciantes na área). Ao longo do projeto eu coleto conteúdos sobre Programação e Desenvolvimento de Software seguindo fontes como:  Tecnólogo em Análise e Desenvolvimento de Sistemas pela PUC Minas Gerais.Bacharelado Aberto em Ciência da Computação pela Open Source Society University - OSSU.Cursos Livres como os do Balta.io ou Curso.dev e outros.Aprendizados no dia a dia.  Sempre que possível, eu vou indicar a fonte das informações mas sempre desconfie e busque por sua própria conta.  Comentário Mesmo gostando de escrever, eu percebi que todo programador maduro é capaz de ler diretamente da documentação oficial e pesquisar por conta própria sempre que necessário. Por causa disso, em matérias mais práticas, vamos tocar um mini projeto onde eu vou mostrar os commits feitos e fazer uma breve explicação em cada commit1.  ","version":"Next","tagName":"h2"},{"title":"Minha Carreira​","type":1,"pageTitle":"Bem Vindo(a)!","url":"/CC_site/docs/intro#minha-carreira","content":"   Desenvolvedor Backend GFT Tech São Paulo Atividades: Alocado em um banco de investimento internacionalSustentaçãoProjetosEvolução TecnológicaRegulatório Stack: C# / .NETPythonGoJavascript / TypescriptSQL / NoSQL CI/CDGitAWSAngularReact RabbitMqRedisKubernetesNodeJsTestes Unitários 2023 - Atualmente Certificação Cloud Pratictioner AWS 2024 Tecnólogo em Análise e Desenvolvimento de Sistemas Pontifícia Universidade Católica - PUC/MG Competências: Boas práticas (SOLID / Clean Code)Desenvolvimento Fullstack .NET/ReactDesenvolvimento Mobile React NativeSistemas distribuídosEngenharia de Software 2022 - 2024 Desenvolvedor Freelancer Ruas Data Analysis Amazonas Atividades: Auxílio à gestão de clínicas com KPIsWebapp com indicadores de gestãoConstrução de Rotinas RPAETL com diferente sistemas Stack: PythonDjangoSeleniumHTMLCSS JavascriptGit/GithubFirebirdSQLTkinter 2022 - 2023 Desenvolvedor Python / Sysadmin One Clinic Amazonas Atividades: Integrações SOAP/REST com o ERP Totvs RMWebapp com indicadores de gestãoConstrução de Rotinas RPAWebapp para download de laudos Stack: PythonDjangoSeleniumHTMLCSS JavascriptGit/GithubFirebirdSQL 2020 - 2022 Especialista em Gestão Financeira Fundação Getúlio Vargas - FGV Competências: Análise de Demonstrações ContábeisControladoriaProjetos Econômicos e Financeiros 2019-2020 Gerente de Orçamento Secretaria Municipal de Saúde - SEMSA Amazonas Atividades: Criação de Webapp de acompanhamento de pagamentosCriação de Webapp georeferenciado de indicadores de produçãoConstrução de Rotinas RPA Stack: PythonRSeleniumShiny 2017 - 2020 Bacharel em Economia Universidade do Estado do Amazonas - UEA Manaus/Amazonas/Brasil Atividades: Pesquisador DiscenteMonitorias Introdução à EconomiaMacroeconomia IEconometria 3º colocado nacional na Gincana de Economia - COFECON Stack: StataEviewsR/Rstudio 2014 - 2017    Footnotes​ Você tem que ser capaz de ler as alterações em cada commit. Pare, leia e se esforce para entender cada passo dos projetos. ↩ ","version":"Next","tagName":"h2"},{"title":"Sobre o Tecnólogo","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/intro","content":"Sobre o Tecnólogo Por ser uma formação tecnológica em desenvolvimento de sistemas, o foco aqui é aprender os conceitos gerais relacionados ao trabalho de analista de sistemas. Nem de longe essa formação é suficiente para os desafios dos profissionais top tier do nosso ramo ainda mais pelo fato que aqui são apenas as minhas anotações sobre algumas matérias (algumas eu não trouxe porque não eram tão relacionadas com tecnologia per se). A ideia aqui é ser capaz de resolver problemas usando software com a principal ferramenta. Além disso tem um monte de matéria de gestão que podem servir bastante para os que seguirem para cargos de liderança e gerência. Ao final desse material, nós seremos capazes de entender como atuar em uma empresa na condição de programadores C#. Produzindo soluções úteis e funcionais para problemas de complexidade baixa a moderada. Ao todo, o curso é divido em 3 ciclos e 5 semestres (chamados de Eixos Temáticos). O conteúdo do curso está abaixo. O checklist indicará quais matérias (que na PUC são chamadas de Microfundamentos) estão completas. Período 1: Implementação de Sistemas de Software Algoritmos e Abstração de Dados Algoritmos e Lógica de Programação Desenvolvimento Web Front-End Matemática Básica Organização de Computadores Fundamentos de Engenharia de Software Pensamento Computacional Lógica Computacional Período 2: Análise e Projeto de Sistemas de Software Algoritmos e Estruturas de Dados Engenharia de Requisitos de Software Design de Interação Programação Modular Desenvolvimento Web Back-End Modelagem de Dados Fundamentos de Redes de Computadores Manipulação de Dados com SQL Período 3: Processos de Negócio e de Desenvolvimento de Software Estatística Descritiva Gerência de Projetos de TI Gerência de Requisitos de Software Desenvolvimento de Aplicações Móveis Gerência de Configuração Qualidade de Processos de Software Modelagem\\Gestão de Processos de Negócios Período 4: Infraestrutura para Sistemas de Software Arquitetura de Software Distribuído Cloud Computing Projeto de Software APIs e Web Services Teste de Software Banco de Dados NoSQL Período 5: Empreendedorismo e Inovação com Sistemas de Software Segurança Aplicada ao Desenvolvimento Compliance em TI Implantação de Solução de TI","keywords":"","version":"Next"},{"title":"Translate your site","type":0,"sectionRef":"#","url":"/CC_site/docs/docusaurus-tutorial/tutorial-extras/translate-your-site","content":"","keywords":"","version":"Next"},{"title":"Configure i18n​","type":1,"pageTitle":"Translate your site","url":"/CC_site/docs/docusaurus-tutorial/tutorial-extras/translate-your-site#configure-i18n","content":" Modify docusaurus.config.js to add support for the fr locale:  docusaurus.config.js export default { i18n: { defaultLocale: 'en', locales: ['en', 'fr'], }, };   ","version":"Next","tagName":"h2"},{"title":"Translate a doc​","type":1,"pageTitle":"Translate your site","url":"/CC_site/docs/docusaurus-tutorial/tutorial-extras/translate-your-site#translate-a-doc","content":" Copy the docs/intro.md file to the i18n/fr folder:  mkdir -p i18n/fr/docusaurus-plugin-content-docs/current/ cp docs/intro.md i18n/fr/docusaurus-plugin-content-docs/current/intro.md   Translate i18n/fr/docusaurus-plugin-content-docs/current/intro.md in French.  ","version":"Next","tagName":"h2"},{"title":"Start your localized site​","type":1,"pageTitle":"Translate your site","url":"/CC_site/docs/docusaurus-tutorial/tutorial-extras/translate-your-site#start-your-localized-site","content":" Start your site on the French locale:  npm run start -- --locale fr   Your localized site is accessible at http://localhost:3000/fr/ and the Getting Started page is translated.  cuidado In development, you can only use one locale at a time.  ","version":"Next","tagName":"h2"},{"title":"Add a Locale Dropdown​","type":1,"pageTitle":"Translate your site","url":"/CC_site/docs/docusaurus-tutorial/tutorial-extras/translate-your-site#add-a-locale-dropdown","content":" To navigate seamlessly across languages, add a locale dropdown.  Modify the docusaurus.config.js file:  docusaurus.config.js export default { themeConfig: { navbar: { items: [ { type: 'localeDropdown', }, ], }, }, };   The locale dropdown now appears in your navbar:    ","version":"Next","tagName":"h2"},{"title":"Build your localized site​","type":1,"pageTitle":"Translate your site","url":"/CC_site/docs/docusaurus-tutorial/tutorial-extras/translate-your-site#build-your-localized-site","content":" Build your site for a specific locale:  npm run build -- --locale fr   Or build your site to include all the locales at once:  npm run build  ","version":"Next","tagName":"h2"},{"title":"Markdown Features","type":0,"sectionRef":"#","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/markdown-features","content":"","keywords":"","version":"Next"},{"title":"Front Matter​","type":1,"pageTitle":"Markdown Features","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/markdown-features#front-matter","content":" Markdown documents have metadata at the top called Front Matter:  my-doc.md --- id: my-doc-id title: My document title description: My document description slug: /my-custom-url --- ## Markdown heading Markdown text with [links](./hello.md)   ","version":"Next","tagName":"h2"},{"title":"Links​","type":1,"pageTitle":"Markdown Features","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/markdown-features#links","content":" Regular Markdown links are supported, using url paths or relative file paths.  Let's see how to [Create a page](/create-a-page).   Let's see how to [Create a page](./create-a-page.md).   Result: Let's see how to Create a page.  ","version":"Next","tagName":"h2"},{"title":"Images​","type":1,"pageTitle":"Markdown Features","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/markdown-features#images","content":" Regular Markdown images are supported.  You can use absolute paths to reference images in the static directory (static/img/docusaurus.png):  ![Docusaurus logo](/img/docusaurus.png)     You can reference images relative to the current file as well. This is particularly useful to colocate images close to the Markdown files using them:  ![Docusaurus logo](./img/docusaurus.png)   ","version":"Next","tagName":"h2"},{"title":"Code Blocks​","type":1,"pageTitle":"Markdown Features","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/markdown-features#code-blocks","content":" Markdown code blocks are supported with Syntax highlighting.  ```jsx title=&quot;src/components/HelloDocusaurus.js&quot; function HelloDocusaurus() { return &lt;h1&gt;Hello, Docusaurus!&lt;/h1&gt;; } ```   src/components/HelloDocusaurus.js function HelloDocusaurus() { return &lt;h1&gt;Hello, Docusaurus!&lt;/h1&gt;; }   ","version":"Next","tagName":"h2"},{"title":"Admonitions​","type":1,"pageTitle":"Markdown Features","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/markdown-features#admonitions","content":" Docusaurus has a special syntax to create admonitions and callouts:  :::note[Comentário] Aqui vou colocar os meus pensamentos sobre o conteúdo. ::: :::tip[Dica] Alguma referência bacana que pode somar ao estudo. ::: :::info[Informação] Vou usar esse card para ir um pouco mais fundo em algum assunto apontando uma referência para estudo. ::: :::warning[Atenção] Indicação que o conteúdo tem natureza complexa. ::: :::danger[Aviso] Indicação que o assunto é sério ou grave. :::   Comentário Aqui vou colocar os meus pensamentos sobre o conteúdo.  Dica Alguma referência bacana que pode somar ao estudo.  Informação Vou usar esse card para ir um pouco mais fundo em algum assunto apontando uma referência para estudo. Também uso esse card para informar se a aula está em elaboração.  Atenção Indicação que o conteúdo tem natureza complexa.  Aviso Indicação que o assunto é sério ou grave.  ","version":"Next","tagName":"h2"},{"title":"MDX and React Components​","type":1,"pageTitle":"Markdown Features","url":"/CC_site/docs/docusaurus-tutorial/tutorial-basics/markdown-features#mdx-and-react-components","content":" MDX can make your documentation more interactive and allows using any React components inside Markdown:  export const Highlight = ({children, color}) =&gt; ( &lt;span style={{ backgroundColor: color, borderRadius: '20px', color: '#fff', padding: '10px', cursor: 'pointer', }} onClick={() =&gt; { alert(`You clicked the color ${color} with label ${children}`) }}&gt; {children} &lt;/span&gt; ); This is &lt;Highlight color=&quot;#25c2a0&quot;&gt;Docusaurus green&lt;/Highlight&gt; ! This is &lt;Highlight color=&quot;#1877F2&quot;&gt;Facebook blue&lt;/Highlight&gt; !     This is Docusaurus green !  This is Facebook blue ! ","version":"Next","tagName":"h2"},{"title":"Matemática Básica","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/primeiro-periodo/matematica-basica","content":"","keywords":"","version":"Next"},{"title":"Bibliografia​","type":1,"pageTitle":"Matemática Básica","url":"/CC_site/docs/puc/primeiro-periodo/matematica-basica#bibliografia","content":" GERSTING, Judith L. Fundamentos matemáticos para a ciência da computação. 7.Rio de Janeiro LTC 2016 1 recurso online ISBN 9788521633303HUNTER, David J. Fundamentos de matemática discreta. Rio de Janeiro LTC 2011 1 recurso online ISBN 9788521635246LIMA, Diana Maia de. Matemática aplicada à informática. Porto Alegre Bookman 2015 1 recurso online ISBN 9788582603178STEWART, James. Cálculo, v. 1. 8.ed. São Paulo (SP): Cengage Learning, 2017 E-book ISBN 9788522126859MENEZES, Paulo Blauth. Aprendendo matemática discreta com exercícios, v.19. Porto Alegre Bookman 2011 ISBN 9788577805105ROSEN, Kenneth H. Matemática discreta e suas aplicações. Porto Alegre ArtMed 2010 ISBN 9788563308399SIMÕES-PEREIRA, José Maunel dos Santos. Introdução à Matemática Combinatória. Editora InterciÊncia 338 ISBN 9788571932920ÁVILA, Geraldo; ARAÚJO, Luis Cláudio Lopes de. Cálculo: ilustrado, prático e descomplicado. Rio de Janeiro, RJ: LTC - Livros Tecnicos e Cientificos, 2012. E-book ISBN 978-85-216-2128-GUIDORIZZI, Hamilton Luiz. Um curso de cálculo, v. 1. 6. Rio de Janeiro LTC 2018 1 recurso online ISBN 9788521635574 ","version":"Next","tagName":"h2"},{"title":"Pensamento Computacional","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/primeiro-periodo/pensamento-computacional","content":"","keywords":"","version":"Next"},{"title":"Conceitos e Competências de Pensamento Computacional​","type":1,"pageTitle":"Pensamento Computacional","url":"/CC_site/docs/puc/primeiro-periodo/pensamento-computacional#conceitos-e-competências-de-pensamento-computacional","content":" Existem divergências quanto ao significado preciso desse conceito, contudo, as interpretações vigentes costumam convergir para a definição que o pensamento computacional é a maneira de organizar o raciocínio de modo a pensar de maneira organizada, lógica e propor soluções úteis para os problemas propostos.  Podemos elencar alguns pilares que fundamentam o processo de pensamento computacional:  Abstração - Construção de um modelo simplificado da questão.Decomposição - Separação do problema em diferentes partes.Reconhecimento de Padrões - Identificação de processos que se repetem.Automação (aka Algoritmo) - Construção de um processo de solução do problema.  Além desses passos, podemos acrescentar mais algumas etapas ao esforço de solução de problemas:  Paralelização - Etapas paralelas e independentes. Particionamento de Dados - Quebra de um grande volume de dados para processamento paralelo e posterior união do resultado.Particionamento de Tarefas - Quebra do processo em diferentes unidades executoras paralelas. Simulação - Simplificação do caso real para melhor compreender o problema. Avaliação de Soluções - Análise dos impactos das soluções propostas.  É importante é saber que pensamento computacional não é pensar como um computador e sim de maneira organizada.  Esses passos não são necessariamente seguidos nessa ordem1. Podemos pensar nessa lista como etapas necessárias mas não sucessivas. Agora veremos um pouco mais sobre cada uma delas.  ","version":"Next","tagName":"h2"},{"title":"Computação Desplugada​","type":1,"pageTitle":"Pensamento Computacional","url":"/CC_site/docs/puc/primeiro-periodo/pensamento-computacional#computação-desplugada","content":" O foco dessa seção é elencar algum problemas que podem ser resolvidos com algoritmos que foram construídos usando o uso das etapas aprendidas na seção anterior.  Várias situações que nós encontramos no processo de construção de uma solução podem ser entendidas como análogas a algum dos problemas elencados aqui. Por isso é bom manter anotações sempre que aprendermos uma técnica de resolução nova para um problema.  Compresão de Texto: Resolvido com a substituição de seções longas por caracteres menores antes da transmissão. Depois enviamos as regras de codificação para processamento da mensagem original. Tópico teórico: Teoria da Informação; Codificação.Adivinhação de um Número: Basta ir perguntando pela metade das opções. Essa é a solução de menor rodadas. Tópico teórico: Árvore de Decisão; Eficiência de Algoritmos.Problema do Caixeiro Viajante: Construção de um grafo e escolha do caminho de menor soma entre as distâncias dos nós. Tópico teórico: Teoria dos Grafos.Nonograma: Procurar as regras de construção das imagens para cada linha até que se tenha um conjunto de regras para ser aplicadas nas instruções iniciais. Desafio difícil de implementar por linguagem de programação. Tópicos teóricos: Abstração; Modelagem.  ","version":"Next","tagName":"h2"},{"title":"Bibliografia​","type":1,"pageTitle":"Pensamento Computacional","url":"/CC_site/docs/puc/primeiro-periodo/pensamento-computacional#bibliografia","content":" BEECHER, Karl. Computational Thinking - A beginner's guide to problem-solving and programming. Swindon, UK: BCS Learning &amp; Development Limited, 2017. (O´Reilly) EPUB ISBN-13: 978-1-78017-36-65FORBELLONE, André Luiz Villar; EBERSPACHER, Henri Frederico. Lógica de programação: a construção de algoritmos e estruturas de dados. 3. ed. São Paulo: Prentice Hall, 2005. xii, 218 p. ISBN 8576050242MANZANO, José Augusto N. G; OLIVEIRA, Jayr Figueiredo de. Algoritmos: lógica para desenvolvimento de programação de computadores. 28. ed. rev. e atual. São Paulo, SP: Érica, 2016. ISBN 9788536518657GUEDES, Sérgio (Org). Lógica de programação algorítmica. São Paulo: Pearson, 2014. ISBN 9788543005546MANZANO, José Augusto N. G. Estudo dirigido de algoritmos. 15. São Paulo Erica 2011 1 recurso online ISBN 9788536519067SOUZA, Marcos Fernando Ferreira de. Computadores e sociedade: da filosofia às linguagens de programação. Editora Intersaberes 208 ISBN 9788559722116TORRES, Fernando E. et al. Pensamento computacional. Porto Alegre: SAGAH, 2019. ISBN 978-85-9502-997-2FORBELLONE, André Luiz Villar; EBERSPACHER, Henri Frederico. Lógica de programação: a construção de algoritmos e estruturas de dados. 3. ed. São Paulo: Prentice Hall, 2005. xii, 218 p. ISBN 8576050242    Footnotes​ Embora, na minha opinião, faz todo sentido seguir nessas etapas mesmo. ↩ ","version":"Next","tagName":"h2"},{"title":"Fundamentos de Engenharia de Software","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software","content":"","keywords":"","version":"Next"},{"title":"Conceitos e Processos de Software​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#conceitos-e-processos-de-software","content":" A engenharia de software é subárea da Ciência da Computação que lida com as atividades de desenvolvimento, operação e evolução de software. Esse campo surgiu com a crise do software de 1968.  ","version":"Next","tagName":"h2"},{"title":"Definições​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#definições","content":" Agora vamos aprender os conceitos usados ao longo do trabalho de engenharia de software:  Programa - Conjunto de instruções em uma linguagem de programação.Software - Programa + Estrutura de Dados + Documentação.Sistema - Conjunto de elementos interdependentes de Softwares, Hardware e Pessoas. Podem ser intensivos em qualquer umas dessas 3 partes.  ","version":"Next","tagName":"h3"},{"title":"Modelos e Princípios de Processo de Software​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#modelos-e-princípios-de-processo-de-software","content":" O processo de Software é um conjunto de etapas usadas para a produção de soluções de software. Podemos elencar dois conceitos importantes que compõe o processo de software:  Descrição de Processos: Atividades - Lista de etapas necessárias.Produtos ou Artefatos - Produto gerado pelas atividades.Papéis - Quem executa cada atividade.Condições - As requisições pré e pós execução das atividades. Modelos de Ciclo de Vida: Modelo Sequencial Linear: Análise/Projeto/Codificação/Teste.Modelo em Cascata: Definição/Projeto/Implementação/Integração/Manutenção.Modelo Incremental: O projeto é quebrado em incrementos e cada incremento possui um modelo sequencial linear ou em cascata.Modelo Incremental Evolutivo: Esboço/loop{Especificação/Desenvolvimento/Validação} até que se tenha a versão final.Modelo Espiral: loop{Planejamento/Modelagem/Construção/Entrega/Feedback} para cada incremento novo ao software.Modelo Iterativo: É o modelo Sequencial Linear mas com possibilidade de retorno para as etapas anteriores até que se esteja aprovado pelo cliente.Modelo V: Durante todas as etapas de processo de software nós já vamos definindo os testes que serão usados para a aprovação do produto.  Hoje em dia, temos dois modelos mais usados. A modelo incremental foca em entregar um pedaço de cada vez e o modelo iterativo permite entregar versões mais simples do produto e ir aprimorando elas. O modelo atual mais usado é justamente o Modelo incremental iterativo.  Agora que aprendemos o conceito de modelo de processo de software, vamos analisar algumas abordagens de elaboração de software. Podemos dizer que existem 3 grupos principais de processos de gestão de software: 1) Processos ágeis; 2) Processos Prescritivos e 3) Processos Enxutos (lean process).  Comentário No material do curso só foram abordadas os dois primeiros processos.  ","version":"Next","tagName":"h3"},{"title":"Processos Ágeis​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#processos-ágeis","content":" Os processos ágeis nasceram no final do século XX. Seguem o modelo incremental e iterativo de desenvolvimento. Os incrementos são pequenos e sucessivos (2 a 3 semanas). O cliente está constantemente em contato com o produto gerado no ciclo. A documentação é reduzida porque há muita comunicação interpessoal.  Existem várias metodologias mas podemos elencar alguns:  eXtreme Programming (XP)ScrumDynamic System Development (DSDM)Feature Driven Development (FDD)Crystal Families  Hoje em dia o método mais usado é o Scrum. A novidade dele é que a abordagem do desenvolvimento é empírica e permite a evolução dos requisitos do processo ao longo do processo.  Scrum​  O Scrum é divido em apenas 3 etapas: 1) Planejamento inicial do projeto; 2) Loop de desenvolvimento e feedback (chamado de sprint) e 3) Entrega ao cliente.  As equipes do scrum são pequenas, multidisciplinares, de liderança diluída e trabalham com um foco de melhorias pequenas em um prazo mais curto (2 ou 4 semanas). Existe a figura do facilitador do processo chamado Scrum Master.  Os requisitos do software são mantidos no artefato chamado Backlog e serve de norte pada os times de desenvolvimento.  Existem 3 papeis no processo de gestão do Scrum:  Product Owner (PO) - O cliente ou alguém representante da vontade dele. Podemos pensar no PO como a ponte entre a empresa-cliente e a empresa-desenvolvedora.Scrum Master - É o facilitador do time de desenvolvimento. Atua como ponte entre o time de desenvolvimento e o PO. Atentemos para o fato do PO não participar do processo de desenvolvimento técnico.Equipe de Desenvolvimento - É auto-organizada e responsável pela produção dos algoritmos que comporão o software.  Agora veremos de maneira organizada os artefatos produzidos no processo de Scrum:  Backlog do Produto - Lista de características necessárias ao software atreladas a um grau de importância. Cada característica é fruto de uma história de usuário que é composta de 3 informações (quem?; o que? e por quê?).Backlog da Sprint - É um subconjunto das características elencadas do backlog do produto. Esses itens serão o foco da sprint (2 a 4 semanas).Incremento do Produto - É o resultado do trabalho realizado na sprint.  Além dos papéis e dos artefatos, existem as cerimônias do modelo Scrum:  Reunião de planejamento da Sprint - Decide quais características do Backlog do projeto serão objeto de trabalho pelo time de desenvolvimento.Daily - Acompanhamento a cada 24 horas do esforço do time de desenvolvimento para o alcance do planejamento da sprint. Algo rápido (15 min).Revisão da Sprint - Avaliação pelo PO do cumprimento do backlog da sprint. Foco no produto.Retrospectiva da Sprint - Melhoria do processo por meio de feedback de todas as partes envolvidas no processo de sprint. Foco no processo.  ","version":"Next","tagName":"h3"},{"title":"Processos Prescritivos​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#processos-prescritivos","content":" Antes do predomínio das metodologias ágeis, os processos de controle de produção de software eram orientados por processos prescritivos, também são chamados de processos dirigidos por planos. A ideia é primeiro planejar tudo e ir visualizando o caminhar dos trabalhos em termos do planejamento inicial. O Rational Unified Process (RUP) é o mais famoso desses modelos.  O RUP hoje pertence à IBM e possui algumas características principais:  Possui vários princípios dos quais podemos citar: Foco nos riscos principaisGarantia do valorPermitir mudançasDefinição da arquitetura da solução o mais breve possívelConstrução da solução em componentes Baseado em componentes/etapas planejadas Disciplinas (o que deve ser feito): Requisitos/Análise/Projeto/Implementação/TesteFases (as etapas de cumprimento das disciplinas): Concepção/Elaboração/Construção/Transição Possui linguagem padronizada: Unified Modeling Language (UML)É dirigido por caso de usoFunciona por modelo iterativo-incremental  Os benefícios dos processos prescritivos ainda são vistos nas maiores empresas, principalmente relacionados ao uso da UML para definição de etapas necessárias em interações e processos. Abaixo temos um exemplo retirado do material do curso. Mais informações sobre a UML podem ser encontradas nesse link.    Especificação do caso de uso Matricular em disciplinas do sistema de controle acadêmico. Fonte: A especificação do caso de uso foi adaptada do livro BEZERRA, Eduardo. Princípios de análise e projeto de sistemas com UML. Rio de Janeiro: Campus, 2003.  Matricular em disciplinas  Sumário: O aluno usa o sistema para se matricular em disciplinas.  Ator primário: aluno  Ator secundário: Sistema Financeiro  Pré-condições: o aluno está identificado pelo sistema  Fluxo Principal:  O aluno solicita a matrícula em disciplinas;O sistema apresenta a lista de disciplinas disponíveis para o semestre corrente para as quais o alunos possui pré-requisitos;O aluno seleciona as disciplinas desejadas e solicita a matrícula;O sistema aloca o aluno em turmas de ofertas das disciplinas desejadas e informa ao aluno a turma alocada para cada disciplina bem como o professor, os horários e dias da semana e as salas de aula;O aluno confirma as alocações feitas;O sistema realiza a matrícula e envia os dados para o Sistema Financeiro;O caso de uso termina.  Fluxo Alternativo (4): Inclusão em lista de espera  a. Se não há vaga ou oferta disponível para alguma disciplina selecionada pelo aluno, o sistema informa o fato ao aluno e fornece a opção de inserir o aluno em uma lista de espera para aquela disciplina;  b. Se o aluno aceitar o sistema insere o aluno na lista de espera desejada e apresenta a posição do aluno na lista. O caso de uso retorna ao passo 4;  c. Se o aluno não aceitar o caso de uso prossegue a partir do passo 4.  Fluxo de Exceção (4): Violação de regra de negócio relativa quantidade máxima de créditos a) Se o aluno já atingiu a quantidade máxima de créditos em que pode se matricular por semestre, o sistema informa a quantidade de disciplinas que ele pode se matricular e o caso de uso retorna ao passo 2;  Pós-Condições: O aluno foi inscrito em turmas das disciplinas selecionadas ou foi acrescentado a listas de esperas das disciplinas selecionadas.    Ao final de cada fase são superados os marcos principais do RUP. Cada marco significa o maior risco relacionado àquela etapa. Na fase de concepção é o marco de objetivo de ciclo de vida. Na fase de elaboração é o marco que arquitetura do software. Na fase da construção é o marco da capacidade operacional inicial e, por fim, no marco da transição é o marco da entrega do produto.  Existem problemas nos métodos prescritivos, os principais são:  Forte apego à hierarquiaSegmentação elevada do processo de construçãoEm situações críticas, acabam dando lugar a processos ágeis  ","version":"Next","tagName":"h3"},{"title":"Quando usar cada Processo?​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#quando-usar-cada-processo","content":" Na vida real, podemos encontrar vários modelos misturados no dia a dia das empresas. As práticas em cada empresa são orgânicas e fortemente baseadas na cultura organização local.  Podemos sempre analisar os modelos como uma matriz de 2 eixos: Cascata x Iterativo e Disciplinado x Flexível. Aqui nós só analisamos os processos iterativos. Cabe a você saber se precisa de um processos mais formal como o RUP ou algo mais rápido e flexível como o SCRUM.  ","version":"Next","tagName":"h3"},{"title":"Requisitos​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#requisitos","content":" Podem ser divididos em 2 grupos: requisitos de cliente e requisitos do software. A primeira classe é focada nas necessidades dos usuários 1 que utilização o sistema (é o problema a ser resolvido). A segunda categoria são as características que o produto deve ter para cumpri os requisitos dos clientes (são as ferramentas que o sistema terá para interagir com os users).  Os requisitos de software podem ser divididos em funcionais e não funcionais. Essa divisão será abordada de maneira mais detalhada abaixo.  ","version":"Next","tagName":"h3"},{"title":"Requisitos Funcionais​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#requisitos-funcionais","content":" Os requisitos funcionais são as características que o software deve ter para resolver os problemas elencados como objetivos do sistema proposto. São definidos pelos stakeholders (user, clientes, especialistas e investidores). No SCRUM eles estão no backlog do projeto e no RUP está num documento específico para isso.  É uma lista de exposições breves das funcionalidades que o software fará e como ele se comportará em relação a alguma interação dos usuários. Atente para o fato que os requisitos funcionais são sempre relacionados a algum usuário e não à características técnicas do sistema.  ","version":"Next","tagName":"h3"},{"title":"Requisitos Não Funcionais​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#requisitos-não-funcionais","content":" São as descrições das normas e padrões do produto de software. É aqui que definimos a linguagem de programação, o ambiente, os critérios de segurança, banco de dados, disponibilidade do produto, desempenho e etc.  Um requisito não funcional deve sempre citar um critério de aceitação quantificável. Desse modo, podemos realizar testes objetivos na hora de avaliar se o desenvolvimento da feature foi bem sucedido na iteração.  Podemos elencar alguns tipos de requisito não funcional:  DesempenhoDisponibilidadePortabilidadeUsabilidadeCapacidade e DegradaçãoManutenibilidade  Outros requisitos não funcionais são relacionados ao processo de desenvolvimento. Como por exemplo:  Restrição da equipe desenvolvedoraQual processo de software deve ser usadaQual documentação deve ser criada  Além dessas duas classificações, podemos ter restrições relacionadas ao projeto de software:  Qual SGBD deve ser usadoPlataforma de disponibilidade (web ou não)Qual linguagem de programação usadaQual o SO das plataformasExistência de sistema legado  Todos os requisitos não funcionais estarão no backlog da sprint através da aceitação do incremento pelo cliente e no RUP existe uma documentação específica para isso.  ","version":"Next","tagName":"h3"},{"title":"Atividades e Artefatos da Engenharia de Software​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#atividades-e-artefatos-da-engenharia-de-software","content":" O processo de produção de software é divido em atividades com seus respectivos responsáveis e os artefatos criados a cada etapa finalizada.  As atividades são dividas em técnicas, gerenciais, testes e de apoio2. Essas atividades são as que compõe toda a gestão da engenharia de software.  ","version":"Next","tagName":"h2"},{"title":"Atividades Técnicas​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#atividades-técnicas","content":" Dentro das atividades técnicas nós temos a engenharia de requisitos, design/projeto de software, implementação/codificação, testes e aceitação do cliente.  Podemos elencar as seguintes atividades técnicas necessárias ao bom processo de engenharia de requisitos:  Levantamento de Requisitos (Elicitação): EntrevistasObservaçãoLeitura de documentação Análise dos Requisitos: Análise das lacunasModelagem gráficaRevisão das descrições Especificação dos Requisitos: Descrição sem ambiguidadesLinguagem natural, controlada ou específica Validação dos Requisitos: Revisão de tudoPrototipagemNotações complexas podem dificultar entendimento do clienteValidação por parte do cliente  Agora vamos ver as atividades de Projeto (design) de Software:  Ponderação das alternativas de soluções Escolha da solução que será implementada Detalhamento da solução escolhida (elaboração do projeto): Arquitetura do Software: Alto nível de abstração. Foco nos requisitos não funcionais. Representação das partes gerais da solução.Projeto Detalhado: Baixa abstração. Definição dos objetos e das interações. Foco nos requisitos funcionais. Algoritmos e estruturas de dados.  Uma vez que temos os requisitos elencados e o projeto definido, entramos na etapa de implementação ou codificação.  Implementados os algoritmos, temos a etapa de testes de software para validar os requisitos e garantir que os objetivos sejam alcançados. Podem ser manuais ou automatizados.  Por fim, temos a aprovação do cliente no sentido de cumprimento das funcionalidades esperadas e da qualidade exigida da solução.  Após a aprovação, existe a etapa de manutenção de software que é composta da repetição de todas as etapas expostas acima. Cada manutenção ou aprimoramento passa pelas etapas descritas desde a análise de requisito até a aprovação.  Medidas de Software​  São abordagens de medição e definição de metas para o cumprimento das etapas programadas para alcance dos objetivos da solução contratada.  ","version":"Next","tagName":"h3"},{"title":"Atividades Gerenciais​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#atividades-gerenciais","content":" São as atividades que atuam no controle da complexidade da solução desenvolvida e podem ser dividas em gestão de configuração, gestão de projeto, gestão de requisitos e gestão de processos e, além dessas, possuem atividades afins como gestão da qualidade e estimativas de software.  A gestão de configuração ou gestão de versões é a atividade que cuida da manutenção e organização dos arquivos produzidos durante todo o processo de software. É a atividade que controla as atualizações dos programas e mantém a memória de todas as etapas anteriores.  A gerência de projeto de software é a atividade que controle a dinâmica de tempo, pessoas, custos envolvido no processo de desenvolvimento.  A gerência de requisitos é a atividade de controle das necessidades de mudança no escopo do projeto bem como controla as mudanças na mudança da necessidade do cliente a respeito da mudança de requisitos. Também atua na priorização dos requisitos para a definição dos focos de trabalho. Outra atribuição relacionada é o controle da rastreabilidade dos requisitos pois todas as etapas de elaboração devem ser relacionadas a algum requisito que pertença ao escopo solicitado pelo cliente.  A gestão de Processos é a atividade de definição e melhoria do processo de gestão de software de acordo com as boas práticas, dos modelos de capacitação e maturidade como (CMMI e MPS.BR).  A gestão da qualidade é a atividade que avalia as várias interfaces de dinâmicas que impactam no resultado final do produto de software.  A estimativa de software é a atividade de gerar previsões com base na história da empresa de desenvolvimento afim de melhorar a alocação dos recursos para cumprimento das etapas previstas no início do processo de planejamento.  ","version":"Next","tagName":"h3"},{"title":"Testes de Software​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#testes-de-software","content":" O objetivo dos testes é identificar os problemas da solução desenvolvida mas, como tudo na vida, existem restrições a quantidade e qualidade de testes possíveis de serem feitos uma vez que existem custos associados a essa atividade.  Diante das restrições impostas pela realidade e da complexidade do processo de desenvolvimento, é impossível, não importa o dimensionamento do esforço, garantir uma aplicação livre de erros. O foco dessa atividade é garantir que, ao dado nível de confiança requerido, que o software entregará as capacidades requeridas no projeto.  Os testes são necessários para garantir o cumprimento dos requisitos funcionais e não funcionais e podem ser divididos em dois tipos:  Testes Funcionais/Caixa Preta - Baseados no ponto de vista do usuário do software.Testes Estruturais/Caixa Branca - Ponto de vista de quem desenvolveu o software por meio de inputs e avaliação de outputs.  Uma boa maneira de realizar os testes funcionais é reproduzir as situações listadas nas histórias dos usuários.  Uma Plano de Testes é o documento que indica o conjunto de informações relacionadas ao teste realizado, tais como:  Testes de desempenhoTestes funcionais da história de usuário xTeste de responsividadeTeste de campos de formuláriosTeste de navegabilidade ou linksTeste de ponta a ponta  No teste ponta a ponta passamos por todas as principais características e funcionalidades do produto que desenvolvimento para cumprimento dos requisitos.  Um plano de teste deve conter os casos de testes que, por sua vez, devem conter as seguintes informações:  ObjetivoValores de entradaValores de saída esperadaValores de saída realRegistro de execução (falha ou sucesso)  ","version":"Next","tagName":"h3"},{"title":"Artefatos e Templates​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#artefatos-e-templates","content":" Artefatos​  Os artefatos são um dos produtos que as atividades técnicas e gerencias produzem em cada ciclo de trabalho e podem ser usados nas etapas posteriores da execução do projeto. Existem vários tipos, vamos elencar alguns:  Artefatos do processo de desenvolvimento: Backlog do produto3 Diagramas de casos de usados Descrição de casos de uso Documento de especificação de requisitos: Descreve os requisitos baseados em casos de uso ou outra forma de descrição.  Artefatos do processe de gerenciamento: Documento de arquitetura de software: O nome já denuncia mas é importante porque contém vários diagramas do desenho da aplicação e como a solução foi construída em partes funcionais. Plano de Teste de software Casos de testes Lista de bugs Plano de projeto Matriz de rastreabilidade: Mostra como os requisitos (que compõe as linhas da matriz) se relacionam com os artefatos produzidos durante o processo de produção.  Templates​  Nós já aprendemos o que são os artefatos de software e em que contexto eles são gerados, agora, vamos aprender algumas ferramentas e templates que nos auxiliam no processo de criação desses artefatos durante o processo de desenvolvimento de software.  Comentário Essa seção é mais para consulta quando você precisar gerenciar algum projeto de desenvolvimento de software. Vou tentar manter os links atualizados mas caso algum deixe de funcionar, pode me avisar pelo twitter.  Backlog do produto e Kanban​  Existem várias maneiras de organizar o cumprimento dos requisitos contidos no backlog do projeto. O kanban é um quadro onde transformamos cada item do backlog em unidades separáveis (geralmente post-its ou quadros) onde podemos mover para quadrantes de um board maior. Usualmente temos os quadrantes &quot;A fazer&quot;, &quot;Fazendo&quot; e &quot;Feito&quot;. Desse modo, podemos ver rapidamente o estado do desenvolvimento das atividades programadas para a sprint.  Existem várias ferramentas virtuais que podem ser usadas no processo como:  TrelloPivotalTracker  Especificação de Requisitos de Software​  Existem vários templates disponíveis na internet:  IEE/ISO/IEC 29148Esse exemploMétodo VolerePUC-MG  Documento de Arquitetura de Software​  Architecture View TemplateInterface TemplateIEE/ISO/IEC 42020  Nesse link aqui você pode ver como elaborar um caso de teste funcional a partir dos casos de uso.  Aqui tem um template de ata de reunião.  Por fim, temos um template de matriz de impacto de mudanças aqui. E uma matriz de rastreabilidade em excel aqui.  ","version":"Next","tagName":"h3"},{"title":"Desenhando Processos de Software​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#desenhando-processos-de-software","content":" Essa última seção é um exercício onde vamos colocar em prática todos os conceitos aprendidos até agora. Temos que saber que os conceitos aprendidos não são regras imutáveis na aplicação prática em um processo de software. Podemos combinar características de vários modelos durante o processo de execução de um planejamento sempre com foco na melhora contínua da qualidade do software.  Mesmo tendo muita flexibilidade sobre o processo de software, podemos elencar características que são obrigatórias em qualquer desenho:  Qual o modelo de ciclo de vidaQuais as atividades que comporão o processo de software e quais a técnicas usadas ao longo delasQuais produtos ou artefatos serão gerados a cada etapaOs papéis dos agentes relacionados ao longo do processo  Nós começamos o nosso estudo de engenharia de software pelos modelos de ciclo de vida exatamente porque eles regem grande parte das atividades e artefatos produzidos durante todo o processo de software. A maturidade da empresa, dimensionamento da mão de obra, recursos disponíveis, verba do projeto, tempo de execução e outras características são importantes para definição do melhor modelo de ciclo de vida a ser adotado.  A nossa jornada pela engenharia de software vai ser em grande medida construir um amplo repertório de modelos de ciclo de vida, atividades e artefatos.  Para facilitar o complexo processo de software, existem várias ferramentas que centralizam as diferentes etapas e simplificam o processo de gestão:  Bizagi ModelerEclipse Process Framework  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Fundamentos de Engenharia de Software","url":"/CC_site/docs/puc/primeiro-periodo/fundamentos-engenharia-software#bibliografia","content":" PRESSMAN, Roger S.; MAXIM, Bruce R. Engenharia de software: uma abordagem profissional. 8. ed. Porto Alegre: AMGH, 2016. E-book ISBN 9788580555349. Capítulos 1, 2, 3PRIKLADNICKI, Rafael, WILLI, Renato, e MILANI, Fabiano. Métodos ágeis para desenvolvimento de software. Porto Alegre: Bookman, 2014 1 recurso online ISBN 9788582602089 Capítulos 1,2,3,8,12,13SOMMERVILLE, Ian. Engenharia de software, 10ª ed. Pearson 768 ISBN 9788543024974 Capítulos 1,2,3,4COHN, Mike; SILVA, Aldir José Coelho Corrêa da. Desenvolvimento de software com Scrum: aplicando métodos ágeis com sucesso. Porto Alegre: Bookman, 2011. E-book ISBN 9788577808199LARMAN, Craig. Utilizando UML e padrões: uma introdução á análise e ao projeto orientados a objetos e desenvolvimento iterativo. 3. ed. Porto Alegre: Bookman, 2007. E-book (695 páginas) ISBN 9788577800476PAULA FILHO, Wilson de Pádua. Engenharia de software, v. 2 projetos e processos. 4. Rio de Janeiro LTC 2019 1 recurso online ISBN 9788521636748VETORAZZO, Adriana de Souza. Engenharia de software. Porto Alegre SAGAH 2018 1 recurso online ISBN 9788595026780WAZLAWICK, Raul Sidnei. Engenharia de software conceitos e práticas. Rio de Janeiro GEN LTC 2013 1 recurso online ISBN 9788595156173    Footnotes​ Por meio das histórias de usuários ou dos casos de uso. ↩ Não focaremos nessa parte mas são as atividades de RH, administrativo e etc. ↩ Nós já sabemos o que é. ↩ ","version":"Next","tagName":"h2"},{"title":"APIs e Webservices","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/quarto-periodo/api-webservices","content":"","keywords":"","version":"Next"},{"title":"Fundamentos de APIs e Web Services​","type":1,"pageTitle":"APIs e Webservices","url":"/CC_site/docs/puc/quarto-periodo/api-webservices#fundamentos-de-apis-e-web-services","content":" ","version":"Next","tagName":"h2"},{"title":"Arquitetura baseada em API​","type":1,"pageTitle":"APIs e Webservices","url":"/CC_site/docs/puc/quarto-periodo/api-webservices#arquitetura-baseada-em-api","content":" Arquitetura de Aplicações Web​  Fundamentos de APIs e Web Services​  ","version":"Next","tagName":"h3"},{"title":"Paradigmas de APIs​","type":1,"pageTitle":"APIs e Webservices","url":"/CC_site/docs/puc/quarto-periodo/api-webservices#paradigmas-de-apis","content":" APIs Request-Response​  APIs Orientadas a Eventos​  ","version":"Next","tagName":"h3"},{"title":"Segurança de APIs​","type":1,"pageTitle":"APIs e Webservices","url":"/CC_site/docs/puc/quarto-periodo/api-webservices#segurança-de-apis","content":" JSON Web Token (JWT)​  OAuth (Open Authorization)​  ","version":"Next","tagName":"h3"},{"title":"Desenvolvimento de APIs e Web Services​","type":1,"pageTitle":"APIs e Webservices","url":"/CC_site/docs/puc/quarto-periodo/api-webservices#desenvolvimento-de-apis-e-web-services","content":" ","version":"Next","tagName":"h2"},{"title":"Ambiente de Desenvolvimento​","type":1,"pageTitle":"APIs e Webservices","url":"/CC_site/docs/puc/quarto-periodo/api-webservices#ambiente-de-desenvolvimento","content":" Configuração​  Modelagem de Dados​  ","version":"Next","tagName":"h3"},{"title":"Desenvolvimento de uma API Web​","type":1,"pageTitle":"APIs e Webservices","url":"/CC_site/docs/puc/quarto-periodo/api-webservices#desenvolvimento-de-uma-api-web","content":" Criação dos serviços web para Veículos​  Criação dos serviços web para Consumos​  Criação dos serviços web para Usuários​  ","version":"Next","tagName":"h3"},{"title":"Segurança na Web API​","type":1,"pageTitle":"APIs e Webservices","url":"/CC_site/docs/puc/quarto-periodo/api-webservices#segurança-na-web-api","content":" Autenticação​  Autorização​ ","version":"Next","tagName":"h3"},{"title":"Arquitetura de Software Distribuído","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida","content":"","keywords":"","version":"Next"},{"title":"Fundamentos de Sistemas Distribuídos​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#fundamentos-de-sistemas-distribuídos","content":" ","version":"Next","tagName":"h2"},{"title":"Definições de Sistemas Distribuídos​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#definições-de-sistemas-distribuídos","content":" Redes e Sistemas Distribuídos​  Até agora, todas as aplicações que construímos usaram uma separação lógica entre camadas (como o modelo MVC) mas, no fim do dia, tudo isso rodava sempre num mesmo servidor (que na maioria das vezes é o nosso computador de casa que usamos para estudar). Entretanto, quando pensamos em aplicações reais de alta performance (como sites de bancos, corretoras de valores, o Ifood, o Uber e etc) podemos ter certeza que esses serviços não são executados por um único servidor monolítico que é capaz de fazer todas as camadas de processamento desses serviços.  No mundo real, as aplicações funcionam de maneira distribuída em diferentes servidores.  Diante disso, temos que entender bem como os conceitos de Redes de Computadores e Sistemas Distribuídos se relacionam.  Redes de Computadores​  Nós já aprendemos sobre esse assunto na microfundamento de Fundamentos de Redes do segundo período.  Podemos definir uma rede como sendo a soma das seguintes partes:  Rede=(Dispositivos Eletro^nicos)+(Sistemas de Comunicac\\ca~o)+(Protocolos de Rede)Rede = (Dispositivos \\ Eletrônicos) + (Sistemas \\ de \\ Comunicação) + (Protocolos \\ de \\ Rede)Rede=(Dispositivos Eletro^nicos)+(Sistemas de Comunicac\\c​a~o)+(Protocolos de Rede)  Ou seja, uma rede é o conjunto de componentes físicos e lógicos que permitem a troca de dados entre os dispositivos.  Sistemas Distribuídos​  Por outro lado, um sistemas distribuído pode ser definido (Coulouris et al, 2013) como sendo um sistema cujas partes (hardware ou software) se comunicam por meio de uma rede e coordenam suas ações apenas enviando mensagens entre si.  Ou seja, um sistema distribuído precisa de uma rede de computadores para existir. Entretanto, não são a mesma coisa (na verdade são conceitos bem diferentes).  Um sistema distribuído é composto por um conjunto de vários softwares (que chamaremos de serviços ou microsserviços) que atuam em conjunto como se fosse um programa apenas.  Nesse microfundamento vamos aprender alguns padrões arquiteturais de construção de sistemas distribuídos1.  Exemplos de Software Distribuído​  Podemos elencar uma série de sistemas distribuídos que utilizamos corriqueiramente:  Sistemas de Banco de Dados Permitem acesso unificado a uma infraestrutura de dadosSão acessados por diferentes origens de frontend Aplicações Web Sistemas complexos que utilizam fortemente as redes de computadoresSeparação em várias camadas lógicas: frontend, backend, banco de dados, servidor de arquivos e etcUtilizam arquitetura cliente-servidor Sistemas P2P Sistemas construídos de maneira não centralizadaCada nó implementa a lógica de aplicação e acesso parcial as dadosMaior custo de localização de dados quando comparado aos sistemas centralizados Aplicações de Internet das Coisas Vários microcontroladores com sensores cada vez mais conectados à internet Redes Sociais  ","version":"Next","tagName":"h3"},{"title":"Características de Sistemas Distribuídos​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#características-de-sistemas-distribuídos","content":" Compartilhamento de Recursos​  Uma característica que une todos os sistemas atuais é o compartilhamento de informações. Nas aplicações modernas, é muito estranho pensarmos no usuário apenas como um consumidor de dados sem que ele mesmo seja um ator ativo no processo. No passado, a coisa era bem diferente, a chamada web 1.0 era estática e unidirecional.  Diante dessa nova realidade, temos que pensar em soluções que permitam o compartilhamento de informações em diferentes meios (web, mobile, API e etc) e entre múltiplos usuários (como uma planilha no google sheets que pode acessada por vários usuários simultaneamente).  Serviços e Servidores​  Podemos definir como serviço qualquer parte de um sistema que gerencia um conjunto de recursos por meio de uma interface. Em sistemas distribuídos, os recursos são acessados remotamente por mecanismos de comunicação.  Um servidor é um programa (isso mesmo, um programa) que é executado em um hardware (que também costumamos chamar de servidor) e que atende às solicitações feitas por programas em outros computadores.  Aqui tem um vídeo bacana sobre o que é um servidor.    A arquitetura mais famosa e simples é a cliente-servidor que a essa altura do campeonato já estamos bem familiares.  Chamamos de requisição remota o processo completo da comunicação entre cliente e servidor que vai desde a requisição inicial até o recebimento da resposta esperada.  **Atenção: ** Mesmo que possa parecer, a arquitetura client-server não é a única possível. Falamos agora a pouco que existem sistemas P2P que subvertem essa lógica e transformam todos os nós em clientes-servidores ao mesmo tempo.  Desafios de Arquiteturas Distribuídas​  ","version":"Next","tagName":"h3"},{"title":"Arquiteturas de Software Distribuído​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#arquiteturas-de-software-distribuído","content":" ","version":"Next","tagName":"h2"},{"title":"Modelos Arquiteturais para Sistemas Distribuídos​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#modelos-arquiteturais-para-sistemas-distribuídos","content":" Sistemas Distribuídos Centralizados​  Sistemas Distribuídos Descentralizados​  Estilos Arquiteturais​  ","version":"Next","tagName":"h3"},{"title":"Modelos de Comunicação de Sistemas Distribuídos​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#modelos-de-comunicação-de-sistemas-distribuídos","content":" Comunicação entre Processos​  Invocação Remota​  Comunicação Indireta​  ","version":"Next","tagName":"h3"},{"title":"Implementação de Software Distribuído​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#implementação-de-software-distribuído","content":" ","version":"Next","tagName":"h2"},{"title":"Middlewares para Desenvolvimento de Sistemas Distribuídos​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#middlewares-para-desenvolvimento-de-sistemas-distribuídos","content":" Objetos Distribuídos​  Serviços Web​  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#bibliografia","content":" ","version":"Next","tagName":"h2"},{"title":"Obrigatória​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#obrigatória","content":" COULOURIS, George; DOLLIMORE, Jean; KINDBERG, Tim; BLAIR, Gordon. Sistemas distribuídos conceitos e projeto. 5. Ed. Porto Alegre: Bookman, 2013. ISBN 9788582600542.BASS, Len; CLEMENTS, Paul; KAZMAN, Rick. Software Architecture in Practice, Third Edition. Addison-Wesley Professional (O'Reilly). September 2012FORD, Neal; RICHARDS, Mark. Fundamentals of Software Architecture. O'Reilly Media, 2020. ISBN 9781492043454.JOURNAL OF SYSTEMS ARCHITECTURE: JSA : the Euromicro journal. New York: Elsevier,1996-. Mensal. ISSN 1383-7621.  ","version":"Next","tagName":"h3"},{"title":"Complementar​","type":1,"pageTitle":"Arquitetura de Software Distribuído","url":"/CC_site/docs/puc/quarto-periodo/arquitetura-distribuida#complementar","content":" CLEMENTS, Paul; BACHMANN, Felix; GARLAN, David; IVERS, James; LITTLE, Reed; MERSON, Paulo; NORD, Robert; STAFFORD, Judith. Documenting Software Architectures: Views and Beyond, Second Edition. Addison-Wesley Professional (O'Reilly). October 2010. ISBN: 9780132488617ERL, Thomas. SOA: princípios de design de serviços. Pearson 334 ISBN 9788576051893.JOURNAL OF CLOUD COMPUTING. London, UK: Springer,2012-. Anual. ISSN 2192-113X.KATZER, Jason. Learning Serverless. O'Reilly Media, 2019. ISBN 9781492057017.LEE, Valentino; Schneider, Heather; Schell, Robbie. Aplicações Móveis: arquitetura, projetos e desenvolvimento. Pearson 350 ISBN 9788534615402.TANENBAUM, Andrew S.; STEEN, Maarten van. Sistemas Distribuídos: princípios e paradigmas. 2. Ed. Pearson, 2015. ISBN 9788576051428.    Footnotes​ Vai por mim. Aprende bem essa aula porque praticamente todas as empresas grandes usam essas arquiteturas. ↩ ","version":"Next","tagName":"h3"},{"title":"Bancos de Dados NoSQL","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/quarto-periodo/banco-nosql","content":"","keywords":"","version":"Next"},{"title":"Introdução​","type":1,"pageTitle":"Bancos de Dados NoSQL","url":"/CC_site/docs/puc/quarto-periodo/banco-nosql#introdução","content":" ","version":"Next","tagName":"h2"},{"title":"Conceitos Básicos​","type":1,"pageTitle":"Bancos de Dados NoSQL","url":"/CC_site/docs/puc/quarto-periodo/banco-nosql#conceitos-básicos","content":" Terminologia​  História​  Características​  Benefícios​  ","version":"Next","tagName":"h3"},{"title":"Taxonomia de Bancos NoSQL​","type":1,"pageTitle":"Bancos de Dados NoSQL","url":"/CC_site/docs/puc/quarto-periodo/banco-nosql#taxonomia-de-bancos-nosql","content":" Tipos de Bancos​  Casos de Uso​  Aspectos Arquiteturais​  ","version":"Next","tagName":"h3"},{"title":"SGBDS NoSQL​","type":1,"pageTitle":"Bancos de Dados NoSQL","url":"/CC_site/docs/puc/quarto-periodo/banco-nosql#sgbds-nosql","content":" ","version":"Next","tagName":"h2"},{"title":"Modelos de Dados NoSQL​","type":1,"pageTitle":"Bancos de Dados NoSQL","url":"/CC_site/docs/puc/quarto-periodo/banco-nosql#modelos-de-dados-nosql","content":" Tabular​  Chave-Valor​  Coluna​  Documento​  Grafos​  ","version":"Next","tagName":"h3"},{"title":"Sistemas de Bancos NoSQL​","type":1,"pageTitle":"Bancos de Dados NoSQL","url":"/CC_site/docs/puc/quarto-periodo/banco-nosql#sistemas-de-bancos-nosql","content":" Cassandra​  MongoDB​  Neo4J​  Redis​ ","version":"Next","tagName":"h3"},{"title":"Cloud Computing","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/quarto-periodo/cloud","content":"","keywords":"","version":"Next"},{"title":"Virtualização de Computadores​","type":1,"pageTitle":"Cloud Computing","url":"/CC_site/docs/puc/quarto-periodo/cloud#virtualização-de-computadores","content":" ","version":"Next","tagName":"h2"},{"title":"Fundamentos de Virtualização​","type":1,"pageTitle":"Cloud Computing","url":"/CC_site/docs/puc/quarto-periodo/cloud#fundamentos-de-virtualização","content":" Conceitos​  Vantagens e Desvantagens​  Hypervisor​  ","version":"Next","tagName":"h3"},{"title":"Tipos de Virtualização​","type":1,"pageTitle":"Cloud Computing","url":"/CC_site/docs/puc/quarto-periodo/cloud#tipos-de-virtualização","content":" Virtualização de Rede​  Virtualização de Armazenamento​  Virtualização de Servidores​  ","version":"Next","tagName":"h3"},{"title":"Virtualização e Cloud​","type":1,"pageTitle":"Cloud Computing","url":"/CC_site/docs/puc/quarto-periodo/cloud#virtualização-e-cloud","content":" Ferramentas de Virtualização​  Containers e Docker​  Integração com Nuvem​  ","version":"Next","tagName":"h3"},{"title":"Computação em Nuvem​","type":1,"pageTitle":"Cloud Computing","url":"/CC_site/docs/puc/quarto-periodo/cloud#computação-em-nuvem","content":" ","version":"Next","tagName":"h2"},{"title":"Fundamentos de Computação em Nuvem​","type":1,"pageTitle":"Cloud Computing","url":"/CC_site/docs/puc/quarto-periodo/cloud#fundamentos-de-computação-em-nuvem","content":" Introdução​  Tipos de Nuvem​  Características do Cloud​  ","version":"Next","tagName":"h3"},{"title":"Modelos de Cloud​","type":1,"pageTitle":"Cloud Computing","url":"/CC_site/docs/puc/quarto-periodo/cloud#modelos-de-cloud","content":" Infraestrutura como Serviço​  Plataforma como Serviço​  Software como Serviço​  Banco de Dados como Serviço​  ","version":"Next","tagName":"h3"},{"title":"Arquitetura e Gestão de Nuvem​","type":1,"pageTitle":"Cloud Computing","url":"/CC_site/docs/puc/quarto-periodo/cloud#arquitetura-e-gestão-de-nuvem","content":" Regiões e Zonas de Disponibilidade​  Tipos de Instância e Modelos de Pagamento​  Implementação de Soluções em Nuvem​ ","version":"Next","tagName":"h3"},{"title":"Projeto de Software","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/quarto-periodo/projeto-software","content":"","keywords":"","version":"Next"},{"title":"Projeto e Arquitetura de Software​","type":1,"pageTitle":"Projeto de Software","url":"/CC_site/docs/puc/quarto-periodo/projeto-software#projeto-e-arquitetura-de-software","content":" ","version":"Next","tagName":"h2"},{"title":"Conceitos​","type":1,"pageTitle":"Projeto de Software","url":"/CC_site/docs/puc/quarto-periodo/projeto-software#conceitos","content":" Importância do Projeto​  Modelo de Projeto​  ","version":"Next","tagName":"h3"},{"title":"Construção de um Projeto​","type":1,"pageTitle":"Projeto de Software","url":"/CC_site/docs/puc/quarto-periodo/projeto-software#construção-de-um-projeto","content":" Projeto de Arquitetura​  Projeto de Componentes​  Projeto de UX​  Projeto de Mobilidade​  ","version":"Next","tagName":"h3"},{"title":"Padrões e Modelagem​","type":1,"pageTitle":"Projeto de Software","url":"/CC_site/docs/puc/quarto-periodo/projeto-software#padrões-e-modelagem","content":" ","version":"Next","tagName":"h2"},{"title":"Projeto Baseado em Padrões​","type":1,"pageTitle":"Projeto de Software","url":"/CC_site/docs/puc/quarto-periodo/projeto-software#projeto-baseado-em-padrões","content":" Padrões de Projeto​  Padrões GRASP​  ","version":"Next","tagName":"h3"},{"title":"Modelagem de Projeto​","type":1,"pageTitle":"Projeto de Software","url":"/CC_site/docs/puc/quarto-periodo/projeto-software#modelagem-de-projeto","content":" Diagramas de Projeto​  Mapeamento Objeto-Relacional​ ","version":"Next","tagName":"h3"},{"title":"Testes de Software","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/quarto-periodo/testes","content":"","keywords":"","version":"Next"},{"title":"Fundamentos de Testes​","type":1,"pageTitle":"Testes de Software","url":"/CC_site/docs/puc/quarto-periodo/testes#fundamentos-de-testes","content":" ","version":"Next","tagName":"h2"},{"title":"Conceitos​","type":1,"pageTitle":"Testes de Software","url":"/CC_site/docs/puc/quarto-periodo/testes#conceitos","content":" Introdução​  Tipos e Níveis​  Projeto de Casos​  Testes de Unidade​  Testes de Integração​  Testes de Sistemas​  ","version":"Next","tagName":"h3"},{"title":"Teste como Processo​","type":1,"pageTitle":"Testes de Software","url":"/CC_site/docs/puc/quarto-periodo/testes#teste-como-processo","content":" Processo de Testes​  Plano de Testes​  Métricas de Testes​  ","version":"Next","tagName":"h3"},{"title":"Automatização de Testes​","type":1,"pageTitle":"Testes de Software","url":"/CC_site/docs/puc/quarto-periodo/testes#automatização-de-testes","content":" ","version":"Next","tagName":"h2"},{"title":"Plano de Testes​","type":1,"pageTitle":"Testes de Software","url":"/CC_site/docs/puc/quarto-periodo/testes#plano-de-testes-1","content":" Fluxo de Trabalho​  Ferramentas e Frameworks​  ","version":"Next","tagName":"h3"},{"title":"Testes de Unidade​","type":1,"pageTitle":"Testes de Software","url":"/CC_site/docs/puc/quarto-periodo/testes#testes-de-unidade-1","content":" Fluxo de Trabalho​  Ferramentas e Frameworks​  ","version":"Next","tagName":"h3"},{"title":"Testes de Integração​","type":1,"pageTitle":"Testes de Software","url":"/CC_site/docs/puc/quarto-periodo/testes#testes-de-integração-1","content":" Fluxo de Trabalho​  Ferramentas e Frameworks​  ","version":"Next","tagName":"h3"},{"title":"Testes de Sistemas​","type":1,"pageTitle":"Testes de Software","url":"/CC_site/docs/puc/quarto-periodo/testes#testes-de-sistemas-1","content":" Fluxo de Trabalho​  Ferramentas e Frameworks​ ","version":"Next","tagName":"h3"},{"title":"Lógica Computacional","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional","content":"","keywords":"","version":"Next"},{"title":"Pensamento Lógico​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#pensamento-lógico","content":" A primeira parte eu já cobri, de maneira mais aprofundada, no projeto matemática. Se quiserem ver um material mais completo, podem conferir na Bibliografia ou no meu Projeto Matemática. Provavelmente, essa seção inteira será deletada no futuro e todo o conteúdo dela será desenvolvido pelo projeto matemática.  ","version":"Next","tagName":"h2"},{"title":"Definições​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#definições","content":" Aqui vai ficar apenas uma lista de todos os conceitos explicados nesse tópico. Se alguém tiver alguma dúvida sobre eles, recomendo ler a bibliografia indicada ou o projeto matemática.  ConjuntoElementoPertencimento e IgualdadePropriedades dos conjuntosConjunto vazioTipos de definições de conjuntos (chaves, set builder notation, recursão, característica)  ","version":"Next","tagName":"h3"},{"title":"Subconjuntos​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#subconjuntos","content":" Notação (A⊂B)(A \\subset B)(A⊂B)Diagrama de VennConjunto Potência (Power Set)Sequências (lista de objetos ordenados)  ","version":"Next","tagName":"h3"},{"title":"Operações sobre Conjuntos​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#operações-sobre-conjuntos","content":" Cardinalidade (∣1,5,3∣=3)(|{1,5,3}| = 3)(∣1,5,3∣=3) Emparelhamento: Se X e Y possuem a mesmo cardinal, ao ligarmos cada elemento de X a um elemento de Y, dizemos que os conjuntos estão emparelhados Produto Cartesiano: A×B={(a,b)∣a∈A∧b∈B}A \\times B = \\{(a,b) | a \\in A \\land b \\in B\\}A×B={(a,b)∣a∈A∧b∈B} Conjunto Universo/Universal Propriedades dos Conjuntos: Comutatividade Associatividade Distributividade União e Interseção com Universo Complemento Duplo Idempotência Lei de DeMorgan Absorção Diferença de Conjuntos União e Interseção com Vazio União e Interseção com complemento Complementos de U e vazio Conjunto Disjuntos (A∩B=∅A \\cap B = \\emptysetA∩B=∅) Partição (A=A1∪A2⋯∪AnA = A_1 \\cup A_2 \\dots \\cup A_nA=A1​∪A2​⋯∪An​)  ","version":"Next","tagName":"h3"},{"title":"Princípios da Lógica Proposicional​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#princípios-da-lógica-proposicional","content":" Lógica: Ramo da Filosofia, Matemática e Ciência da Computação que lida com inferências válidasHipóteses vedadeiras →\\rightarrow→ Conclusões VerdadeirasAsserção: Uma afirmação declarativaProposição: Uma asserção verdadeira ou falsa mas não ambosVariáveis Proposicionais: É a variável atribuída à alguma proposiçãoProposições Compostas: Proposições ligadas por operadores lógicosTabela Verdade  ","version":"Next","tagName":"h3"},{"title":"Conectivos Lógicos​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#conectivos-lógicos","content":" Conectivos: Criam novas proposições a partir de duas ou mais proposiçõesNegação (≠\\neq=)Conjunção (∧\\land∧)Disjunção (∨\\lor∨)Disjunção Exclusva (⊕\\oplus⊕)Condicional ou Implicação (p→qp \\rightarrow qp→q). Onde p é a hipótese e q é a conclusãoBicondicional (p→q∧q→pp \\rightarrow q \\land q \\rightarrow pp→q∧q→p) ou (p↔qp \\leftrightarrow qp↔q)Proposições CompostasOrdem de Precedência em Proposições Compostas:NegaçãoConjunçãoDisjunçãoImplicaçãoImplicação Dupla  ","version":"Next","tagName":"h3"},{"title":"Tabela Verdade e Equivalência Lógica​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#tabela-verdade-e-equivalência-lógica","content":" Esse assunto eu realmente recomendo o material do projeto matemática no site Economia Mainstream.  Tautologia: Uma proposição que sempre será verdadeiraContradição ou Absurdo: Proposição sempre falsaContingência: Proposição cujo valor será definido pelas suas variáveis proposicionaisEquivalência Lógica: Se duas proposições possuem a mesma tabela verdade, elas são equivalentesLógica Proposicional - Sentenças objetivas e não ambíguas, circuitos lógicos, automação de processos e etc  ","version":"Next","tagName":"h3"},{"title":"Predicados e Quantificadores​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#predicados-e-quantificadores","content":" A proposição x&gt;3x &gt; 3x&gt;3 possui dois componentes:  xxx é chamado de sujeito  &gt;3&gt;3&gt;3 é chamado de predicado  P(x)P(x)P(x) é a notação para uma declaração com predicado PPP e sujeito xxxA validade de uma proposição desse tipo depende inteiramente do valor do sujeitoQuantificador universal: {∀x∈R:P(X)}={P(x1)∧P(x2)∧… }\\{ \\forall x \\in \\mathbb{R} : P(X)\\} = \\{P(x_1) \\land P(x_2) \\land \\dots\\}{∀x∈R:P(X)}={P(x1​)∧P(x2​)∧…}Quantificador existencial: {∃x∈R:P(X)}={P(x1)∨P(x2)∨… }\\{\\exists x \\in \\mathbb{R} : P(X)\\} = \\{P(x_1) \\lor P(x_2) \\lor \\dots\\}{∃x∈R:P(X)}={P(x1​)∨P(x2​)∨…}  ","version":"Next","tagName":"h3"},{"title":"Ligando Variáveis​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#ligando-variáveis","content":" Uma variável é dita amarrada quando está atrelada a algum quantificador ou quando algum valor é atribuído a elaSe uma variável não está amarrada, então dizemos que ela está livreUm proposição só existe se todas as suas variáveis estiverem amarradasQuando atribuímos um quantificador a uma variáveis, dizemos que estamos definindo o seu escopo∃x(P(x)∧Q(x))∨∀xR(x)\\exists x (P(x) \\land Q(x)) \\lor \\forall x R(x)∃x(P(x)∧Q(x))∨∀xR(x) : É uma proposição cujo primeiro escopo é dado por ∃x\\exists x∃x e o segundo é dado por ∀x\\forall x∀x  ","version":"Next","tagName":"h3"},{"title":"Negações​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#negações","content":" ¬∀P(x)=∃x¬P(x)\\neg \\forall P(x) = \\exists x \\neg P(x)¬∀P(x)=∃x¬P(x)¬∃xQ(x)=∀x¬Q(x)\\neg \\exists x Q(x) = \\forall x \\neg Q(x)¬∃xQ(x)=∀x¬Q(x)  ","version":"Next","tagName":"h3"},{"title":"Pensamento Analítico​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#pensamento-analítico","content":" ","version":"Next","tagName":"h2"},{"title":"Provas de Teoremas​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#provas-de-teoremas","content":" Um teorema é uma declaração em que pode-se demonstrar a sua validade de maneira lógica. Esse processo é chamado de prova e obedece aos construdos lógicos que aprendemos na primeira parte desse microfundamento.  Sempre que temos um teorema, podemos reduzir sua estrutura em dois componentes: Sua hipótese (ppp) e sua conclusão (qqq). A prova do teorema é justamente a comprovação que, a partir da hipótese, podemos chegar na conclusão proposta.  A habilidade de comprovar teoremas é a real linguagem da matemática. Requer muita criatividade, lógica e capacidade de ser claro na exposição dos argumentos.  A construção de provas matemáticas deve ter um conjunto de ferramentas que podemos elencar:  Axiomas/PostuladosTeoremas já provadosHipótesesProposições derivadas as anteriores segundo as regras de inferência  ","version":"Next","tagName":"h3"},{"title":"Regras de Inferência​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#regras-de-inferência","content":" as regras de inferência são as regras que garantem a obtenção de novas informações a partir de informações anteriores e, simultaneamente, o respeito às regras lógicas.  O modus ponens (modo de afirmar) é a regra de inferência fundamental. Sua lógica é a seguinte:  Data a tautologia (p∧(p→q))→q(p \\land (p \\rightarrow q)) \\rightarrow q(p∧(p→q))→qSe ppp for verdade, então, a tautologia nos diz que será verdade que p→qp \\rightarrow qp→qO que por fim, nos garante que qqq seja o resultado alcançado com a verdade de ppp  A escrita desse argumento é com a colocação das verdades na parte de cima de uma linha horizontal e das conclusões na parte de baixo.  ppp  p→qp \\rightarrow qp→q  ∴q\\therefore q∴q  Esse &quot;∴\\therefore∴&quot; significa &quot;portanto&quot;.  Além da regra fundamental, nós temos uma grande quantidade de outras regras importantes para construção de provas de teoremas. Abaixo podemos ver uma tabela com várias delas.  Tautologia\tNomep→(p∨q)p \\rightarrow (p \\lor q)p→(p∨q)\tAdição (p∧q)→p(p \\land q) \\rightarrow p(p∧q)→p\tSimplificação ((p)∧(q))→(p∧q)((p) \\land (q)) \\rightarrow (p \\land q)((p)∧(q))→(p∧q)\tConjunção [p∧(p→q)]→q[p \\land (p \\rightarrow q)] \\rightarrow q[p∧(p→q)]→q\tModus Ponens [¬q∧(p→q)]→¬p[\\neg q \\land (p \\rightarrow q)] \\rightarrow \\neg p[¬q∧(p→q)]→¬p\tModus Tollens [(p→q)∧(q→r)]→(p→r)[(p \\rightarrow q) \\land (q \\rightarrow r)] \\rightarrow (p \\rightarrow r)[(p→q)∧(q→r)]→(p→r)\tSilogismo hipotético [(p∨q)∧¬p]→q[(p \\lor q) \\land \\neg p] \\rightarrow q[(p∨q)∧¬p]→q\tSilogismo disjuntivo [(p∨q)∧(¬p∨r)][(p \\lor q) \\land (\\neg p \\lor r)][(p∨q)∧(¬p∨r)]\tResolução  ","version":"Next","tagName":"h3"},{"title":"Argumentos Válidos​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#argumentos-válidos","content":" Na lógica proposicional, um argumento é dito valido se sempre que as hipóteses forem verdadeiras, a conclusão será, obrigatoriamente, verdadeira. Em notação formal dizemos que  p1∧⋯∧pn→qp_1 \\land \\dots \\land p_n \\rightarrow qp1​∧⋯∧pn​→q  A demonstração da validade de um argumento depende de como as hipóteses se conectam com as conclusões sempre de maneira lógica segundo o correto uso dos conectivos lógicos já estudados.  Em tese, a construção de uma tabela verdade é sempre possível para um número arbitrário de hipóteses, o problema disso, é que o tamanho dessa tabela cresce na razão de 2n2^n2n sendo nnn a quantidade de hipóteses. Para superarmos esse problema, fazemos grande uso das regras de inferência.  Uma premissa falsa aplicada a uma argumentação logicamente correta gera conclusões falsas. Então a validade das premissas também pode ser um motivo de cuidado na hora de construirmos teoremas.  Uma falácia é um tipo de erro argumentativo que, à primeira vista, até se parece com um argumento válido, mas possui algum erro na sua construção. Um exemplo é a falácia da afirmação da conclusão que pode ser expressa como [(p→q)∧q]→p[(p \\rightarrow q) \\land q] \\rightarrow p[(p→q)∧q]→p. Essa expressão é falsa quando ppp é falso e qqq verdadeiro.  Um exemplo em linguagem natural dessa falácia é &quot;p→qp \\rightarrow qp→q: Quem resolve todos os exercícios aprende. qqq: Você aprendeu. Logo, ppp: você resolveu todos os exercícios&quot;. Veja que, se alguém aprender (o que torna qqq verdadeiro) mas não fizer todos os exercícios (tornando ppp falso) quebra a linha de argumentação e torna essa proposição falsa.  Outra falácia conhecida é a negação da hipótese. Podemos construir ela como sendo [(p→q)∧¬p]→¬q[(p \\rightarrow q) \\land \\neg p] \\rightarrow \\neg q[(p→q)∧¬p]→¬q. A primeira vista, parece certo, mas não é.  Regras de Inferência​  Comentário Eu achei que essa parte foi um pouco negligenciada no curso. Devo voltar aqui para expandir esse conteúdo mais tarde. Por enquanto, temos essa tabela de referência.  Regra de Inferência\tNome\tNota∀xP(x)→P(c)\\forall x P(x) \\rightarrow P(c)∀xP(x)→P(c)\tInstanciação Universal\tc específico P(c)→∀xP(x)P(c) \\rightarrow \\forall x P(x)P(c)→∀xP(x)\tGeneralização Universal\tc arbitrário ∃xP(x)→P(c)\\exists x P(x) \\rightarrow P(c)∃xP(x)→P(c)\tInstanciação Existencial\tc específico e não conhecido P(c)→∃xP(x)P(c) \\rightarrow \\exists x P(x)P(c)→∃xP(x)\tGeneralização Existencial\tc específico e conhecido  ","version":"Next","tagName":"h3"},{"title":"Indução Matemática​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#indução-matemática","content":" A dedução é o processo de, a partir de premissas verdadeiras, determinar as conclusões verdadeiras necessariamente oriundas dessas premissas. Ou seja, é o processo de, partindo de um princípio geral se chegar em um caso especial.  O processo reverso é chamado de indução. Partir do caso específico para um princípio anterior geral.  A indução pode ser usada para comprovar teoremas que se relacionam com um número arbitrário de elementos (ou mesmo infinitos elementos). Basicamente, a demonstração por indução consiste em dois passos:  Passo básico (provar para P(n=1)P(n=1)P(n=1))Passo indutivo (Provar que P(k) ⟹ P(k+1)P(k) \\implies P(k+1)P(k)⟹P(k+1))  Temos que ter cuidado com o passo básico. Afirmar que P(n=1)P(n=1)P(n=1) é verdadeiro não é provar. Similarmente, no passo indutivo, também não podemos assumir que P(k)P(k)P(k) é verdade sem tomar muito cuidado. O ideial é que P(k)P(k)P(k) seja evidentemente verdadeira.  ","version":"Next","tagName":"h3"},{"title":"Indução Forte​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#indução-forte","content":" Similar ao processo de prova por indução simples. A indução forte possui 2 passos:  Provar que P(n=1)P(n=1)P(n=1) é verdadeiroProvar que P(1)∧P(2)∧⋯∧P(k) ⟹ P(k+1)P(1) \\land P(2) \\land \\dots \\land P(k) \\implies P(k+1)P(1)∧P(2)∧⋯∧P(k)⟹P(k+1)  Ao contrário do que o nome sugere, a indução forte é mais flexível que a indução simples. O material é um pouco obtuso nesse tema, então vamos ter que revisar essa seção posteriormente.  ","version":"Next","tagName":"h3"},{"title":"Recursão​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#recursão","content":" As vezes precisamos lidar com sequências, conjuntos ou funções que não são definíveis facilmente. Para conseguirmos um tipo útil de definição, podemos usar um processo chamado de recursão em que definimos um objeto pela sua característica de composição.  Para uma sequência definida recursivamente, podemos usar a indução para provar proposições que façam uso dela.  Para um conjunto, primeiro definimos os elementos iniciais e depois fornecemos uma regra para construção de novos elementos. Para demonstrações com conjuntos recursivos, usamos um método de prova chamado indução estrutural.  Para uma função, primeiro definimos o passo básico e depois uma rega para encontrar o valor da função no seu domínio definido. Um exemplo famoso disso são os número de Fibonacci onde temos f0=0,f1=1f_0 = 0, f_1 = 1f0​=0,f1​=1 e fn=fn−1+fn−2∀n=2,3,4,…f_n = f_{n-1} + f_{n-2} \\forall n = 2,3,4,\\dotsfn​=fn−1​+fn−2​∀n=2,3,4,….  Existe uma relação entre a recursão e a indução pois, geralmente, objetos construídos recursivamente são demonstrados por meio de indução matemática.  ","version":"Next","tagName":"h3"},{"title":"Especificação de Sistemas​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#especificação-de-sistemas","content":" A especificação de sistemas é a capacidade de traduzir linguagem natural para linguagem lógica.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Lógica Computacional","url":"/CC_site/docs/puc/primeiro-periodo/logica-computacional#bibliografia","content":" HUNTER, David J. Fundamentos de Matemática Discreta. Rio de Janeiro: LTC, 2011ROSEN, Keneth H. Discrete Mathematics and its Applications. New York: McGraw-Hill, 2019 ","version":"Next","tagName":"h2"},{"title":"Compliance em TI","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/quinto-periodo/compliance","content":"","keywords":"","version":"Next"},{"title":"Fundamentação Teórica​","type":1,"pageTitle":"Compliance em TI","url":"/CC_site/docs/puc/quinto-periodo/compliance#fundamentação-teórica","content":" ","version":"Next","tagName":"h2"},{"title":"Conceitos​","type":1,"pageTitle":"Compliance em TI","url":"/CC_site/docs/puc/quinto-periodo/compliance#conceitos","content":" Compliance e Sua Importância​  ","version":"Next","tagName":"h3"},{"title":"Governança de TI e Compliance​","type":1,"pageTitle":"Compliance em TI","url":"/CC_site/docs/puc/quinto-periodo/compliance#governança-de-ti-e-compliance","content":" Governança de TI​  Relação entre Governança e Compliance​  ","version":"Next","tagName":"h3"},{"title":"Compliance na Prática​","type":1,"pageTitle":"Compliance em TI","url":"/CC_site/docs/puc/quinto-periodo/compliance#compliance-na-prática","content":" ","version":"Next","tagName":"h2"},{"title":"Legislação​","type":1,"pageTitle":"Compliance em TI","url":"/CC_site/docs/puc/quinto-periodo/compliance#legislação","content":" LGPD - Lei Geral de Proteção de Dados​  Benefícios da LGPD​ ","version":"Next","tagName":"h3"},{"title":"Implantação de Soluções em TI","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/quinto-periodo/implantacao","content":"","keywords":"","version":"Next"},{"title":"Integração Contínua e Construção Automatizada​","type":1,"pageTitle":"Implantação de Soluções em TI","url":"/CC_site/docs/puc/quinto-periodo/implantacao#integração-contínua-e-construção-automatizada","content":" ","version":"Next","tagName":"h2"},{"title":"Cultura DevOps​","type":1,"pageTitle":"Implantação de Soluções em TI","url":"/CC_site/docs/puc/quinto-periodo/implantacao#cultura-devops","content":" ","version":"Next","tagName":"h3"},{"title":"Gerenciamento de Configuração​","type":1,"pageTitle":"Implantação de Soluções em TI","url":"/CC_site/docs/puc/quinto-periodo/implantacao#gerenciamento-de-configuração","content":" Gerência de Configuração​  Sistema de Controle de Versão​  Integração Contínua​  Gerenciamento Ágil de Mudanças​  Gerenciamento de Releases​  ","version":"Next","tagName":"h3"},{"title":"Implantação e Manutenção de Software​","type":1,"pageTitle":"Implantação de Soluções em TI","url":"/CC_site/docs/puc/quinto-periodo/implantacao#implantação-e-manutenção-de-software","content":" ","version":"Next","tagName":"h2"},{"title":"Testes​","type":1,"pageTitle":"Implantação de Soluções em TI","url":"/CC_site/docs/puc/quinto-periodo/implantacao#testes","content":" Testes de Integração​  ","version":"Next","tagName":"h3"},{"title":"Implantação de Software​","type":1,"pageTitle":"Implantação de Soluções em TI","url":"/CC_site/docs/puc/quinto-periodo/implantacao#implantação-de-software","content":" Empacotamento​  Implantação​  ","version":"Next","tagName":"h3"},{"title":"Manutenção de Software​","type":1,"pageTitle":"Implantação de Soluções em TI","url":"/CC_site/docs/puc/quinto-periodo/implantacao#manutenção-de-software","content":" Evolução e Manutenção​  Refatoração de Código​ ","version":"Next","tagName":"h3"},{"title":"Organização de Computadores","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores","content":"","keywords":"","version":"Next"},{"title":"Fundamentos de Organização de Computadores​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#fundamentos-de-organização-de-computadores","content":" ","version":"Next","tagName":"h2"},{"title":"Representação de Dados e Sistemas Binário​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#representação-de-dados-e-sistemas-binário","content":" Compreendendo o Sistema Decimal​  Os componentes eletrônicos digitais só permitem dois estados de tensão: 0 e 1. Isso implica que toda informação manipulada pelos computadores é representado em um sistema de numeração binária que é correlacionada com o nível de tensão nos componentes da máquina.  O nosso modelo de sistema numérico usual é o decimal (também chamado base 10). Ele é um sistema posicional porque o peso do dígito é dependente da posição dele no número. Por exemplo:  3810=3×101+8×100=30+838_{10} = 3 \\times 10^1 + 8 \\times 10^0 = 30 + 83810​=3×101+8×100=30+8  17,2510=10×101+7×100+2×10−1+5×10−217,25_{10} = 10 \\times 10^1 + 7 \\times 10^0 + 2 \\times 10^{-1} + 5 \\times 10^{-2}17,2510​=10×101+7×100+2×10−1+5×10−2  O subscrito indica o tipo de base usado. Uma característica dos sistemas posicionais é que o dígito mais a esquerda será o mais significativa (MSB - Most Significant Bit) e os à sua direita serão os LSB (Less Significant Bit).  ","version":"Next","tagName":"h3"},{"title":"Conceitos de Lógica Digital​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#conceitos-de-lógica-digital","content":" Computadores são formados por componentes eletrônicos. Os transistores e os diodos são usados para a construção das portas lógicas que nos permitem, através de circuitos elétricos, replicar os operadores lógicos da lógica usados na algebra booleana. Assumindo valores em dois estágios: 0 (de 0 a 0,6 volts) e 1 (entre 3,6 e 5 volts).  Uma porta lógica nada mais é que um circuito que recebe sinais de entrada e, conforme a sua configuração, produz um sinal de saída cujo valor é dependente da entrada.  Podemos categorizar as portas lógicas em 3 grupos:  Portas Lógicas Básicas Operação Lógica - AND Operação Lógica - OR Operação Inversora - NOT Funções e Portas Lógicas Compostas Operação Lógica - NAND (NOT-AND) Operação Lógica - NOR (NOT-OR) Operação Lógica - XOR (OR-EXCLUSIVA) Expressões Lógicas e Circuitos Digitais  Eu já trabalhei bem a fundo a lógica matemática no meu curso do Projeto Matemática. Você pode conferir no capítulo 02 nesse link. A única diferença é que quando lá for TRUE ou VERDADE, aqui será 1 e, claramente, quando lá for FALSE ou FALSO, aqui será 0.  Como nosso estudo nesse manual é mais focado em Análise e Desenvolvimento de Sistemas, vamos manter as anotações referentes à transposição da algebra booleana para os circuitos eletrônicos. Mas caso haja alguma dúvida, a leitura do material acima é recomendada.  Operadores Básicos​        Operadores Compostos​        Expressões Lógicas e Circuitos​  Podemos usar os operadores lógicos para criar expressões do tipo Y=(A+B).CY = (A+B).CY=(A+B).C que pode ser lida como &quot;Y é igual a (A ou B) e C&quot;1. Podemos também usar os diagramas de circuitos para representar exatamente essa mesma opração lógica.    Para entender como cada input produz um resultado é necessário usarmos uma tabela verdade que nos mostra todos os casos entre os inputs e os outputs.  Desafio: Vamos olhar a tabela verdade abaixo:​  A\tB\tC\tY0\t0\t0\t1 0\t0\t1\t1 0\t1\t0\t1 0\t1\t1\t1 1\t0\t0\t1 1\t0\t1\t1 1\t1\t0\t1 1\t1\t1\t0  Qual função lógica produz o resultado compatível para a coluna Y? A resposta está na observação cuidadosa dos valores. Podemos ver que sempre que tivermos algum valor 0 como input, o resultado será 1. Como existe essa alternância, podemos ver que o operador de negação está sendo usado. Além disso, se tivéssemos o operador &quot;ou&quot; aliado a um operador de negação, na linha (0,0,1)(0,0,1)(0,0,1) teríamos o resultado 1 que, ao ser negado, retornaria um resultado 0.  Portanto, só nos resta acreditar que temos uma situação de operações do tipo &quot;e&quot; e de negação. A essa estrutura damos o nome de &quot;NOT-AND&quot; ou &quot;NAND&quot;. Em temos lógicos formais, temos a expressão ¬(A∧B∧C)\\neg (A \\land B \\land C)¬(A∧B∧C) e na notação que usamos no curso, temos um (A.B.C)‾\\overline{(A . B . C)}(A.B.C)​.  ","version":"Next","tagName":"h3"},{"title":"Circuitos Lógicos Digitais Básicos​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#circuitos-lógicos-digitais-básicos","content":" Com o uso das portas lógicas, nós podemos construir circuitos mais complexos e que desempenham funções importantes para o funcionamento de um computador. Podemos agrupar esses circuitos (também chamados de módulos) em dois grupos:  Circuitos Lógicos Combinacionais MultiplexadoresDemultiplexadoresCodificadoresDecodificadores Circuitos Sequenciais RegistradoresContadores  Circuitos Combinacionais​  Os circuitos combinacionais são construídos de maneira que o resultado obtido por ele é condiconado ao input atual nas portas lógicas que o compões. Para analizarmos um circuito composto de nnn portas lógicas e mmm saídas, podemos usar a tabela verdade, símbolos gráficos no padrão das portas que aprendemos antes e equações booleanas que convertem a lógica eletrônica para a matemática.  Observemos a tabela verdade abaixo:  A\tB\tC\tF0\t0\t0\t0 0\t0\t1\t0 0\t1\t0\t1 0\t1\t1\t1 1\t0\t0\t0 1\t0\t1\t0 1\t1\t0\t1 1\t1\t1\t0  Para criar a representação do circuito lógico que corresponde a coluna F, basta observarmos as condições necessárias para o valor 1 na referida coluna. Temos 3 eventos em que isso acontece. Podemos demonstrar essa relação pode meio da seguinte equação boolena:F=A‾BC‾+A‾BC+ABC‾F = \\overline{A} B \\overline{C} + \\overline{A} B C + A B \\overline{C}F=ABC+ABC+ABC  A essa primeira maneira de escrita, damos o nome de Soma de Produtos ou Sum Of Products (SOP).  Uma outra forma de representarmos o circuito F é se focarmos na negativa das condições que retornam o valor 0. Desse modo, também podemos representar o circuito da seguite maneira:F=ABC‾‾.AB‾C‾.ABC‾‾.AB‾C‾.ABC‾F = \\overline{\\overline{A B C}} . \\overline{\\overline{A B} C} . \\overline{A \\overline{B C}} . \\overline{A \\overline{B} C} . \\overline{A B C}F=ABC.ABC.ABC.ABC.ABC  Podemos visualizar essa condição no diagrama abaixo.    Ao aplicarmos o teorema de DeMorgan (X1.X2‾)=X1‾+X2‾(\\overline{X1 . X2}) = \\overline{X1} + \\overline{X2}(X1.X2)=X1+X2 nessa segunda versão podemos desenvolve-la até chegarmos em uma terceira configuração:F=(A+B+C).(A+B+C‾).(A‾+B+C).(A‾+B+C‾).(A‾+B‾+C‾)F = (A + B + C) . (A + B + \\overline{C}) . (\\overline{A} + B + C) . (\\overline{A} + B + \\overline{C}) . (\\overline{A} + \\overline{B} + \\overline{C})F=(A+B+C).(A+B+C).(A+B+C).(A+B+C).(A+B+C)Que chamamos de Produto das Somas ou Product of Sums (POS).  Comentário O material do microfundamento é consideravelmente reduzido nessa parte. Mas como estou perto da prova enquanto escrevo essa parte, terei que, por agora, reduzir a profundidade e seguir como é dado pelo material da aula. Em tempo oportuno eu volto aqui e expando essa seção.  Agora que entendemos um pouco melhor sobre cisrcuitos lógicos combinacionais, vamos aprender mais sobre alguns circuitos desse tipo.  Os multiplexadores são circuitos combinacioinais que selecionam nnn entradas a uma única saída por meio de suas linhas de seleção. Para cada duas entradas, serão necessárias 1 linha de seleção. Os demultiplexadores são o oposto, ligando uma única entrada para nnn saídas.  Um codificador normalmente só permite que uma das entradas esteja ativa a cada instante e sua função é converter os valores de entrada em um número binário. Similarmente, um decodificador recebe um binário como entrada e a saída será alguma linha previamente definida.  Circuitos Sequenciais​  Por outro lado, os circuitos sequenciais usam elementos armazenadores chamados latches e flip-flops e possuem a capacidade de armazenamento de informações.  Um latch é um circuito capaz de armazenar o valor de 1 bit e pode ser construído com 2 portas NOR ou NAND como na imagem abaixo.    A entrada S é chamada de Set e atribui um valor ao sistema. A porta R é chamada de Reset e retorna o valor 0 para o nosso circuito. Se ambos são 0, o nosso sistema retorna um status inalterado memorizando o estado anterior.  Com o latch podemos usar o controle de tempo (chamado de clock) para controlarmos o comportamento oscilante de alguns circuitos sequenciais mais complexos.  Os circuitos sequenciais são criados com o uso dos latchs e sinais de controle por clock. São muito relevantes para os computadores pois permitem a capacidade de memorização de informação na memória de trabalho. Aqui, não estamos falando dos discos rígidos ou memória flash.  Existem dois tipos de circuitos sequenciais muito importantes para a estrutura dos computadores modernos. O primeiro deles é o registradores que são usados para memorizar temporariamente informações em memória maiores que 1 bit (as de 1 bit podem ser armazenadas diretamente pelo latch). Os contadores usam o clock para a contagem da passagem do tempo.  ","version":"Next","tagName":"h3"},{"title":"Introdução à Organização de Computadores​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#introdução-à-organização-de-computadores","content":" A medida que os computadores foram evoluindo, a representação das suas partes por meio das portas digitais se tornou inviável devido ao número exponencial de portas que faziam parte de cada nova geração de computadores.  Desse modo, a representação por meio da hierarquia de subsistemas se tornou mais adequada. O objetivo é conseguirmos compreender como cada subsistema se interliga com os demais e desempenha funções específicas para o correto funcionamento do equipamento.  Para prosseguirmos, é necessário definirmos o que seria esse &quot;correto funcionamento&quot; dos computadores. Em suma, podemos afirmar que um computador deve realizar 4 funções:  Processamento de Dados - Produzir nova informação a partir de informação anteriorArmazenamento de Dados - Capacidade de memorizar tanto no prazo de trabalho quanto no longo prazoTransferência de Dados - Envio das informações por meio dos dispositivos de entrada e saídaControle - Para a garantia das 3 funções acima  Para realizar esses trabalhos, podemos dividir o computador moderno nos seguintes subsistemas:  Unidade Central de Processamento (CPU) - Que faz o controle de toda a operação do computadorMemória Principal - Conectada por meio de um barramento ao CPU, armazena os dados necessários para o CPU realizar as operações desejadasEntrada e Saída de Dados - São os elementos que inputam informações ao CPU e retiram dele os resultados para o mundo exteriorBarramento - Meio físico de comunicação entre os subsistemas do computador  Organização x Arquitetura​  Embora esses conceitos sejam muito parecidos. Podemos definir a organização de computadores como a descrição de computadores por meio dos seus subsistemas, suas funções e interconexões. Por sua vez, a arquitetura de computadores está relacionada à conexão entre o projeto de computador e a execução dos programas, ou seja, é o estudo de como uma mudança no design de um computador impacta na execução dos programas.  Uma mesma arquitetura pode ser implementada em várias organizações possíveis. A arquitetura tem foco na abstração do computador e a organização tem foco na implementação.  Para facilitar a diferenciação dos termos, vamos elencar alguns tópicos de estudo dessas áreas.  Organização de Computadores Implementação de hardwareImplementação de sistemas de controle que transmitem a execução das instruçõesComunicação entre o computador e seus periféricosTecnologia usada pra a memória Arquitetura de Computadores Conjunto de instruções que a CPU processaO formato das instruçõesManeiras de endereçamento de memóriaRepresentação dos tipos de dados usados nas instruções  Organização Básica de um Computador Digital - Modelo de Von Neumann​  Antigamente, os programas executados pelos computadores eram feitos por meio do arranjo físico dos seus componentes. A programação era feita diretamente no hardware. contudo, uma nova arquitetura foi necessária porque se buscava a construção de um mecanismo que permitisse, ao mesmo tempo, o salvamento tanto dos dados quanto das instruções necessárias para o processamento dos mesmo.  Foi nesse contexto que a arquitetura de Von Neumann foi construída. Ela é constituída de, basicamente, 3 componentes principais interligados por um barramento:  CPUMemória PrincipalDispositivos de Entrada e saída  ","version":"Next","tagName":"h3"},{"title":"Unidade Central de Processamento - UCP​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#unidade-central-de-processamento---ucp","content":" Na seção passada, nós vimos que a arquitetura de Von Neumann possui o CPU (também chamado de processador) como um dos seus componentes. Durante um ciclo de execução, o processador deve buscar as instruções na memória, decodificá-la e executá-la. Para entender melhor como ele faz tudo isso, podemos subdividi-lo nas seguintes partes:  Unidade de Controle - É quem faz a busca na memória e permite a execução das instruções (programas)Unidade Lógica e Aritmética (ULA) - Executa as instruções enviadas pela unidade de controle referentes às operações lógicas e aritméticasRegistradores - São componentes de memória de extrema velocidade de leitura mas baixa disponibilidade. Essa memória é usada temporariamente para auxiliar o ciclo de execução  Ciclo de Execução de Instruções​  As instruções sempre são executadas sequencialmente. Quem controle o fluxo de qual instrução será executada a cada ciclo é um registrador chamado controlador de programas (PC). Ele armazena o endereço da próxima instrução a ser executada e, a cada ciclo, é reescrito com o novo endereço de execução.  O ciclo de execução é composto seguintes etapas:  Busca da próxima execução - O PC indica o endereço na memória da instrução a ser executada. Esse endereço é carregado em outro registrador chamado registrador de instruções (RI) e então o PC recebe o endereço da próxima instruçãoDecodificação da instrução - o endereço armazenado no RI (também chamado de opcode) é lido pela unidade de controle e o comando à ULA é feito para execução da instruçãoBusca dos operandos - A unidade de controle busca todos os dados necessários à execução da instrução por meio do envio de sinais através do barramento2Execução da Instrução - A ULA, de posse dos dados, faz a execução da instrução lendo os operandos carregados em memória pela unidade de controleRepetição do processo  ","version":"Next","tagName":"h3"},{"title":"Memória​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#memória","content":" Idealmente, a memória deveria ser super rápida e abundante. O problema é que existe um trade-off entre essas duas qualidades. Quanto mais rápida é a leitura, mais cara é a memória. Esse é o motivo de, na arquitetura dos computadores atuais, existirem diversos tipos de memória.  A ordem de velocidade é dada por:  RegistradoresMemoria CacheMemoria PrincipalMemoria Secundária  As primeiras são as memórias mais rápidas e caras. As demais, estão as mais lentas e baratas.  A memória principal é a memória RAM e ROM dos nossos computadores. Dela, a CPU lê as instruções escritas em alguma linguagem de programação e é nela que o processador salva o resultado das operações.  Para entender como a memória principal e funciona, basta pensarmos em um conjunto de pequenas células (posições) de armazenamento de informação. Todas as células da memória possuem o mesmo tamanho (medido em quantidade de bits). Os endereços são os identificadores da posição física de cada célula no material de armazenamento (disco magnético ou chip).  Se soubermos a quantidade de bits em cada célula e a quantidade de células, saberemos a capacidade de armazenamento do dispositivo por meio do cálculo  Capacidade=2Numero de Celulas∗Numero de bits por celula\\textrm{Capacidade} = 2^{ \\textrm{Numero de Celulas}} * \\textrm{Numero de bits por celula}Capacidade=2Numero de Celulas∗Numero de bits por celula  A memória principal pode ser divida em memória RAM - Random Access Memory, que pode ser lida e apagada a qualquer momento mas não é capaz de armazenar os dados após o desligamento do computador, e a memória ROM - Read Only Memory que não pode ser alterada na execução do programa mas se mantém após o desligamento do computador.  Comentário A memória RAM ainda é subdividida em outras memórias mas veremos isso em uma atualização desse curso.  A memória secundária é o HD e o SSD dos nossos computadores. O processador só faz uso dela por meio de dispositivos de entrada e saída. A vantagem dela é o seu preço que é infinitamente menor que as memórias mais rápidas.  ","version":"Next","tagName":"h3"},{"title":"Entrada e Saída​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#entrada-e-saída","content":" São os componentes que permitem os usuários acessar e visualizar os resultados dos ciclos de processamento.  E/S de entrada - Teclado, Mouse, Scanner ...E/S de saída - Impressoras, Monitores, Caixas de Som ...Interface de E/S - São os programas que intermediam a comunicação entre o CPU e o dispositivos  Existem alguns tipos de comunicações entre os dispositivos de Entrada e Saída mas nós vamos parar por aqui.  ","version":"Next","tagName":"h3"},{"title":"Arquitetura de Computadores​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#arquitetura-de-computadores","content":" ","version":"Next","tagName":"h2"},{"title":"Arquiteturas RISC e CISC​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#arquiteturas-risc-e-cisc","content":" Como o processador exerce um papel central na atividade de um computador moderno, não é nada estranho se preocupar muito sobre como ele é capaz de compreender as instruções e executar. Na verdade, existe um campo específico de pesquisa chamado arquitetura de instruções do processador.  Esse campo estuda o formato das instruções, os códigos de operação, os registradores, a memória de dados e outros tópicos relacionados a atividade desse componente.  Na primeira geração de processadores, o conjunto de operações era reduzido para simplificação da construção desse componente. Na década de 60, a quantidade de operações aumentou junto com a complexidade dos processadores. A essa família dá-se o nome de CISC - Complex Instruction Set Computer.  Os computadores da família CISC possuem uma maior quantidade de instruções, contudo, o seu ciclo de processamento é mais lento. O exemplo dessa família de processadores é a Intel: 286, 386, 486 e Pentium.  No final da década de 80, os processadores com um conjunto reduzido de instruções voltaram a serem utilizados sob o nome de RISC - Reduced Instruction Set Computer. A ideia era a de melhorar o desempenho dos processadores via simplificação e ganho de velocidade. Os exemplos são os processadores MIPS e a arquitetura ARM (muito usados nos smartphones).  Hoje em dia os processadores possuem ambas as abordagens implementadas simultaneamente.  ","version":"Next","tagName":"h3"},{"title":"Arquitetura do Conjunto de Instruções: Exemplo do MIPS​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#arquitetura-do-conjunto-de-instruções-exemplo-do-mips","content":" No tópico anterior, nosso foco foi na história dos desenhos físicos dos processadores. Agora, nossa atenção será voltada para a arquitetura das instruções, ou seja, as operações nativas que os processadores já vem de fábrica capazes de fazer.  Diferente da arquitetura física, o mercado acabou por convergir para um padrão relativamente comum de arquitetura de instruções básicas. Como exemplo, o material cita o Microprocessor Without Interlocked Pipeline Stages - MIPS.  Desenvolvido na década de 80, o MIPS foi implementado mesmo antes da RISC ser criada. Hoje em dia, podemo encontrar essa arquitetura de opareções em equipamentos da Cisco, Nintendo, Toshiba, Sony e etc.  A arquitetura do conjunto de instruções define os tipos de instruções executáveis pelo processador, o formato de cada instrução, o tamanho em bits delas, o métodos de endereçamento e outras taregas importantes para o funcionamento desse componente.  Podemos elencar algumas classes de instruções que o MIPS 32 bits é capaz de executar:  Operações AritméticasOperações LógicasTransferência de DadosDesvios CondicionaisDesvios Incondicionais  ","version":"Next","tagName":"h3"},{"title":"Linguagem de Montagem​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#linguagem-de-montagem","content":" Já sabemos que o processador só trabalha com número em binário, entretanto, também sabemos que os programas são escritos em linguagens de programação que não são, definitivamente, escritas em binário. Existe uma linguagem que está mais próxima do binário mas ao mesmo tempo pode ser lida (com a devida prática do leitor) e escrita para construção de programas. Essa linguagem é a linguagem assembly ou de montagem.  Em assembly, cada instrução é definida por um mnemônico (ADD, SUB, LW, SW, ...) que indica um operador nativo do processador. Cada instrução dessa possui um correspondente em binário do lado do processador de modo que é possível converter de um para o outro por um programa chamado assembler ou montador. No MIPS, cada instrução assembly é convertida em um binário de 32 bits no formato RIJ.  O assembly contém um conjunto de classes de instruções que, a primeira vista, se parecem muito com qualquer linguagem de alto nível:  Instruções Aritméticas add $t1, $t2, $t3 é igual a t1 = t2 + t3sub $t1, $t2, $t3 é igual a t1 = t2 - t3addi $t1, $t2, 10 é igual a t1 = t2 + 10 Instruções Lógicas and $s1, $s2, $t0 é igual a s1 = s2 AND t0or $s1, $s2, $t0 é igual a s1 = t2 OR t0 Instruções de Uso de Memória lw $t0, 0($s3) é igual a t0 receber valor de s3sw $t0, 0($s3) é igual a t0 é armazenado em s3 Instruções de Controle de Fluxo  # Codigo em C # Codigo em Assembly if (i == j) bne $s3, $s4, Else # vai pra else se s3 != s4 f = g + h; add $s0, $s1, $s2 # f=g+h else j Exit # salto para Exit f = h - h; Else: sub $s0, $s1, $s2 Exit:   Já conseguimos ver que em assembly é necessário mais linhas quando comparamos a uma linguagem de alto nível. Para finalizar, vamos comparar a declaração de uma função em C e em assembly.  // c # Construção da mesma função em C int func(int g, int h, int i, int j) { int f; f = (g+h) - (i+j); return f; } # Construção da mesma função em assembly func: add t0, a0, a1 # t0 recebe g + h add t1, a2, a3 # t1 recebe i + j sub s0, t0, t1 # s0 recebe t0 - t1 add v0, s0, zero # v0 recebe s0 + 0 jr ra # retorna o resultado   Dica: Caso, em algum momento da sua vida, você precise programar em assembly, uma boa dica é usar o simulador/IDE MARS - MIPS Assembler and Runtime Simulator. Disponível nesse link.  ","version":"Next","tagName":"h3"},{"title":"Conceito de Pipeline de Instruções​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#conceito-de-pipeline-de-instruções","content":" A essa altura, já compreendemos relativamente bem como um processador é capaz de trabalhar e como a ordem da execução das instruções é relevante para o trabalho dele. Entretanto, existem etapas de processamento que não são necessariamente encadeadas, ou seja, não dependem uma do resultado da outra. Diante dessa constatação, o conceito de pipeline surge como uma técnica de otimização que executa instruções simultaneamente parecido com uma linha de montagem industrial.  O pipeline pode ser pensando como uma &quot;trilha&quot; que o processador possui para trabalhar a cada ciclo de clock. Nos processadores modernos, temos várias linhas de trabalho simultâneo que podem ser usadas para paralelismo de tarefas.  Se pensarmos que, para cada instrução, o processador deve passar pelos 6 estágios abaixo:  FI - Fetch Instruction/Busca da InstruçãoDI - Decodificação da InstruçãoCO - Cálculo dos Endereços dos OperandosBO - Busca do OperandosEI - Execução da InstruçãoWO - Armazenamento do Operando Destino  A cada ciclo de clock, então, ao invés de termos um único programa sendo executado por uma linha de pipeline do processador, podemos separar esse programa em unidades menores independentes que executam, cada uma em uma linha própria, suas etapas paralelamente a cada ciclo de clock. Abaixo nós temos uma tabela demonstrando o ganho de tempo com o uso dessa técnica para duas instruções.  0\t1\t2\t3\t4\t5\t6\t7Instrução 1\tFI\tDI\tCO\tFO\tEI\tWO Instrução 2 FI\tDI\tCO\tFO\tEI\tWO  Podemos ver que as duas instruções estarão finalizadas em apenas 7 ciclos de clock. Sem o paralelismo, teríamos levado 12 ciclos para completar essas mesmas duas instruções.  ","version":"Next","tagName":"h3"},{"title":"Paralelismo em Nível de Instruções e Processadores​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#paralelismo-em-nível-de-instruções-e-processadores","content":" Existem dois tipos de paralelismo para obtenção de desempenho sem aumento do clock do processador:  Existem duas abordagens típicas para o paralelismo a nível de instrução: Superpipeline - Há uma quebra de estágios de pipeline em estágios menores que 1 clock mas. Um exemplo é o MIPS R4000 que é um RISC com Superpipeline.Superescalar - Múltiplas unidades funcionais independentes que executam mais de uma instrução por clock. É como se houvesse mais de um pipeline dentro do processador. Os intel x86 usam essa técnica.  Paralelismo a nível de processador  É feito pelo uso de vários processadores ao mesmo tempo. E existem duas classes de computadores com essa abordagem: Multiprocessadores - Sistema com mais de uma CPU que compartilham a memória principal por meio de um processo coordenado. Podem ser implementados por barramento único ou memórias locais. CPUs fortemente acompladas.Multicomputadores - Sistema com computadores interligados em rede com alguma topologia. O foco está na comunicação entre eles. Processadores fracamente acoplados.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Organização de Computadores","url":"/CC_site/docs/puc/primeiro-periodo/organizacao-computadores#bibliografia","content":" Bibliografia Básica  STALLINGS, William. Arquitetura e organização de computadores. 10. ed. São Paulo: Pearson, c2018. E-book. ISBN 9788543020532CORRÊA, Ana Grasielle Dionísio (Org.). Organização e arquitetura de computadores. São Paulo: Pearson, 2017. E-book. ISBN 9788543020327PATTERSON, David A. Organização e projeto de computadores a interface hardware/software. Rio de Janeiro, GEN LTC 2017. 1 recurso online. ISBN 9788595152908TANENBAUM, Andrew S.; AUSTIN, Todd. Organização estruturada de computadores. 6. ed. São Paulo, SP: Pearson Education do Brasil, 2013. E-book. ISBN 9788581435398MONTEIRO, Mário A. Introdução à organização de computadores. 5. ed. Rio de Janeiro: LTC - Livros Técnicos e Científicos, c2007. E-book. ISBN 978-85-216-1973-4    Footnotes​ Usando os símbolos lógicos mais clássicos, podemos escrever como Y:(A∨B)∧CY: (A \\lor B) \\land CY:(A∨B)∧C. ↩ Sempre que você está vendo uma tela de loading, é isso que está acontecendo no seu computador. ↩ ","version":"Next","tagName":"h2"},{"title":"Segurança no Desenvolvimento","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/quinto-periodo/seguranca","content":"","keywords":"","version":"Next"},{"title":"Gestão da Segurança da Informação​","type":1,"pageTitle":"Segurança no Desenvolvimento","url":"/CC_site/docs/puc/quinto-periodo/seguranca#gestão-da-segurança-da-informação","content":" ","version":"Next","tagName":"h2"},{"title":"Conceitos Básicos​","type":1,"pageTitle":"Segurança no Desenvolvimento","url":"/CC_site/docs/puc/quinto-periodo/seguranca#conceitos-básicos","content":" Muito bem. A essa altura do nosso estudo saímos do praticamente zero lá no primeiro período. Aprendemos a desenvolver interfaces frontend. A lógica de negócio e acesso ao banco de dados relacional e não relacional no backend. Aprendemos aplicações mobile. Também vimos aplicações distribuídas.  Caramba, quanta coisa! Entretanto, teve algo que sempre acompanhou a nossa caminhada mas que finalmente terá o seu devido lugar de foco. A Segurança as nossas aplicações finalmente será o objeto do nosso cuidado agora.  Enquanto os times de desenvolvimento se esforça para entregar todos os requisitos elicitados no backlog. Entretanto, o time de segurança também se esforça para entregar todos os requisitos elencados no backlog e, além disso, eles também se empenham em evitar que o sistema apresente comportamentos indesejados no que tange ao acesso as informações.  Requisitos da Segurança da Informação​  Para elicitar os requisitos relacionados à segurança, também temos algumas abordagens que podem ser úteis. O material cita as três principais fontes para requisitos dessa natureza:  Avaliação de riscos à organização relacionados aos objetivos da empresa.Requisitos legais, estatutos e regulamentos (aqui a LGPD veio com força total).Conjunto de princípios e práticas para o manuseio da informação que a empresa usa para apoiar suas operações.  Uma vez que tenhamos aprendido as fontes dos requisitos. Temos que entender quais propriedades esses itens devem receber para que a organização faça uso correto e pertinente das suas informações e, ao mesmo tempo, se proteja de vazamentos e intrusões.  Principais propriedades da segurança da informação:  Confidencialidade - Somente pessoas autorizadas devem ver certas informações.Integridade - A informação não deve ser alterada.Disponibilidade - Os sistemas devem estar disponíveis para a consulta.Garantia - As pessoas e sistemas devem se comportar como o esperado.Autenticidade - Garantia que os atos e fatos são gerados pela indicação da fonte.Anonimato (Privacidade) - Em alguns casos, deve-se assegurar que alguns fatos e atos não sejam rastreáveis.Auditabilidade - Registro dos acessos às informações.Legalidade - Conformidade com os regulamentos e normas.  Ameaças, Ataques e Vulnerabilidades​  ","version":"Next","tagName":"h3"},{"title":"Normas e Políticas​","type":1,"pageTitle":"Segurança no Desenvolvimento","url":"/CC_site/docs/puc/quinto-periodo/seguranca#normas-e-políticas","content":" Norma ISO/IEC 27001​  Políticas de Segurança da Informação​  ","version":"Next","tagName":"h3"},{"title":"Desenvolvimento Seguro de Software​","type":1,"pageTitle":"Segurança no Desenvolvimento","url":"/CC_site/docs/puc/quinto-periodo/seguranca#desenvolvimento-seguro-de-software","content":" ","version":"Next","tagName":"h2"},{"title":"Barreiras de Proteção​","type":1,"pageTitle":"Segurança no Desenvolvimento","url":"/CC_site/docs/puc/quinto-periodo/seguranca#barreiras-de-proteção","content":" Controle de Acesso e Permissões​  Segurança de Banco de Dados​  ","version":"Next","tagName":"h3"},{"title":"Software Seguro​","type":1,"pageTitle":"Segurança no Desenvolvimento","url":"/CC_site/docs/puc/quinto-periodo/seguranca#software-seguro","content":" Proteção Contra SQL Injection​  Proteção Contra Cross-Site Scripting (XSS)​  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Segurança no Desenvolvimento","url":"/CC_site/docs/puc/quinto-periodo/seguranca#bibliografia","content":" ","version":"Next","tagName":"h2"},{"title":"Básica​","type":1,"pageTitle":"Segurança no Desenvolvimento","url":"/CC_site/docs/puc/quinto-periodo/seguranca#básica","content":" BARRETO, Jeanine dos Santos et al. Fundamentos de segurança da informação. Porto Alegre: SAGAH, 2018. E-book.GOODRICH, Michael T.; TAMASSIA, Roberto. Introdução à segurança de computadores. Porto Alegre, RS: Bookman, 2013. E-book.HINTZBERGEN, Jule et al. Fundamentos de segurança da informação: com base na ISO 27001 e na ISO 27002. Rio de Janeiro: Brasport, 2018. E-book.HOGLUND, Greg; McGraw, Gary. Como Quebrar Códigos: a arte de explorar (e proteger) software.SILBERSCHATZ, Abraham; KORTH, Henry F.; SUDARSHAN, S. Sistema de banco de dados. 7. ed. Rio de Janeiro: LTC, 2020. E-book.TERADA, Routo. Segurança de dados: criptografia em redes de computador. 2. ed. rev. e ampl. São Paulo: Blucher, 2008. E-book.  ","version":"Next","tagName":"h3"},{"title":"Complementar​","type":1,"pageTitle":"Segurança no Desenvolvimento","url":"/CC_site/docs/puc/quinto-periodo/seguranca#complementar","content":" MUELLER, John. Segurança para Desenvolvedores Web. 1a. ed. 2018. E-book.BASTA, Alfred; BASTA, Nadine; BROWN, Mary. Segurança de computadores e teste de invasão. São Paulo: Cengage Learning, c2015. E-bookZEESHAN, Afzaal. DevSecOps for.NET Core/ Securing Modern Software Applications. 1st edition. 2020.HOWARD, Michael; LEBLANC, David; VIEGA, John. 24 Deadly Sins of Software Security/ Programming Flaws and How to Fix Them. 1st edition. 2009. ","version":"Next","tagName":"h3"},{"title":"Desenvolvimento Web Backend","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/segundo-periodo/desenvolvimento-web-backend","content":"","keywords":"","version":"Next"},{"title":"Comentário​","type":1,"pageTitle":"Desenvolvimento Web Backend","url":"/CC_site/docs/puc/segundo-periodo/desenvolvimento-web-backend#comentário","content":" Essa matéria tem uma abordagem muito prática. Desse modo, escrever um passo a passo detalhado de maneira escrita é a pior maneira de ensinar esse conhecimento por ser algo extremamente enfadonho tanto para mim (que estou escrevendo) quando para vocês que estarão lendo.  Dessa feita, eu vou criar um repositório no github dedicado para esse microfundamento onde cada commit será uma etapa do processo de desenvolvimento da aplicação. Aqui no material restará apenas a parte teórica e um resumo das transformações feitas ao longo do processo de desenvolvimento da aplicação.  Link do Repositório do Mini Projeto.  ","version":"Next","tagName":"h2"},{"title":"Arquitetura e Linguagens de Programação de Aplicações Web Back-End​","type":1,"pageTitle":"Desenvolvimento Web Backend","url":"/CC_site/docs/puc/segundo-periodo/desenvolvimento-web-backend#arquitetura-e-linguagens-de-programação-de-aplicações-web-back-end","content":" No nosso projeto de primeiro semestre, desenvolvemos uma aplicação web front-end. Como aprendemos até então, o front-end de uma aplicação é a parte da aplicação que tem foco na interface de interação com o usuário. Por outro lado, uma aplicação back-end tem foco nos serviços e tecnologias necessárias para atendimento das regras de negócio que a aplicação deve obedecer.  No back-end, temas como banco de dados, gerenciamento de rotas, sessão de usuário, cookies, segurança, templates e outros são relevantes e aprenderemos um pouco sobre cada um desses assuntos ao longo da nossa formação. Outro objetivo é o contato com as principais linguagens usadas para o desenvolvimento back-end assim como os principais frameworks para desenvolvimento de aplicações web.  Como a formação da PUC-MG é baseada no .NET, vamos aprender a usarmos o ASP.NET Core MVC para criação de aplicações web completas.  ","version":"Next","tagName":"h2"},{"title":"Arquitetura Back-End​","type":1,"pageTitle":"Desenvolvimento Web Backend","url":"/CC_site/docs/puc/segundo-periodo/desenvolvimento-web-backend#arquitetura-back-end","content":" Arquitetura de Software​  Durante o desenvolvimento de uma aplicação, é comum1 iniciarmos um projeto e irmos criando novas funções e módulos a medida que precisamos. Essa maneira de desenvolvimento recebe o apelido de bola de lama por sua representação visual de ligação entre as classes parecer uma &quot;bola&quot;.    Na norma ISO/IEC/IEEE 42010, temos a definição de Arquitetura de Software como sendo os &quot;conceitos ou propriedades fundamentais de um sistema em seu ambiente incorporados em seus elementos, relacionamentos e nos princípios de seu design e evolução&quot;. Dessa frase, podemos depreender que uma arquitetura de software é parte fundamental de um sistema. Esse sistema existe em um ambiente que é considerado pela arquitetura.  Em Clements e Kazman (2012) temos outra definição de arquitetura de software: &quot;A arquitetura de software de um programa ou sistema de computação é a estrutura ou estruturas do sistema, que compreendem elementos de software, as propriedades externamente visíveis desses elementos e as relações entre eles&quot;. Ou seja, a arquitetura de software é uma abstração de um sistema de software que serve de base para a construção do próprio sistema.  Ao elicitar os requisitos necessários para o atendimento de uma determinada demanda, o próximo passo é justamente definir as características arquitetônicas que comporão a solução de software. Desse modo, podemos ver que além da codificação e do design, uma solução de software também possui uma camada de arquitetura em sua construção.  Tal qual aprendemos nas boas práticas de desenvolvimento e design de aplicações, a arquitetura de software também possui atributos de qualidade para sua avaliação. Normalmente, podemos separar esses atributos em três grandes grupos:  Operacional DisponibilidadeDesempenhoRecuperabilidadeConfiabilidade\\SegurançaRobustezEscalabilidade Estrutural ConfigurabilidadeExtensibilidadeInstallabiltyLocalização\\TraduçãoCapacidade de ManutençãoPortabilidadeSuportabilidadeCapacidade de Atualização Transversal AcessibilidadeArquivabilidadeAutenticaçãoAutorizaçãoPrivacidadeSegurançaLegalUsabilidade\\Capacidade de Realização  Comentário Infelizmente, enquanto eu escrevo essa parte do material, estou com pouquíssimo tempo disponível para me aprofundar mais em alguns tópicos. Em tempo oportuno voltaremos a rever essas seções com a devida atenção que elas merecem.  Estilos Arquiteturais​  Já entendemos que, na construção de uma solução, precisaremos nos perguntar qual será o tipo de arquitetura de software que será usada para preencher todos os requisitos elicitados na etapa inicial de planejamento. Nessa seção, vamos ver os principais modelos\\estilos de arquiteturas de back-end usados hoje em dia.  Podemos agrupar alguns modelos segundo suas formas de organizar o sistema em componentes que interagem entre si. Entretanto, precisamos estar sempre cientes que essas divisões são apenas para fins didáticos. Na vida real, o mais comum é vermos várias características de modelos de arquiteturas integradas em uma mesma solução.  Arquitetura Monolítica  É o modelo de arquitetura baseado em um alto acoplamento onde o programa é projetado para funcionar como uma unidade única e independente. Esse modelo era mais utilizado nos primórdios do desenvolvimento quando não existia uma clara separação entre hardware e software. Hoje em dia, podemos ver um espelho desse tipo de arquitetura nos sistemas embarcados e em produtos de tecnologia que executam apenas uma aplicação.  Arquitetura Microkernel (Baseada em Plugins)  Esse tipo de arquitetura permite a inserção de extensões dinâmicas por meio de plugins. O melhor exemplo hoje em dia é o navegador que permite a instalação de extensões de terceiros para extender as funcionalidades dos navegadores. A vantagem é que esse tipo de arquitetura permite a extensibilidade de funcionalidades de modo mais simples quando comparamos com o modelo monolítico que demandaria a recompilação de toda a aplicação sempre que houver alguma mudança.  Arquitetura Pipes and Filters (Pipeline)  Esse modelo de construção é usado quando temos processos de tratamento de informações seriadas. Imaginemos que temos um arquivo a ser processado por um programa para gerar informações úteis para o usuário. Ao usarmos a arquitetura de pipeline, nós criamos uma série de etapas de processamento (chamadas de filters) que são independentes entre si e interconectadas pelos pipes que nada mais são que as ligações lógicas entre os filters onde o resultado de um filter é recebido como input do próximo filter por meio do pipe.  Arquitetura em Camadas (Layred)  Uma maneira de se evitar a complexidade gerada por alto acoplamento na arquitetura monolítica é a separação das funções do sistema em camadas que podem, ou não, se comunicar livremente entre si. A arquitetura web é a principal implementação desse tipo de arquitetura (camada de user, camada de api, camada de banco de dados e etc). Quando separamos um sistema em camadas, podemos definir a capacidade de cada em emitir e receber dados de modo a termos um controle da segurança dos dados e desempenho.  Comentário Na literatura, podemos achar o termo multi-tier que se refere a separação física entre as camadas e multi-layer que se refere a separação lógica.  Arquitetura Cliente/Servidor  É um tipo especial de arquitetura em camadas de duas camadas. É amplamente usada para soluções web onde trabalhamos as comunicações entre as camadas usando um protocolo de request/response. A principal dificuldade é a escalabilidade para páginas que possuem um grande volume de acessos que poderiam inviabilizar a resposta pelo servidor.  Arquitetura Peer-to-Peer  Esse é o mais novo tipo de arquitetura onde cada nó da rede é tido como simultaneamente um cliente e um servidor. É amplamente usado para escalabilidade de soluções e é um dos motores da chamada web 3.0. Como exemplo, temos os torrents e as blockchains usados para a criação e manutenção das criptomoedas.  Comentário Como dito no início, essas separações são apenas didáticas e não definitivas. Não existe arquitetura errada. Tudo depende do problema a ser resolvido.  Tipos de Aplicações Web​  Quando definimos que um dado problema será resolvido por meio de uma aplicação web. Temos que decidir a arquitetura dessa aplicação levando-se em conta coisas como: desempenho esperado, custos de servidor, segurança da informação e etc. Nessa seção vamos aprender sobre os principais modelos de construção de soluções web usadas na atualidade.  Multi-Page Application (MPA)  Tem como vantagens: a) Um melhor desempenho nos sistemas de pesquisa SEO pois as páginas são servidas com as metatags otimizadas para os mecanismos de busca; b) Um tempo de inicialização mais rápido devido o fato do processamento estar muito focado na camada do servidor que envia a página já renderizada para o client apenas mostrar para o user.  Tem como desvantagens: a) Uma experiência mais desagradável para o user que precisa ver a página inteira ser renderizada sempre que fizer uma solicitação de nova informação; b) Alto acoplamento entre front e back-end visto que o server precisa ter o controle das camadas de front-end para o processamento adequado do html a ser servido no client com alto controle sobre rotas.  Single Page Applicatoin (SPA)  Tem como vantagens: a) Uma única &quot;viagem&quot; de ida e volta ao server pois no primeiro acesso, os dados de visualização são baixados e salvos nos cookies do client evitando a dinâmica de ter que baixar todo o front-end em cada página nova o que melhora a experiência do usuário; b) Controle de rotas mais eficiente porque o novo conteúdo é renderizado dentro do mesmo arquivo html sem a necessidade de várias rotas novas; c) Como a quantidade de arquivos servidor é menor, também temos uma melhora no desempenho da aplicação a depender do SDK JS usado.  Tem como desvantagens: a) Uma piora nos mecanismos de pesquisa uma vez que o conteúdo das SPA é dinamicamente gerado de modo que os crawlers não conseguem tagear de maneira eficiente os sites que usam essa tecnologia; b) Tempo de carregamento inicial mais alto devido o fato de, no primeiro acesso, toda a carga de assets usados no front-end ser servida pelo server para o client.  Server-Side Rendered (SSR)  Com o advento do Node.js em 2009, o JS se tornou uma linguagem que pode ser usada tanto no front quanto no back-end2. Agora, podemos pensar em aplicações que atuam como um intermediário entre as abordagens SPA e MPA com o uso do JS isomórfico.  Tem como vantagens: a) Tempo de carregamento mais rápido; b) Melhor suporte de SEO e c) Melhor experiência do user pois a visualização se parece muito com o SPA.  Tem com desvantagens: a) A necessidade de um server em Node.js e b) Possui um desenvolvimento mais complexo com gestão de plugins e pacotes de terceiros que podem gerar muitos problemas em aplicações grandes.  Static Site Generators (SSG)  Uma outra abordagem é a de se gerar todas as páginas antecipadamente no server e envia-las todas de uma vez ao client no acesso ao site.  Tem como vantagens: a) Tempo de inicialização mais rápido porque o consumo é de páginas html estáticas; b) Otimizado para SEO; c) Implantação mais simples porque só lidamos com páginas html estáticas sem camada de servidor.  Tem como desvantagens: a) Falta de suporte no server side que impede qualquer processamento mais elaborado de dados e b) Sem renderização em tempo real que prejudica a customização da experiência de uso.  ","version":"Next","tagName":"h3"},{"title":"Projeto​","type":1,"pageTitle":"Desenvolvimento Web Backend","url":"/CC_site/docs/puc/segundo-periodo/desenvolvimento-web-backend#projeto","content":" Pois bem, agora vamos colocar a mão na massa.  Como o projeto é de Backend, vamos fazer um WEB API com ASP.NET Core usando como material a própria documentação no site da microsoft.  Também não vamos perder tempo desenvolvendo nada de interface. No final, vamos ter uma aplicação que recebe chamadas http via swagger3 e retorna um json.  Info Eu vou seguir um modelo de arquitetura chamado Controller-Based API mas o ASP.NET Core também permite a construção via Minimal API. Para entender melhor sobre esses estilos basta ler essa página4.  ","version":"Next","tagName":"h2"},{"title":"Requisitos​","type":1,"pageTitle":"Desenvolvimento Web Backend","url":"/CC_site/docs/puc/segundo-periodo/desenvolvimento-web-backend#requisitos","content":" Receber requisição HTTP GET/POST/PUT/DELETERetornar um JSON como resposta  ","version":"Next","tagName":"h3"},{"title":"Panorama do Desenvolvimento​","type":1,"pageTitle":"Desenvolvimento Web Backend","url":"/CC_site/docs/puc/segundo-periodo/desenvolvimento-web-backend#panorama-do-desenvolvimento","content":" Abaixo temos a lista dos commits usados no projeto. Em seguida eu explico o geral de cada commit, seu papel é abrir os links e ler os códigos.    Commit 1 - Update Git Ignore​  Nada de mais aqui, só colocando algumas coisas no git ignore pra gente não ter que ficar olhando pra arquivos desnecessários (faltou colocar o .db ai também).  Link do Commit 1  Commit 2 - Template padrão do ASP.NET Core​  Tirado da própria documentação do .NET, podemos ver que existem 3 tipos de runtime para executar aplicativos .NET. O ASP.NET Core é a parte para aplicações web mas além dele tem o Desktop e a parte de CLI.  Aqui nesse commit eu criei um app padrão só pra gente sentir a &quot;temperatura&quot;. Tem vários arquivos que são gerados automaticamente pelo Visual Studio 2022 mas eu deixei um comentário nos mais importantes.  Link do Commit 2  Commit 3 - Models, DataContext e InMemory Database​  Aqui nós pegamos o template do ASP.NET Core e começamos a criar nossa aplicação.  Primeiro, criamos o modelo da classe de item TO DO e também a classe que representa a conexão com o banco de dados.  Falando em banco de dados, nesse primeiro momento, vamos usar um banco alocado diretamente na memória RAM do computador, ou seja, desligando o app, perdemos todos os dados.  Link do Commit 3  Commit 4 - Scaffold do controller para To Do Item​  Nessa etapa a gente cria o controller da nossa aplicação usando uma automação chamada Scaffold onde só precisamos dizer a classe de datacontext e da tabela que o VS 2022 faz praticamente tudo no CRUD (o que significa que a gente tem que saber muito mais do que criar apenas CRUD).  Tem um monte de outros arquivos também mas só foca no que eu comentei.  Link do Commit 4  Rodando o projeto, podemos ver que agora temos os nossos endpoints no swagger.    Commit 5 - Database local parte 1 - Error​  Agora, queremos salvar as informações de maneira persistente. Para isso, vamos abandonar a estratégia de InMemoryDatabase para um banco de dados que é super simples chamado sqlite.  Documentação oficial    Link do Commit 5    Anteção Aprendam a ler logs de erro! Sério, um programador passa mais tempo lendo logs de erro e interpretando eles do que escrevendo código. Então vejam que eu apontei na stacktrace onde o nosso código quebrou. Vejam que tem um monte de coisa antes mas o que importa é saber onde no nosso código precisamos resolver.  Commit 6 - Database local parte 2 - Done​  Para resolver o problema eu tive que pesquisar no stackoverflow, macoratti e no chatgpt. Basicamente, ficaram faltando algumas libs e o appsettings.json tinha um erro porque eu coloquei a referência para o banco de dados dentro das chaves da parte de log.  Link do Commit 6  Commit 7 - Update no Database​  Esse último commit é só salvando os dados do teste que eu fiz com os dados persistindo no banco. Logo abaixo eu mostro a consulta no banco.    Conclusão​  Agora sabemos como criar um backend simples que pode ser consumido via chamadas nos endpoints da nossa API com controller. Ainda podemos evoluir muito mais nossa aplicação com segurança, camada de serviço, camada de domínio e etc.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Desenvolvimento Web Backend","url":"/CC_site/docs/puc/segundo-periodo/desenvolvimento-web-backend#bibliografia","content":" Ingeno, Joseph. Software Architect's Handbook. Packt Publishing, 2018.Lauret, Arnaud. Web Application Architecture: Principles, Protocols and Practices, 2nd Edition. Wiley. 2009.Lock, Andrew. ASP.NET Core in Action, Second Edition. Manning Publications. 2021Mead, Andrew. Learning Node.js Development. Packt Publishing. 2018.Tatroe, Kevin; MacIntyre, Peter. Programming PHP, 4th Edition. O'Reilly Media, Inc. 2020.FinTech. Web Application Architecture: Principles, Protocols and Practices, 2nd Edition. Wiley. 2009.Bass, Len; Clements, Paul; Kazman, Rick. Software Architecture in Practice, Third Edition. Addison-Wesley Professional, 2012.Kok, Lau Tiam. Hands-on Nuxt.js Web Development. Packt Publishing. 2020.Richards, Mark. Software Architecture Patterns. O'Reilly Media, Inc., 2015.Richards, Mark; Ford, Neal. Fundamentals of Software Architecture. O'Reilly Media, Inc., 2020.Sanctis, Valerio De. ASP.NET Core 2 and Angular 5. Packt Publishing. 2017.ASP.NET. Essential ASP.NET with Examples in C#. Addison-Wesley Professional. 2003Busuioc, Alexandru; Carr, David; Gray, Markus; Joshi, Vijay; McCollum, Mark; McLeod, Bart; Tonu, M A Hossain. The PHP Workshop. Packt Publishing. 2019.    Footnotes​ Principalmente para aqueles que aprendem a programar por conta própria. ↩ Chamamos essa característica de isomórfica. ↩ Pode ser feita via postman ou insomnia também. ↩ Já que você está começando. Vale a pena fazer os 2 modelos pra aprender. ↩ ","version":"Next","tagName":"h2"},{"title":"Algoritmo e Abstração de Dados","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao","content":"","keywords":"","version":"Next"},{"title":"Introdução​","type":1,"pageTitle":"Algoritmo e Abstração de Dados","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao#introdução","content":" Durante o processo de construção de software, a manipulação de informação em memória é tarefa fundamental para que a solução de software seja útil e satisfatória. As linguagens de programação possuem especificações sobre as características que cada grupo de variáveis pode ter, esse controle de propriedade das variáveis e das limitações relacionadas a cada tipo é chamado de Tipo de Dado.  Dizemos que um Tipo Abstrato de Dado (TAD) é a definição por parte do programador de uma nova classe de dado otimizada para a resolução do problema a ser trabalhado com o software em desenvolvimento. Contém tanto a estrutura da informação a ser trabalhada quanto as operações, procedimentos e funções que podem ser aplicadas a esse tipo de dado novo.  A construção de TADs passa pela identificação das entidades de um problema computacional e a definição e desenvolvimento do modelo de dados adequado para a solução proposta.  Primeiramente, vamos aprender sobre os tipos de dados normalmente existente nas linguagens de programação mais comuns do mercado. Podemos dividir os tipos de dados em dois grandes grupos: Homogêneos e Heterogêneos.  Comentário Esse microfundamento deve ser estudado somente após o microfundamento de Algoritmo e Lógica de Programação. Como esse material é de referência, ele não deve ser lido, necessariamente, como se fosse um livro.  ","version":"Next","tagName":"h2"},{"title":"Estrutura de Dados Homogêneas e Heterogêneas​","type":1,"pageTitle":"Algoritmo e Abstração de Dados","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao#estrutura-de-dados-homogêneas-e-heterogêneas","content":" ","version":"Next","tagName":"h2"},{"title":"Estrutura de Dados Homogêneas​","type":1,"pageTitle":"Algoritmo e Abstração de Dados","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao#estrutura-de-dados-homogêneas","content":" Os dois tipos de TAs Homogêneos mais comuns são os vetores (também chamados de arrays), que são formados por uma lista de nnn elementos de mesmo tipo e as matrizes, que podem ser entendidas como um empilhamento de vetores ou um tipo de vetor de duas dimensões.  Vetores​  É uma variável composta, homogênea e unidimensional. Podemos pensar em um vetor como uma lista com nnn elementos do mesmo tipo.  Como todos os valores de um vetor possuem o mesmo nome (o nome da variável), para acessarmos algum valor específico de um elemento, precisaremos de um índice que faça referência ao local na lista onde o valor desejado se encontra.  Para criarmos um vetor em c#, usamos a declaração da variável com um par de colchetes vazio e a definição da quantidade de posições (ou lugares) que o nosso vetor terá. Abaixo podemos ver um exemplo disso.  int[] Idades = new int[100]; // Vetor de int com 100 places double[] Alt = new double[20]; // Vetor de double com 20 string[] Nomes = new string[10]; // Vetor de string com 10   No exemplo acima, podemos ver que criamos um vetor denominado Idades que receberá apenas valores do tipo inteiro. Um vetor de doubles (que é um float com mais casas de precisão) chamado salario. E, por fim, um vetor de strings chamado Nomes.  Comentário Existe uma classe que permite a criação de um tipo de vetor genérico sem tamanho definido em c# chamado Lista. O curso não entrou nesse assunto mas eu vou deixar esse exemplo de lista aqui.  using System.Collections.Generic; List&lt;int&gt; lista = new List&lt;int&gt;(); List.add(1); List.add(2); List.remove(2);   Agora que sabemos como criar um vetor. O próximo passo é aprendermos como inserir informação nele. Para a nossa sorte, é bem simples. Basta colocarmos o nome do vetor seguido da posição a ser preenchida entre colchetes.  Idades[20] = 10; // Valor 10 na posição 19 Alt[0] = 1.2; // Valor 1.2 na posição 1   Só temos que ter cuidado com uma coisa. Existem linguagens (como C#, Java, Python e outras) que colocam o index da primeira posição de um vetor como sendo o valor 0. Outras linguagens (como R) usam o numero 1 para essa primeira posição.  Com base no que aprendemos em Algoritmos e Lógica da Programação, somos capazes de entender o código abaixo a respeito do uso de um laço de repetição para preenchimento de um vetor de 5 posições.  int i; int[] Valores = new int[5]; // Input dos dados for (i = 0; i &lt; 5; i++) { Console.WriteLine($&quot;Digite o valor {i + 1}: &quot;); Valores[i] = int.Parse(Console.ReadLine()); };   Desafio​  O professor propõe o seguinte desafio para fixação do conceito de vetor: &quot;Criaremos um vetor de números inteiros com 5 posições e ler cada um de seus valores. Criaremos duas funções que, tomando esse vetor como parâmetro, irão retornar a soma dos números pares contidos no vetor e a quantidade de números ímpares que ele possui.&quot;  Minha resolução desse problema segue abaixo.  int[] vetor = new int[5]; int somaPar = 0; int contaImpar = 0; int input; // Soma de dois valores int soma(int valor1, int valor2) { return valor1 + valor2; }; // Iteração para lançamento dos valores e somas for (int i = 0; i &lt; 5; i++) { Console.WriteLine($&quot; Valor da Posição nº: {i + 1}&quot;); input = int.Parse(Console.ReadLine()); vetor[i] = input; if (input % 2 == 0) { somaPar = soma(somaPar, input); } else { contaImpar += 1; } }; Console.WriteLine($&quot; SomaPar = {somaPar}, ContaImpar = {contaImpar}&quot;); Console.WriteLine($&quot;({vetor[0]},{vetor[1]},{vetor[2]},{ vetor[3]},{vetor[4]})&quot;);   Que produz o seguinte resultado para o input (1,2,1,2,1).    Matrizes​  Como dito no início dessa seção. Podemos pensar que matrizes são vetores de duas dimensões. Por causa disso, a declaração da variável é um pouco diferente.  double[,] Notas = new double[4,5]; // 4 linhas e 5 colunas   Por ser uma variável de duas dimensões, a maneira como atribuímos valores à cada posição é um pouco diferente do caso com vetor. Para cada atribuição de valor, temos que indicar a linha e coluna que nosso dado será salvo.  Notas[0,0] = 1; // Linha 1 coluna 1 Notas[0,1] = 1; // Linha 1 coluna 2 Notas[2,3] = 1; // Linha 3 coluna 4 Notas[3,4] = 1; // Linha 4 coluna 5   Devemos sempre lembrar que c# usa a posição de numeral 0 para o index inicial de vetores e matrizes.  Agora vamos ver um programa simples que exemplifica o que acabamos de aprender. A leitura dele não deve ser difícil. Se está tendo dificuldade, volte no microfundamento de lógica da programação.  int i, j; int[,] Valor = new int[10,3]; // Loop para entrada de valores na matriz for (i = 0; i &lt; 10; i++) // Loop para linhas { for (j = 0; j &lt; 3; j++) // Loop para colunas { Console.WriteLine($&quot;Valor Linha:{i+1} Coluna{j+1}&quot;); Valor[i,j] = int.Parse(Console.ReadLine()); } }   Desafio​  Para a fixação do conceito de matrizes, o professor faz o seguinte desafio: &quot;Vamos fazer um programa que irá ler os dados de uma matriz de inteiros de ordem 5, ou seja, de dimensões 5x5. Matematicamente ela é chama de matriz quadrada, porque o número de “linhas” é igual ao número de “colunas”. Depois de darmos entrada nos valores da matriz chamaremos uma função que, tomando essa matriz como parâmetro, retornará um vetor composto pelos elementos da diagonal principal dessa matriz quando, então, os listaremos.&quot;  // c# // Aqui vai ficar o cogido da solução do desafio // quando eu tiver vontade de fazer   Vetores e Matrizes são os principais tipos homogêneos de dados. A partir de agora, estudaremos estruturas que nos permitem alocar valores de tipos diferentes em uma mesma variável. A compreensão correta dos tipos de dados é a pedra fundamental do paradigma de desenvolvimento chamado de Programação Orientada à Objetos.  ","version":"Next","tagName":"h3"},{"title":"Estrutura de Dados Heterogêneas​","type":1,"pageTitle":"Algoritmo e Abstração de Dados","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao#estrutura-de-dados-heterogêneas","content":" Registros​  Na definição de um tipo de dado, nós definimos precisamente a faixa de valores que podem ser atribuídos e os métodos nativos do tipo de dado.  Chamamos de tipo simples de dados os grupos de valores do mesmo tipo (inteiros, reais, string ou booleanos). Por outro lado, chamamos de tipo estruturado de dados os modelos que comportam valores de tipagem diferentes na mesma variável.  Um registro é um tipo de dado estruturado.  Nós já estamos familiarizados com as definições de variáveis em c# para os tipos nativos de dados.  int x; double Result; string Name;   A essa altura do aprendizado, as linhas acima são simples de serem compreendidas. São apenas declarações do tipos de 3 variáveis simples. Mas vejam só o que podemos fazer abaixo.  Aluno xAlu;   Estranho, né?! Estamos declarando a variável xAlu como sendo do tipo...&quot;Aluno&quot;?  Sim, é isso mesmo!  Nós podemos usar um token dedicado na linguagem para a criação de tipos novos de dados que sirvam melhor para solução dos problemas que queremos resolver como nosso código.  O token dedicado para construção de tipos de dados em c# é o struct. Mas para usa-lo bem, temos que aprender os conceitos de tipos de dados heterogêneos e, no futuro, avançaremos para o conceito de classes.  O comando struct é pensado para o encapsulamento de pequenos conjuntos de variáveis relacionadas. No exemplo do tipo Aluno, podemos pensar que todos os alunos devem ter um nome, um cpf e uma data de nascimento, por exemplo. Como essas características se repetem para todos, podemos definir um tipo de dado específico para lidarmos com as informações dos alunos.  Implementação de um Registro​  A criação de um tipo de dado é simples. Basta definirmos o nome do tipo de dado e declararmos o conjunto de variáveis que farão parte dele. No exemplo abaixo, nós criamos o tipo &quot;Funcionário&quot; com as informações que serão usadas.  struct Funcionario { public string CPF; public string Name; public double Salary; public string dataNasc; }   Podemos ver que a declaração das variáveis dentro do bloco de código estão com o token public antes da declaração do tipo de dado. Isso ocorre porque precisamos dizer ao compilador da linguagem que essas variáveis serão acessíveis fora do bloco de código em que elas são criadas. Isso tem relação direta com o conceito de método e procedimento que aprendemos no curso de Algoritmo e Lógica Computacional.  Agora que temos o nosso novo tipo de dado criado, podemos usar esse recurso para a definição de novas variáveis.  static void Main(string[]) args) { Funcionario xFunc; xFunc.CPF = &quot;1234&quot;; xFunc.Name = &quot;Bruce Wanne&quot;; xFunc.Salary = 1234,33; xFunc.dataNasc = &quot;31/08/1993&quot;; }   Não precisamos nos preocupar com a primeira linha agora. Basta saber que todo programa em c# é um procedimento em algum nível. Podemos focar apenas no que está dentro dos colchetes.  Com o tipo de dado criado. Podemos criar a variável xFunc e acessar seus parâmetros usando um ponto após o seu nome. A atribuição é feita como antes mas agora não precisamos declarar os tipos porque eles estão definidos dentro do tipo de dado.  Já aprendemos no começo desse microfundamento que a criação de vetores (que são listas de elementos do mesmo tipo) são feitas em c# pela adição de colchetes vazios na declaração das variáveis. Por exemplo, um vetor de inteiros é definido por int[].  Pois bem, podemos usar a mesma lógica e criar um vetor do tipo que acabamos de criar1. Analogamente, como nosso tipo de dado é Funcionario, seu vetor que conterá vários funcionários diferentes será criado por Funcionario[].  Funcionario[] xFunc = new Funcionario[5]; for (int i = 0; i &lt; 5; i++) { Console.WriteLine(&quot;CPF do funcionário: &quot;); xFunc[i].CPF = Console.readLine(); Console.WriteLine(&quot;Nome do funcionário: &quot;); xFunc[i].Name = Console.readLine(); Console.WriteLine(&quot;Salário: &quot;); xFunc[i].Salary = Console.readLine(); Console.WriteLine(&quot;Data de Nascimento: &quot;); xFunc[i].dataNasc = Console.readLine(); }   Acima, temos a criação de um vetor de 5 posições onde cada elemento é do tipo Funcionario. Logo abaixo, temos um loop para facilitar o preenchimento das informações de cada elemento do vetor.  Estamos começando a nos aproximar do conceito de banco de dados. Mas não veremos isso agora.  Tipos de Dados Aninhados​  Não precisamos parar por aqui, é plenamente possível criarmos um tipo de dados que use outro tipo de dados criado fora dele. Por exemplo, ao invés de salvarmos a data de nascimento como uma string, podemos criar um tipo de dados chamado Data que recebe 3 informações: dia, mês e ano.  struct Funcionario { public string CPF; public string Name; public double Salary; public Data dataNasc; } struct Data { public string day; public string month; public string year; }   Dentro do tipo funcionário, temos a declaração de um variável do tipo data.  Para aproveitarmos o código de criação de um vetor Funcionario. Podemos fazer apenas uma pequena alteração.  Funcionario[] xFunc = new Funcionario[5]; for (int i = 0; i &lt; 5; i++) { Console.WriteLine(&quot;CPF do funcionário: &quot;); xFunc[i].CPF = Console.readLine(); Console.WriteLine(&quot;Nome do funcionário: &quot;); xFunc[i].Name = Console.readLine(); // Parte que foi substituída // Console.WriteLine(&quot;Salário: &quot;); // xFunc[i].Salary = Console.readLine(); Console.WriteLine(&quot;Data de Nascimento - Dia: &quot;); xFunc[i].dataNasc.day = Console.readLine(); Console.WriteLine(&quot;Data de Nascimento - Mês: &quot;); xFunc[i].dataNasc.month = Console.readLine(); Console.WriteLine(&quot;Data de Nascimento - Ano: &quot;); xFunc[i].dataNasc.year = Console.readLine(); }   A criação de tipos eficientes de dados é uma ferramenta muito eficiente para padronização e manutenção de soluções de software. É sempre bom entendermos bem o problema proposto e quais tipos de dados podem ser criados para a criação de uma resposta adequada a ele.  ","version":"Next","tagName":"h3"},{"title":"TAD, Classes e Implementação​","type":1,"pageTitle":"Algoritmo e Abstração de Dados","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao#tad-classes-e-implementação","content":" ","version":"Next","tagName":"h2"},{"title":"Definição de um TAD - Classes e Objetos​","type":1,"pageTitle":"Algoritmo e Abstração de Dados","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao#definição-de-um-tad---classes-e-objetos","content":" Um tipo abstrato de dado ou TAD é um &quot;padrão&quot; ou &quot;modelo&quot; que rege as características que determinada estrutura de dado criada bem como suas funções (que chamamos de métodos) internas. Ou seja, um TAD é a definição das informações contidas e as operações executáveis por uma variável de um determinado modelo.  Nós estamos usando isso o tempo todo sem perceber. Por exemplo, quando usamos a função Math.Pow(a,b) nós estamos, na verdade, executando um método chamamo Pow dentro do objeto Math. Exatamente o mesmo pensamento é aplicado ao Console.Write() ou Console.ReadLine().  Agora que estamos avançando mais no nosso conhecimento sobre desenvolvimento de software, começamos a entender mais sobre as estruturas que nos permitem realizar os nossos trabalhos, ou no jargão, estamos começando a ver &quot;de baixo do capô&quot;.  Até agora, nós temos definido os nossos TADs através da definição de sua estrutura (pelo token struct), mas as linguagens que utilizam o paradigma orientado à objeto atuais usam o conceito de classes para definição dos seus TADs.  Implementando TADs usando Classes​  Já aprendemos a implementar um TAD por estrutura.  // Definindo o TAD struct Produto { public string Nome; public double PrecoUnd; } // Criando uma variável com TAD Produto xProd; // Usando o TAD xProd.Nome = &quot;PS5&quot;; xProd.PrecoUnd = 8000.99;   Podemos construir uma solução análoga a essa pelo token de criação de classes.  // Definindo o TAD class Produto { public string Nome; public double PrecoUnd; } // Criando a classe Produto xProd = new Produto(); // Usando o TAD xProd.Nome = &quot;Xbox One&quot;; xProd.PrecoUnd = 9999.99;   Em uma primeira vista, parecem ser abordagens equivalentes. Mas existem algumas diferenças importantes que merecem a nossa atenção.  Para entender bem a diferença entre essas construções, vamos ter que aprender um pouco mais sobre como o computador guarda informações. O layout de memória de programas em C são separados em 5 níveis:  Text segment (instructions)Initializes data segmentUninitialized data segment (bss)HeapStack (Inline)  Nós não vamos nos atentar muito aos detalhes agora. Mas agora que sabemos um pouco das diferentes alocações possíveis na memória durante a execução de um programa. Podemos focar no que for necessário para diferenciarmos o struct do class.  Os valores do tipo struct são alocados na memória stack. Essa parte de memória grava temporariamente as variáveis criadas por uma função. No stack, as variáveis são declaras, guardadas e inicializadas durante a execução do programa e apagadas na sua conclusão. A memória é alocada em um bloco contíguos. É mais limitada e de rápido acesso.  Os valores do tipo class são alocados no heap. Essa é a parte da memória usada pelas linguagens de programação para suas variáveis de escopo global. A memória é alocada de maneira aleatória e é mais abundante se comparada com a stack. Sempre que criamos uma nova instância como fizemos em Produto xProd = new Produto() nós estamos apontando um novo endereço de memória para ser usado.  Desafio​  Cadastrar objetos em um vetor usando uma classe.  using System; namespace WorkSpace { // Criando o TAD do tipo class class carro { public string name; public string marca; public string anoFab; public string placa; public double precoFip; }; class Program { static void Main(string[] args) { // Criando um vetor do tipo carro carro[] cadCarro = new carro[3]; // Loop para inserir o input no vetor for (int i = 0; i &lt; 2; i++) { carro x = new carro(); Console.Write($&quot;\\n Qual o nome? &quot;); x.name = Console.ReadLine(); Console.Write($&quot; Qual a marca? &quot;); x.marca = Console.ReadLine(); Console.Write($&quot; Qual o ano de fabricação? &quot;); x.anoFab = Console.ReadLine(); Console.Write($&quot; Qual a placa? &quot;); x.placa = Console.ReadLine(); Console.Write($&quot; Qual o preço da tabela FIP? &quot;); x.precoFip = double.Parse(Console.ReadLine()); // Salvando o x no vetor cadCarro cadCarro[i] = x; }; Console.Clear(); // Mostrando o resultado foreach (carro C in cadCarro) { Console.WriteLine($&quot;\\n Carro: {C.name},Marca:{C.marca}&quot;); Console.WriteLine($&quot; Placa: {C.placa}, Ano:{C.anoFab}&quot;); Console.WriteLine($&quot; Preço da Tabela Fip: {C.precoFip}&quot;); }; Console.ReadKey(); } } }   É muito mais comum se achar situações de construção de TADs por uso de classes ao invés de estruturas. Vale a pena estudar mais para sabermos exatamente quando cada uma dessas opções é a adequada. Mas no começo, as classes nos servirão muito bem.  Aqui é importante frisarmos uma coisa. Quando instanciamos um objeto (ou seja, quando usamos o token new) o nome que passamos a esse objeto é apenas uma referência. Isso quer dizer que, no exemplo acima, cadCarro não é o nosso objeto em si e sim uma referência a ele.  Alguns de vocês podem estar questionando o motivo desse aviso. Sabendo que cadCarro não é o objeto em si e sim apenas uma referência que aponta para o endereço na memória em que o objeto está salvo, ao criarmos uma nova linha no nosso código do tipo cadCarro2 = cadCarro estamos criando uma nova referência para o mesmo objeto alocado na memória. Ou seja, qualquer manipulação feita usando a referência cadCarro também será refletida em cadCarro2.  Abaixo temos um programa simples que usa essa relação de referência.  using System; class Program { class carro { public string name; public string marca; public string anoFab; public string placa; public double precoFip; }; public static void Main(string[] args) { // Criando um vetor do tipo carro carro cadCarro = new carro(); carro cadCarro2 = null; cadCarro.name = &quot;carro Nome&quot;; cadCarro.marca = &quot;marca&quot;; cadCarro.anoFab = &quot;2022&quot;; cadCarro.placa = &quot;placa&quot;; cadCarro.precoFip = 22.22; Console.WriteLine($&quot;{cadCarro.name}&quot;); cadCarro2 = cadCarro; Console.WriteLine($&quot;{cadCarro2.name}&quot;); cadCarro2.name = &quot;carro nome 2&quot;; Console.WriteLine($&quot;{cadCarro.name}&quot;); } }   ","version":"Next","tagName":"h3"},{"title":"Atributos, Propriedades e Métodos de Classe​","type":1,"pageTitle":"Algoritmo e Abstração de Dados","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao#atributos-propriedades-e-métodos-de-classe","content":" Vamos analisar com calma essas duas citações do texto:  &quot;Uma classe especifica uma estrutura de dados e os seus métodos operacionais permissíveis que se aplicam a cada um dos seus objetos&quot; (MARTIN e ODELL, 1995).&quot;Um objeto é qualquer coisa, real ou abstrata, a respeito da qual armazenamos os dados e os métodos que os manipulam&quot; (MARTIN e ODELL, 1995).  Em ambas as citações temos as figuras dos dados e dos métodos. A estrutura dos dados nós já vimos na seção passada quando lidamos com definição de TADs declarando os tipos das variáveis tanto na declaração via estrutura quanto por classe.  Agora, vamos expandir um pouco mais o poder dos TADs nos permitindo definir, além das regras de quais dados serão armazenados, quais operações e funções serão executadas internamente por nossos objetos.  Ao construir um tipo abstrato de dados, nos perguntamos quais informações serão necessárias e, além disso, quais operações serão usadas para resolução do nosso problema.  Indo um pouco mais fundo​  Vejamos o seguinte TAD criado apenas com a definição da estrutura de dados:  class pessoa { public string name; public double salary; }   Dizemos que as informações sobre nome e salário são atributos do nosso objeto pessoa. Eles definem a estrutura do tipo abstrato de dados que definimos. Também podemos chama-los de variáveis da classe pessoa.  Mesmo que o exemplo acima funcione. Uma maneira mais apropriada de reconstruir essa solução pode ser vista abaixo.  class pessoa { private string _name; public string name { get {return _name;} set {_name = value;} } private double _salary; public double salary { get {return _salary;} set {_salary = value;} } }   Os campos _name e _salary são definidos com o escopo privado e podem ser acessados somente internamente ao objeto. Para podermos acessar fora do escopo do objeto, usamos as funções nativas get e set.  Os nomes das funções deixam claro o que cada uma faz. set é usado para atribuição de um valor passado (que chamamos de value) e get é usado para retorno de valor salvo no objeto.  Vamos ver um programa simples que utiliza esses conceitos.  namespace WorkSpace { class pessoa { private string _name; public string name { get {return _name;} set {_name = value;} } private double _salary; public double salary { get {return _salary;} set {_salary = value;} } }; class Program { static void Main(string[] args) { pessoa xpes = new pessoa(); xpes.name = &quot;Clark Kent&quot;; xpes.salary = 1234.56; Console.WriteLine($&quot;Nome: {xpes.name}&quot;); Console.WriteLine($&quot;Salário: R$ {xpes.salary}&quot;); } } }   Na linha xpes.name = &quot;Clark Kent&quot; vemos como a função interna set funciona. Ela recebe o valor e atribui à variável provada _name.  Quando definimos um atributo privado e funções (get e set) que manipulam esse atributo dentro da classe, podemos dizer que criamos uma propriedade do objeto.  Já temos os conceitos de objeto, atributo e propriedade bem definidos. Agora vamos aprender sobre as funções dentro de um objeto. A essas funções, damos o nome de métodos ou serviços do objeto.  class circulo { private double _raio; public double raio { get { return _raio; } set { _raio = value; } } public double calcArea() { return Math.PI * Math.Pow(_raio, 2); } }   Aqui temos um atributo chamado _raio. Uma propriedade chamada raio. E, por fim, temos também um método chamado calcArea. Abaixo temos um exemplo de como usar esses conceitos na prática.  namespace WorkSpace { class circulo { private double _raio; public double raio { get { return _raio; } set { _raio = value; } } public double calcArea() { return Math.PI * Math.Pow(_raio, 2); } } class Program { static void Main(string[] args) { double area; circulo xcirculo = new circulo(); xcirculo.raio = 2.5; area = xcirculo.calcArea(); Console.WriteLine($&quot;A área é igual a {area:F2}&quot;); Console.ReadKey(); } } }   Comentário Eu não sei você, mas eu fiquei com dúvidas sobre essa parte do area:F2. Isso é muito simples. Como o valor area é do tipo double, ele possui várias casas após a vírgula. Esse parâmetro é a definição da quantidade de casas após a vírgula. Nesse caso, o resultado terá 2 casas após a vírgula.  Quando encapsulamos as propriedades e os métodos dentro de um objeto, estamos omitindo os detalhes de como objeto faz as transformações e armazena os dados. A essa técnica damos o nome de ocultação da informação. Isso é útil para garantir a integridade da manipulação dos dados por parte dos usuários e aumenta a segurança quanto a lógica implementada no código.  Podemos definir a lógica também dentro das funções de set e get.  namespace WorkSpace { class circulo { private double _raio; public double raio { get { return _raio; } set { if (value &lt; 0) _raio = 0; else _raio = value; } } public double calcArea() { return Math.PI* Math.Pow(_raio, 2); } } class Program { static void Main(string[] args) { double area; circulo xcir = new circulo(); xcir.raio = -2.5; area = xcir.calcArea(); Console.WriteLine($&quot;Area: {area:F2}&quot;); } } }   Desse modo, podemos ver que caso o valor inputado no raio for negativo, o resultado da área será 0. Caso for positivo, o valor da área será calculado normalmente. Se importássemos esse objeto sem saber o que acontece por dentro dele, não entenderíamos o que acontece exatamente dentro do objeto circulo.  ","version":"Next","tagName":"h3"},{"title":"Mecanismos de Visibilidade/Acessibilidade​","type":1,"pageTitle":"Algoritmo e Abstração de Dados","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao#mecanismos-de-visibilidadeacessibilidade","content":" Os modificadores de acesso ou mecanismos de visibilidade são os métodos de acesso às classes e seus, atributos, propriedades e métodos. Existem vários tipos de modificadores de acesso (protected, internal, protected internal e etc), mas por agora, vamos estudar somente o public e o private.  Observemos novamente o código da última seção com algumas anotações adicionais.  // Bloco contendo todo o programa namespace WorkSpace { // Definição do TAD circulo class circulo { private double _raio; public double raio { get { return _raio; } set { if (value &lt; 0) _raio = 0; else _raio = value; } } public double calcArea() { return Math.PI* Math.Pow(_raio, 2); } } // Bloco contendo o programa class Program { // Procedimento do programa static void Main(string[] args) { double area; circulo xcir = new circulo(); xcir.raio = -2.5; area = xcir.calcArea(); Console.WriteLine($&quot;Area: {area:F2}&quot;); } } }   Podemos ver que a classe circulo é criada antes do bloco que contém o programa propriamente dito. Ou seja, estão em escopos diferentes. Desse modo, um comando contido no procedimento Main não tem acesso a nenhuma propriedade ou atributos com o parâmetro private nele somente os de parâmetro public ou através das funções set e get.  Atenção: Na criação da classe circulo não foi dito se ela seria acessível fora do seu escopo original, ou seja, não usamos o comando public class circulo e sim o comando class circulo. Em c#, quando se cria uma classe sem a definição explícita da sua visibilidade, o padrão da linguagem é deixar a classe como public.  Qualidade e Robustez de Software​  Esses conceitos de controle de acesso são importantes porque nosso código precisa fazer o que foi planejado, da maneira planejada. Quando não limitamos a capacidade do usuário inserir dados, podemos cair em situações não previstas que podem comprometer a execução do nosso programa.  Um conceito que nos ajuda a entender melhor essa situação é o robustez do software. Esse conceito é usado pelos profissionais de qualidade de software e que é referente a capacidade do programa em funcionar da maneira correta em diferentes cenários e condições adversas.  Outro conceito útil dessa área é o correção de software que é a qualidade referente a capacidade do nosso programa funcionar da maneira prevista e especificada.  A técnica da omissão da informação nos ajuda a garantir o cumprimento desses requisitos.  ","version":"Next","tagName":"h3"},{"title":"Construtores e Destrutores de Classe​","type":1,"pageTitle":"Algoritmo e Abstração de Dados","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao#construtores-e-destrutores-de-classe","content":" Um construtor de classe é usado para criação de um objeto e pela inicialização dos seus atributos. Sempre que instanciamos um objeto, o seu construtor entra em ação.  Comentário Não entraremos a fundo no conceito de Common Language Runtime (CLR) agora. Talvez mais pra frente a gente veja isso.  Se um construtor não for declarado explicitamente, o c# cria a classe usando algumas convenções de modo a colocar o objeto disponível para uso. Esses padrões de construtores são definidos de acordo com o tipo primitivo das variáveis contidas no nosso objeto (que sabemos que se chamam atributos). Por padrão, o CLR atribui os seguintes valores para os atributos dos objetos:  0 para variáveis do tipo int, double e floatfalse para variáveis booleanas'\\0' para variáveis do tipo string  Definindo Construtores​  Para não usarmos as convenções padrão do CLR. Podemos, nós mesmo, atribuir os construtores dos atributos dos nossos objetos. Para isso, usamos um método (ou seja, uma função interna do objeto) com o mesmo nome do objeto. Esse método não possui retorno e são declarados como public.  [...] // Código com o namespasce class circulo { private double _raio; public double raio { get {return _raio;} set {_raio = value;} } public circulo() // construtor { _raio = 0; } public double calcArea() { return Math.PI * Math.Pow(_raio,2); } }   A partir de agora, sempre que executarmos um instanciamento através do comando  circulo xcir = new circulo();   O construtor será chamado e executará as instruções contidas no construtor. No caso de exemplo, o valor default para o atributo _raio será 0.  Não é difícil pensar em situações onde precisaríamos usar diferentes métodos de construção em um objeto. Para isso, podemos ter mais de um construtor no mesmo objeto, chamamos isso de sobrecarregamento. A condição é que esses construtores sejam diferentes em termos de parâmetros ou ordem dos parâmetros.  [...] // Código com o namespasce class circulo { private double _raio; public double raio { get {return _raio;} set {_raio = value;} } public circulo() // construtor { _raio = 0; } public circulo(int R) { _raio = R; } public double calcArea() { return Math.PI * Math.Pow(_raio,2); } }   Para executar o segundo construtor, basta passarmos um parâmetro no momento do instanciamento do nosso novo objeto.  circulo xcirc = new circulo(2.3);   Como fizemos um instanciamento com valor, o c# saberá que queremos usar o segundo construtor ao invés do primeiro.  Destrutores​  Ao contrário do que podemos pensar pelo nome, os destrutores não são usados para &quot;destruir&quot; os objetos. Eles são usados definir um comportamento específico no momento da destruição de um objeto. Ou seja, eles são acionados na destruição e não são os destruidores.  Não precisam ser chamados ou referenciados pois são invocados automaticamente. O normal é não se usar destrutores no dia a dia visto que o CLR já faz o trabalho de padronização para eliminação de um objeto.  Diferente dos construtores, uma classe pode ter apenas um destrutor. E a sua criação é parecida com a do construtor, uma vez que são métodos sem retorno. A única diferença é que sua notação começa com o til.  [...] // Código com o namespasce class circulo { private double _raio; public double raio { get {return _raio;} set {_raio = value;} } public circulo() // construtor 1 { _raio = 0; } public circulo(int R) // construtor 2 { _raio = R; } ~circulo { Console.WriteLine(&quot;Adeus, mundo cruel!&quot;); } public double calcArea() { return Math.PI * Math.Pow(_raio,2); } }   Os detalhes de como um computador funciona são estudados em Estrutura de Computadores mas, para adiantar, algumas linguagens tem um programa chamado garbage colector que é responsável pela reutilização de slots de memória que estão sendo usados por objetos que não tem mais utilização no código.  Em c# nós não precisamos explicitamente eliminar um objeto porque o próprio garbage colector faz esse trabalho.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Algoritmo e Abstração de Dados","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-abstracao#bibliografia","content":" ASCENCIO, Ana Fernanda Gomes; CAMPOS, Edilene Aparecida Veneruchi de. Fundamentos da programação de computadores. São Paulo: Pearson, 2012. ISBN 9788564574168SOUZA, Marco A. Furlan de; GOMES, Marcelo Marques; SOARES, Marcio Vieira; CONCÍLIO, Ricardo. Algoritmos e lógica de programação: um texto introdutório para a engenharia. São Paulo: Cengage Learning, 2019. ISBN: 9788522128150AGUILAR, Luis Joyanes. Fundamentos de programação algoritmos, estruturas de dados e objetos. 3. ed. Porto Alegre: AMGH, 2008. ISBN: 9788580550146DEITEL, Harvey M; DEITEL, Paul J. Java - como programar. 8. ed. São Paulo: Pearson, 2010. ISBN 9788576055631GRIFFITHS, Ian. Programming C# 8.0. O'Reilly Media, Inc. 2019. ISBN 9781492056812MANZANO, José Augusto N. G; OLIVEIRA, Jayr Figueiredo de. Algoritmos: lógica para desenvolvimento de programação de computadores. 28. ed. rev. e atual. São Paulo, SP: Érica, 2016. E-book. ISBN 9788536518657PRICE, Mark J. C# 8.0 and T Core 3.0 - Modern Cross - Platform Development. O'Reilly Media; 2019. ISBN 9781788478120PUGA, Sandra; RISSETTI, Gerson. Lógica de programação e estruturas de dados com aplicações em Java. 2. ed. São Paulo: Prentice Hall, 2009. ISBN 9788576052074    Footnotes​ Isso é muito legal! ↩ ","version":"Next","tagName":"h2"},{"title":"Engenharia de Requisitos","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/segundo-periodo/engenharia-requisitos","content":"","keywords":"","version":"Next"},{"title":"Tipos e Elicitação de Requisitos de Software​","type":1,"pageTitle":"Engenharia de Requisitos","url":"/CC_site/docs/puc/segundo-periodo/engenharia-requisitos#tipos-e-elicitação-de-requisitos-de-software","content":" ","version":"Next","tagName":"h2"},{"title":"Características e Tipos de Requisitos​","type":1,"pageTitle":"Engenharia de Requisitos","url":"/CC_site/docs/puc/segundo-periodo/engenharia-requisitos#características-e-tipos-de-requisitos","content":" Conceitos e Características de Requisitos​  Os conceitos são palavras dotadas de significados objetivos. Ao longo de todos os nossos estudos, nós, basicamente, estamos aumentando nosso repertório de conceitos e ligando conceitos novos aos que já aprendemos previamente. Desse modo, não é nenhuma novidade começar nosso estudo por meio da definição dos conceitos que vamos usar ao longo do microfundamento.  Chamamos de Requisito toda Característica que um produto deve possui para ser aceito. Dessa feita, podemos definir como Engenharia de Requisitos, o conjunto das técnicas usadas para levantamento, detalhamento e validação desses requisitos de um produto.  Ao tomarmos notas a respeito dos requisitos, precisaremos garantir que os mesmos tenham as seguintes Características:  Completude - Descrição integral da necessidade a ser atendida.Correção - Descrição exata e associada ao software que será desenvolvido.Exequidade - Um requisito de ser passível de execução.Prioridade - Descrição do nível: Obrigatório, Desejável ou Opcional.Modificação - Capacidade de alteração do requisito ao longo do processo.Verificabilidade - Capacidade de se realizar testes que verifiquem se o requisito fora alcançado.Rastreabilidade - Relação entre código e requisito de maneira clara e recíproca.  Tipos de Requisitos​  Podemos separar os requisitos segundo a sua relação com a funcionalidade do software:  Requisito Funcional - É diretamente relacionado ao funcionamento do programa. Descreve uma função a ser desempenhada pelo produto com maior foco no negócio e não na tecnologia. Requisito Não Funcional - É relacionado a tecnologia de desenvolvimento. Ele especifica/restringem o comportamento desejado do software. Requisito de Desempenho - Especifica atributos como velocidade ou consumo de memória que o sistema deve ter.Requisito de Confiabilidade - Especifica a taxa aceitável de falhas do sistema.Requisito de Proteção - Relacionado a segurança do software.Requisito de Usabilidade - Características desejadas de usabilidade.  ","version":"Next","tagName":"h3"},{"title":"Elicitação de Requisitos de Software​","type":1,"pageTitle":"Engenharia de Requisitos","url":"/CC_site/docs/puc/segundo-periodo/engenharia-requisitos#elicitação-de-requisitos-de-software","content":" Processos da Engenharia de Requisitos e Técnicas de Elicitação​  Elicitar é o processo de extrair ou obter o máximo de informação possível para o conhecimento de um objeto desejado. Logo, Elicitação de Requisitos é o processo de extrair dos clientes as reais necessidades da demanda dele, ou seja, os requisitos da demanda. Além disso, a classificação desses requisitos nas categorias que aprendemos na seção passada.  Para se extrair essas informações podemos usar uma miríade de técnicas:  Entrevista - Com roteiro para as principais questões. Prioritariamente algo rápido e não cansativo. Pode ser individual ou em grupo.Brainstorming - Reunião sem roteiro definido. A criatividade é o foco na construção de propostas de resolução de um determinado problema.Questionário - Com perguntas fechadas ou abertas. Tem como vantagem a praticidade.Protótipo - É indicado para situações onde o user não tem facilidade em se expressar. A elicitação é feita pela interação entre user e protótipo.Etnografia - É a observação da realidade do cliente por um período.  Após as coletas de todas as informações, passamos para fase de Estudo de Documentos em que os dados serão convertidos em requisitos funcionais e não funcionais do projeto.  ","version":"Next","tagName":"h3"},{"title":"Modelagem, Validação e Verificação de Requisitos​","type":1,"pageTitle":"Engenharia de Requisitos","url":"/CC_site/docs/puc/segundo-periodo/engenharia-requisitos#modelagem-validação-e-verificação-de-requisitos","content":" ","version":"Next","tagName":"h2"},{"title":"Modelagem de Requisitos​","type":1,"pageTitle":"Engenharia de Requisitos","url":"/CC_site/docs/puc/segundo-periodo/engenharia-requisitos#modelagem-de-requisitos","content":" Modelagem de Requisitos e Introdução à UML​  A Unified Modeling Language (UML) é uma linguagem de modelagem unificada. Surgida em 1997 como resultado de um esforço de várias empresas para a construção de um padrão para a modelagem de engenharia de software. Vale ressaltar que a UML não é uma metodologia e apenas uma maneira de expor processos de software.  A Modelagem de Requisitos ou Análise de Requisitos é a produção da lista de requisitos funcionais e não-funcionais para um projeto. Para padronização desses produtos, usamos a UML como linguagem de representação.  A UML possui 3 tipos de diagramas:  Diagrama de Estrutura - Foco na visão estática. Diagrama de ClassesDiagrama de Pacotes Diagrama de Comportamento - Foco na visão dinâmica. Diagrama de Caso de Uso Diagrama de Interação - Representação da comunicação entre objetos.  Modelagem de Casos de Uso UML​  Como acabamos de ver, o diagrama de casos de uso é um tipo de diagrama de comportamento e, logicamente, tem foco no comportamento dinâmico entre as partes envolvidas no funcionamento do sistema.  O diagrama de casos de uso é geralmente o primeiro diagrama UML usado na fase de requisitos pois permite o detalhe dos requisitos funcionais na fase de elicitação. É importante notar que, por ter foco na interação entre as partes, esse tipo de diagrama não é usado para elicitação dos requisitos não-funcionais.  As partes integrantes do diagrama de casos de uso são:  Atores - São as representações da entidades que interagem com o sistema. Sejam elas seres humanos, sensores ou outros sistemas. Casos de Uso - São as transações entre as partes. Relacionamentos - Podem ser divididos em quatro tipos: Associação - É o relacionamento mais comum. Representado por uma seta aberta (ou uma linha reta) que liga os atores aos casos de uso. Não pode ligar atores a atores ou casos de uso a casos de uso.Generalização - Acontece quando há uma relação de herança entre elementos. Pode acontecer entre atores e atores e casos de uso e casos de uso.Inclusão (Include) - São usados para representar rotinas comuns entre transações do sistema por meio do uso de uma seta pontilhada com a lable de include. Só ocorre entre casos de uso.Exclusão (Extend) - É usada para indicar exceções. Tem a notação parecida com o include mas no lable está escrito exclude.  Abaixo temos um exemplo desse diagrama.    Práticas de Diagrama de Casos de Uso​  Essa seção é um exercício proposto de construção de um diagrama de casos de uso. O problema proposto é:  O cliente cadastra os dados pessoais, depois do veículo e finalmente a proposta da seguradora.  Alguns clientes são da categoria &quot;especial&quot; do programa de fidelidade da seguradora e cadastram as propostas de seguros com desconto.  A seguradora formata a proposta baseada nos dados dos veículos cadastrados. Depois, os clientes pagam as prestações do seguro.  Caso haja inadimplência, a seguradora cancela o seguro. Comunicando o cliente.  Em caso de acidente, o cliente comunica o sinistro à seguradora. Ela paga as despesas do conserto. Em casos raros, a seguradora paga ao cliente o valor integral do veículo.  Comentário Antes de olhar como ficou. Tente fazer o diagrama sozinho. Uma boa ferramenta para isso é o Lucidchart ou o Draw.io.  Abaixo temos uma representação de caso de uso possível para o caso exemplo.    Modelagem de Classes UML​  Começaremos a ver os diagramas de estrutura pelo Diagrama de Classes de UML. Seu objetivo é definir a estrutura estática de relacionamento entre classes.  Lá em programação modular nós aprendemos que uma classe é um conjunto de objetos com propriedades similares. Toda classe tem um nome e atributos que descrevem as suas propriedades. Além disso, possuem métodos que são as funções internas da classe.    Comentário Esse último parágrafo faz muito sentido para todos que já passaram pela matéria de programação modular. Se não for o seu caso, corre lá depois que terminar esse microfundamento.  Também sabemos que classes podem ser relacionadas entre si pela relação de herança que é um dos pilares da programação orientada à objetos. No contexto da UML, podemos chamar essa relação de herança de Generalização-Especialização. A representação entre a superclasse e as classes filhas é feita com o uso de uma seta de ponta fechada onde a seta sempre sai da subclasse e aponta para a superclasse.    O outro modelo de relacionamento é a agregação ou Estrutura Todo-Parte. Nesse relacionamento não há herança, entretanto, existe alguma relação de pertinência de modo que cada parte é um elemento do todo. Possui a representação da multiplicidade (1...*) para indicar a quantidade de itens que o relacionamento suporta.  A agregação pode ser representada de dois modos. Na Agregação Simples usamos um losango em branco e indica que a parte possui vida além do todo1. Por outro lado, na Agregação por Composição, usamos o losango preenchido para indicar que a parte não tem vida além do todo.    Comentário A ideia nessa dotação da multiplicidade é simples. Imagine que temos uma classe &quot;Estoque&quot; e uma classe &quot;Produto&quot;. Uma vez que um estoque é justamente o todo dos produtos armazenados, é plenamente possível termos a relação entre essas classes. Podemos usar a relação de agregação para indicar esse caso. Quando ligamos as classes, nós indicamos quantos objetos são aceitos na relação. No nosso exemplo é possível termos um estoque de zero itens2 de cada produto, logo, a multiplicidade indicada será de 0...* que deve ser lida como ``Podemos ter entre zero e n produtos no nos&quot; estoque&quot;.  Para terminar essa seção, temos apenas mais uma relação a ser aprendida. Na Associação, também não temos relação de herança e também temos multiplicidade. A diferença está no fato que não existe relação de todo e parte, ou seja, o vínculo entre as classes é mais fraco.  Normalmente, a associação é indicada por uma linha reta entre as classes com as multiplicidades com asteriscos nos dois lados. Além disso, podemos ter uma classe `&quot;endurada&quot; entre a associação para indicar o modo.    Modelagem de Pacotes UML​  Uma vez que tenhamos feito nossos diagrama de classes, temos um diagrama que é capaz de &quot;empacotar&quot; classes relacionadas. Esse diagrama recebe o nome de Diagrama de Pacotes. Tal qual o diagrama de classes, o diagrama de pacotes é um digrama estrutural da UML.  Não existe muita exatidão no processo de construção de pacotes. A ideia é que a associação entre classes faça sentido e, nessas horas, o bom senso é a nossa melhor ferramenta.  No geral, podemos elencar algumas regras para nos ajudar na criação de pacotes:  Deve ter duas ou mais classesNome genérico ou da classe mais importanteRepresentação na UML pelo ícone da uma pastaUma classe pode pertencer a mais de um pacoteNenhuma classe deve ficar fora do diagrama de pacotesUm pacote pode depender de outros pacotesA dependência de pacotes é dada no UML pelo uso de uma seta pontilhada    ","version":"Next","tagName":"h3"},{"title":"Validação e Verificação de Requisitos​","type":1,"pageTitle":"Engenharia de Requisitos","url":"/CC_site/docs/puc/segundo-periodo/engenharia-requisitos#validação-e-verificação-de-requisitos","content":" Validação e Verificação de Requisitos​  Uma vez que temos nosso sistema modelado, podemos nos perguntar se ``estamos construindo o pro&quot;to certo&quot;. Chamamos de validação o trabalho de verificação da resposta a essa pergunta. Ou seja, estamos verificando a eficácia da nossa solução.  Do outro lado, dizemos que a verificação tem relação com a eficiência. Isso quer dizer que queremos saber se além de cumprir o objetivo, nossa solução o faz com a otilização dos recursos de maneira certa.  Para realizarmos essas duas verificações podemos fazer uso da Revisão Técnica que avalia esses aspectos por meio um time das partes envolvidas no processo para a busca das seguintes falhas:  erros no conteúdo\\interpretaçãoinformações faltantesinconsistênciasrequisitos conflitantes\\irreais  Para realizar essas verificações, podemos usar várias abordagens:  Inspeções de CódigoComandos de Banco de DadosAnálise dos RequisitosTestes de Software  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Engenharia de Requisitos","url":"/CC_site/docs/puc/segundo-periodo/engenharia-requisitos#bibliografia","content":" SOMMERVILLE, Ian. Engenharia de Software. São Paulo: Pearson, 2019.BEZERRA, Eduardo. Princípios de Análise e Projeto de Sistemas com UML. São Paulo: Elsevier, 2006.PRESSMAN, Roger; MAXIM, Bruce. Engenharia de Software. São Paulo: Bookman, 2016.LARMAN, Craig. Utilizando UML e padrões: uma introdução á análise e ao projeto orientados a objetos e desenvolvimento iterativo. 3. ed. Porto Alegre: Bookman, 2007. E-book (695 páginas) ISBN 9788577800476.PAULA FILHO, Wilson de Pádua. Engenharia de software, v. 2 projetos e processos. 4. Rio de Janeiro LTC 2019 1 recurso online ISBN 9788521636748.WAZLAWICK, Raul Sidnei. Engenharia de software conceitos e práticas. Rio de Janeiro GEN LTC 2013 1 recurso online ISBN 9788595156173.GUEDES, Gilleanes. UML 2 - Uma Abordagem Prática. São Paulo: Novatec, 2018.    Footnotes​ Isso é um jeito estranho de dizer que a parte não está inteiramente contida no todo. ↩ Ou seja, é o caso onde não temos o produto estocado. ↩ ","version":"Next","tagName":"h2"},{"title":"Modelagem de Dados com SQL","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql","content":"","keywords":"","version":"Next"},{"title":"Linguagem de Definição de Dados (DDL)​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#linguagem-de-definição-de-dados-ddl","content":" ","version":"Next","tagName":"h2"},{"title":"Conceitos Básicos​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#conceitos-básicos","content":" O que é SQL​  Banco de Dados Relacional​  ","version":"Next","tagName":"h3"},{"title":"Linguagem DDL​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#linguagem-ddl","content":" Comando CREATE TABLE​  Comandos ALTER, DROP, TRUNCATE e RENAME​  ","version":"Next","tagName":"h3"},{"title":"Linguagens de Manipulação de Dados (DML)​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#linguagens-de-manipulação-de-dados-dml","content":" ","version":"Next","tagName":"h2"},{"title":"Inserindo, Atualizando e Excluindo Dados​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#inserindo-atualizando-e-excluindo-dados","content":" Comandos INSERT, UPDATE e DELETE​  ","version":"Next","tagName":"h3"},{"title":"Consultando Dados​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#consultando-dados","content":" Comando SELECT​  Operadores​  Funções Agregadas​  ","version":"Next","tagName":"h3"},{"title":"Agrupando Dados​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#agrupando-dados","content":" Cláusulas GROUP By e HAVING​  ","version":"Next","tagName":"h3"},{"title":"Junção de Tabelas​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#junção-de-tabelas","content":" Cláusula JOIN​  ","version":"Next","tagName":"h3"},{"title":"Consultas Aninhadas​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#consultas-aninhadas","content":" Consultas Aninhadas Sem e Com Correlação​  ","version":"Next","tagName":"h3"},{"title":"Transação e Segurança​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#transação-e-segurança","content":" ","version":"Next","tagName":"h2"},{"title":"Transação e Propriedades ACID​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#transação-e-propriedades-acid","content":" Transação em Banco de Dados​  ","version":"Next","tagName":"h3"},{"title":"Segurança​","type":1,"pageTitle":"Modelagem de Dados com SQL","url":"/CC_site/docs/puc/segundo-periodo/modelagem-sql#segurança","content":" Comandos GRANT e REVOKE​ ","version":"Next","tagName":"h3"},{"title":"Design de Interação","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/segundo-periodo/design-interacao","content":"","keywords":"","version":"Next"},{"title":"Elementos do Design de Interação​","type":1,"pageTitle":"Design de Interação","url":"/CC_site/docs/puc/segundo-periodo/design-interacao#elementos-do-design-de-interação","content":" Ao longo desse microfundamento, teremos o objetivo de responder a seguinte pergunta: &quot;O que leva um usuário a gostar de usar um sistema?&quot;. Assumiremos um papel chamado de projetista de sistemas interativos.  A base desse trabalho é compreender o usuário, os sistemas interativos e a relação entre usuário e sistemas. Vamos aprender a projetar essas interações bem como avaliar se os objetivos determinados foram alcançados.  Comentário Essa matéria tem abordagem bem teórica. Então esse material vai ser o mais resumido possível sobre os temas abordados. Quem tiver interesse em se aprofundar, pode buscar esse diferencial na bibliografia.  ","version":"Next","tagName":"h2"},{"title":"Sistemas Interativos em Contexto​","type":1,"pageTitle":"Design de Interação","url":"/CC_site/docs/puc/segundo-periodo/design-interacao#sistemas-interativos-em-contexto","content":" Em qualquer planejamento de interações existem dois atores: o usuário humano e o computador. Ambos são peças fundamentais para o desenho das interações, entretanto, a maneira como modelamos o comportamento desses agentes pode variar de acordo com o contexto e o objetivo de design.  Podemos dizer que existem quarto perpectivas básicas para modelagem das interações user-computador:  Perspectiva Sistema - Abora a interação user-pc como a interação entre dois sistemas. Uma característica marcante dessa abordagem é o uso de formas codificadas como atalhos de teclas ou linguagem formal. A ênfase é dada ao computador e na transmissão de dados. Dados como tempo de interação e número de erros são importantes para avaliação.Perspectiva Parceiro do Discurso - O ponto focal de avaliação está mais próximo do usuário. Existem interação por linguagem natural e inferência. Um exemplo dessa abordagem são as pesquisas relacionadas em sites de buscas. Dados como a qualidade da resposta provida pelo sistemas são importantes para essa abordagem.Perspectiva Ferramenta - O sistema é modelado como ferramenta para alcance de algum resultado. Existe claramente a presença de um resultado da interação (um artefato) que define o sucesso ou fracasso da interação. Dados sobre uso das funções disponíveis e facilidade de uso são importantes.Perspectiva Mídia - O foco aqui é na comunicação entre pessoas. Nesse caso o sistema atua como meio de comunicação entre usuários. A qualidade da comunicação é um dos dados mais importantes nessa abordagem.  ","version":"Next","tagName":"h3"},{"title":"Atributos de Qualidade da Interação (Cognição e Semiótica)​","type":1,"pageTitle":"Design de Interação","url":"/CC_site/docs/puc/segundo-periodo/design-interacao#atributos-de-qualidade-da-interação-cognição-e-semiótica","content":" Perspectiva teórica do Humano na Interação Humano-Computador​  A interação Humano-Computador (IHC) é o estudo dos sistemas computacionais que são projetados para receberem interações de usuários humanos. O foco principal é a implementação, avaliação e investigação dos sistemas e fenômenos relacionados ao seus usos.  Os usuários dos sistemas são humanos. Isso implica que a IHC leva em consideração aspectos do sistema cognitivo com suas preferências e comportamentos. Também entendem que existem diferenças entre usuários e, até mesmo, variações entre o mesmo usuários ao longo do tempo.  O método de investigação da IHC é teórico por meio do uso de abordagens distintas. No ramo das abordagens da psicologia experimental são usados dados mensuráveis e modelagem de comportamento humano. No ramo da psicologia cognitiva, temos a aplicação de conceitos teóricos para a interpretação de algumas interações e comportamentos observados.  Além dos caminhos de pesquisa baseados na psicologia, temos também a adoção de métodos oriundos do estudo da linguística que investigam os signos usados na comunicação e metacomunicação por meio de artefatos. Para citar algumas dessas abordagens temos: Leis de Hick-Hyman, Leis de Fitts, Processador Humano de Informação, Princípios da Gestalt, Teoria da Atividade, Cognição Distribuída, Engenharia Cognitiva, Teoria da Ação, Engenharia Semiótica e etc.  O Contexto da Experiência do Usuários​  Chamamos de contexto de uso todos os fatos que interferem e interagem com o uso de um sistema. Para citar alguns temos: tempo, ambiente físico, social e cultural, disponibilidade e outros fatores.  A interação do usuário sempre tem algum objetivo em mente que pode ser simples ou complexo. Qualquer interação, como cadastro de um funcionário, é analisada como uma interação.  As interações humano-computador acontecem por meio de uma interface. Ela atua como único meio entre os modos de processamento de informações orgânicos e biológicos do ser humano e os recursos de máquina do computador. A interface também atua como agende limitador das interações, visto que, ela é quem define as funções acessíveis ao usuário em dado tempo.  Outra limitação que a interface impõe a a respeito da acessibilidade. Se o sistema apenas possui uma interface de intração por CLI (Command Line Interface), o uso dessa aplicação será totalmente diferente de um outro sistema com GUI (Graphic User Interface), por exemplo.  Também podemos definir interação como a troca de informações e influência entre o usuário e o sistema através da interface. Interagir sempre implica em provar dados e receber novas informações como retorno.  É no contexto de uso que temos a Experiência do Usuário (User eXperience ou UX). Esse conceito tão famoso envolve a interface, a interação e o ambiente de interação. O processo de projetar a UX (UX Design) é levar em conta todos esses vários pontos para proporcionar sempre a melhor experiência possível.  A interface de usuário (UI) é a construção do modo em que a informação será disposta ao usuário por meio da arquitetura da informação (IA). Ela é quem define quais serão as partes em destaque e o que pode ser ``escondido'' por trás de um menu, por exemplo.  Para concluir esses conceitos, vamos coloca-los todos juntos: Por meio da interface e dentro de um contexto de uso é que ocorrem as interações de modo que a UX desse usuário é definida, além desses dois primeiros fatores, pela IA1.  O estudo de todas as variáveis que amarramos acima é chamado de Design de Interação (IxD). Não é nenhum espanto constatar que em várias equipes de IxD tenhamos a presença de profissionais de vários campos de estudos que variam da linguística até a antropologia.  Atributos de Usabilidade, Comunicabilidade e Acessibilidade​  Quais seriam os atributos necessários para que possamos avaliar uma interação como adequada? Podemos definir quatro características que podem nos ajudar a julgar essa matéria:  Usabilidade - Grau em que um produto é usado por usuários específicos para se atingir um objetivo específico em um dado contexto de uso.Acessibilidade - Uso do sistema sem que a interface imponha obstáculos ao usuário.Experiência de Uso - Como o usuário se sente ao interagir com o sistema. Pode ser grandemente impactada por todos os elementos do contexto de uso.Comunicabilidade - Capacidade da interface comunicar ao usuário a lógica que rege o seu funcionamento.  Existem alguns normativos que regem os consensos da comunidade ao longo dessas questões. Podemos destacar a ISO/IEC 25010:2011 e a ISO 9241-11:2018(en).  A interação pela Lente Cognitiva​  Em 1986, um pesquisador chamado Donal Norman lançou os fundamentos do que hoje é conhecida como Engenharia Cognitiva (EC). Esse ramo de estudos busca compreender os fundamentos da ação e desempenho humano que sejam relevantes para a construção de design de modo a possibilitar a criação de sistemas agradáveis e engajantes.  Em sua base a EC considera que existem dois grupos de variáveis: 1) Variáveis Psicológicas e 2) Variáveis Físicas (estados do sistema) e Controles Físicos (mecanismos de interação). como são conjuntos de variáveis muito diferentes entre si. Podem existir discrepâncias causadas nas tentativas de construir modos de interação entre esses dois &quot;mundos&quot; distintos. Podemos destacar três tipos de problemas:  Problemas de Mapeamento - As variáveis psicológicas precisar ser conectadas às variáveis físicas por meio da interface. Qualquer imprecisão no meio de comunicação entre user e computador gera problemas de mapeamento.Dificuldade de Controle - O quão fácil é controlar as variáveis físicas para se alcançar o objetivo proposto pela solução.Dificuldade de Avalização - O quão fácil é avaliar se o resultado da interação do user está de acordo com o objetivo da interação.  Os problemas descritos acima são originários da diferença entre como o designer entende o sistema e como o usuário entende o sistema. Podemos criar alguns conceitos para organizar melhor essa problemática de meios de interpretação diversos do mesmo sistema. É possível separar essas interpretações em três componentes:  Modelo de Design - Modelo conceitual que o sistema é compreendido pelo design.Imagem do Sistema Físico - É o sistema físico construído a partir do modelo de design.Modelo do Usuário - É o modelo construído internamente pelo usuário ao longo das interações com o sistema.  Comentário Cada conceito que vimos até agora levam anos de pesquisa até se ter algum domínio. Nosso foco por agora é apenas conhecer a existência desses conceitos bem como uma versão resumida do que são.  Fontes Complementares:  NORMAN, Donald A. Steps toward a cognitive engineering: Design rules based on analyses of human error (Links para um site externo.). In: Proceedings of the 1982 conference on Human factors in computing systems. 1982. p. 378-382. Acesso em 15 de Mai. de 2021.NORMAN, Donald A. Cognitive engineering. User centered system design, v. 31, p. 61, 1986.  A interação pela Lente Semiótica​  Comentário Eu não sei vocês, mas, pra mim, a palavra semiótica é o tipo de palavra que apenas eruditos e intelectuais costumam usar. Então, finalmente, chegou a nossa hora de aprender o que significa isso.  Podemos definir a Semiótica como o ramo da linguística que estuda como e porque as pessoas atribuem significado às coisas e, além disso, como usam esses objetos dotados de significado para se comunicar.  Por sua vez, a Engenharia Semiótica busca compreender a interação humano-computador como um caso particular de comunicação humana mediada por sistemas computacionais. Esse processo de comunicação ocorre em dois níveis:  Comunicação direta user-sistemaMetacomunicação designer-user mediada pela interface do sistema.  A interface pode ser entendida como um meio da mensagem passada pelo designer. Essa comunicação se dá por meio de signos (coisas com significado), significados (tarefas que desejamos executar) e representações (janelas, botões, menus e etc).  Existem três tipos de signos:  Estáticos - Comunicam seu significado integral por meio de telas fixas do sistemaDinâmicos - Comunicam seu significado integral em sequência de telas e não e apenas uma visão.Metalinguísticos - São signos que explicam outros signos (estáticos ou dinâmicos).  ","version":"Next","tagName":"h3"},{"title":"Processo de Design de Interação​","type":1,"pageTitle":"Design de Interação","url":"/CC_site/docs/puc/segundo-periodo/design-interacao#processo-de-design-de-interação","content":" ","version":"Next","tagName":"h2"},{"title":"Perspectivas de Design​","type":1,"pageTitle":"Design de Interação","url":"/CC_site/docs/puc/segundo-periodo/design-interacao#perspectivas-de-design","content":" Métodos de se Projetar um Sistema​  No esforço de construir boas interfaces de sistemas, podemos partir de abordagens diferentes que focam em pressupostos de interpretação da interação user-computador. Grosso modo, podemos agrupar essas abordagens em dois grupos:  De Dentro para Fora - Foco no software. Primeiro se projeta a estrutura de dados, lógica do sistema e, por fim, a interface. As métricas são focadas na eficiência de funcionamento do sistema.De Fora para Dentro - Foco no usuário. Começa-se com o projeto da interface para, depois, seguir o planejamento da lógica e a organização dos dados. Essa abordagem demanda um amplo conhecimento da pessoas que farão uso do sistema.  Graus de Importância do Usuário  Existem algumas maneiras de se considerar o usuário na hora de construirmos a interface das aplicações. Podemos definir três graus de relevância do usuário na construção das aplicações:  Projeto Independente - Esse modelo não conhece nem consulta o usuário no processo de construção do software. O usuário terá de se adaptar à lógica do sistemas. Deve aceitar o que o sistema permite e não permite. Essa abordagem não é a ideal para sistemas interativos. Design Centrado no Usuário - Há a preocupação em entender quem são os usuários e quais são os seus objetivos. São coletados dados empíricos de uso, simulações e protótipos. Costumam ter quatro atividades para a construção: Identificação das necessidadesConstrução do design do sistemasConstrução da versão InterativaAvaliação do artefato Design Participativo - O usuário tem voz ativa no processo. Amplo foco na usabilidade.  Fontes Complementares:  KUHN, Sara; WINOGRAD, Terry. Participatory Design (Links para um site externo.). In: Bringing Design to Software. New York: Addison-Wesley, 1996. Acesso em: 01 Jul. 2021.PONCIANO, Lesandro. HCI Support Card: Creating and Using a Support Card for Education in Human-Computer Interaction (Links para um site externo.). In: Workshop sobre Educação em IHC. Simpósio Brasileiro de Fatores Humanos em Sistemas Computacionais. 2019, Vitória. Porto Alegre: Sociedade Brasileira de Computação, 2019. p. 106-111. Acesso em: 01 Jul. 2021.  Desing é Técnica ou Arte?​  Comentário Eu, particularmente, acho esse tipo de discussão pouco relevante. Então vou apenas resumir e indicar as bibliografias.  Basicamente, temos duas maneiras de enxergar o conhecimento de construção de design de interações:  Racionalismo Técnico - Existem problemas conhecidos com soluções pre-determinadas. O papel do designer seria &quot;enxergar&quot; as equivalências do caso prático dele com a teoria. Além disso, teria a responsabilidade de aumentar o seu repertório de soluções para sempre ter uma saída a um problema de design encontrado.Reflexão em Ação - Existem problemas e soluções únicas onde os métodos e ferramentas atuam apenas como auxiliadores do processo de construção do design. Nessa abordagem a criatividade do designer possui amplo espaço para construção.  Fontes Complementares:  PONCIANO, Lesandro. Debate Estruturado: Uma Estratégia Pedagógica para Ensino e Aprendizagem de Valores Humanos em Interação Humano-ComputadorLinks para um site externo.. In: Workshop sobre Educação em IHC - Simpósio Brasiliero de Fatores humanos em Sistemas Computacionais, 17., 2018, Belém. Porto Alegre: Sociedade Brasileira de Computação, 2018. Acessso em: 01 de Jul. de 2021.PONCIANO, Lesandro; ANDRADE, Nazareno. Perspectivas em Computação SocialLinks para um site externo.. Computação Brasil, Raquel Prates and Thais Castro (Eds.), v. 36, p. 30-33, 2018. Acesso em 01 de Jul. de 2021.  ","version":"Next","tagName":"h3"},{"title":"A Prática de Design​","type":1,"pageTitle":"Design de Interação","url":"/CC_site/docs/puc/segundo-periodo/design-interacao#a-prática-de-design","content":" Até agora tivemos guiado nossa caminhada no mundo dos conceitos. É importante saber os termos usados no mercado bem como suas referências bibliográficas, entretanto, o viés da nossa formação nos direciona para uma abordagem mais prática também.  Modelagem de Usuários e Necessidades​  Como designers de uma aplicação um dos nossos objetivos é alcançar a usabilidade que, pela ISO 9241-11 (2018), pode ser entendida como o grau de utilização do produto para o alcance dos objetivos de modo eficiente, eficaz e satisfatório.  Pois bem, sabemos que quem usará os nossos sistemas são os usuários, diante disso, só podemos construir aplicações com usabilidade se pensarmos no nossos usuários. Para pensarmos melhor a respeito deles, precisamos de informações que podem vir das mais diversas fontes: pesquisar, entrevistas, vivência e etc. A partir dessas informações, podemos realizar um processo chamado de Modelagem de Usuários.  A modelagem de usuários pode ser feita por meio de três técnicas:  Perfil de Usuário - Descrição detalhada das características. É u agrupamento de conjuntos característicos para um grupo de usuários reais (jovens, idosos, professores, alunos e etc) focam em algumas características e ignorando outras.Persona de Usuário - É o uso de uma fabulação a respeito do uso. Criamos uma história fictícia que elucida as funcionalidades que nosso sistema deve ter para que o objetivo do nosso personagem seja alcançado.Mapa de Empatia - Descrição do usuário por meio dos meios de fala, pensamento, sentimento, ação e contexto. Usa-se um mapa como esse aqui.  Fontes Complementares:  Artigo científico com exemplos de perfis: PONCIANO, Lesandro; BRASILEIRO, Francisco. Finding Volunteers' Engagement Profiles in Human Computation for Citizen Science Projects (Links para um site externo.). Human Computation, v. 1, n. 2, 2014. Acesso em: 01 de Jul. de 2021.Artigo científico com exemplos de perfis: LOUZADA, Henrique; CHAVES, Gabriel; PONCIANO, Lesandro. Exploring user profiles based on their explainability requirements in interactive systems (Links para um site externo.). In: Proceedings of the 19th Brazilian Symposium on Human Factors in Computing Systems. 2020. p. 1-6. Acesso em: 01 de Jul. de 2021.  Abordagens de Prototipagem​  Agora que temos nossos modelos de usuários, o próximo passo é construir o protótipo da nossa solução.  O objetivo dessa técnica é obter feedback dos interessados antes da construção final do projeto. Desse modo, uma boa fase de prototipagem pode economizar verdadeiras fortunas para as empresas e clientes.  Usualmente, o processo de prototipagem consiste em quatro etapas:  Definição do feedback a ser coletadoConstrução dos protótiposAvaliação dos interessadosDescarte do protótipo  Agora que sabemos as etapas gerais do processo, nos resta saber quem seriam esses interessados. A resposta para essa pergunta depende muito de quem se propor a respondê-la mas, no geral, clientes, outros designers e usuários são boas fontes de feedback.  Métodos de construção de Protótipos  Para a construção de protótipos temos uma infinidade de técnicas possíveis. Vamos destacar algumas:  Wireframe - Telas de baixa fidelidade com foco na arquitetura da informação e o layout.Mock-Up - Telas de alta fidelidade com inclusão de detalhes e funcionalidades mas com escopo de atuação reduzido2.Storyboards - Prototipagem por figuras similares a um diagrama de fluxo que ilustram detalhes na sequência de interação.Prototipação em Vídeo - Criação de uma narrativa visual de utilização da solução com exemplo do que será feito na experiência real.Protótipo em Papel - Desenho livre das funcionalidades. Permite uma alta ajustabilidade mas é desaconselhado para projetos de alta complexidade.  Graus de Fidelidade em Prototipagem  Agora que aprendemos alguns dos métodos usados na construção dos protótipos, podemos ver que existem diferentes níveis de abstração a depender de qual método optarmos. Chamamos de prototipação horizontal os métodos que temos menor profundidade nos detalhes, entretanto, uma maior amplitude na quantidade de características do sistema. Do outro lado, temos a prototipação vertical que foca em poucas características mas com uma abordagem muito mais profunda.  Além do escopo da quantidade de características, podemos avaliar os protótipos relativamente ao grau de fidelidade. Os métodos de baixa fidelidade são mais rápidos e baratos por focarem em abstrair a maioria dos detalhes em detrimento das ideias simples e iniciais. No outro espectro, métodos de alta fidelidade tentam se aproximar grandemente do que será o resultado final com o máximo de detalhes possíveis.  Cores, Fontes e Harmonização​  A tipografia é o ramo que estuda as diferentes características entre os ``tipos''. Geralmente, agrupados por meio de famílias, época e estilo.  Além das fontes de texto, as cores também são importantes no quesito da estética da aplicação. Cores podem ser entendidas em termo de ``temperatura'' como cores quentes para objetos em destaque e cores frias para objetos de background. Para auxiliar a escolha da identidade visual, podemos usar ferramentas como o círculo cromático para escolher cores de diferentes padrões como, por exemplo:  Complementares - Opostas no círculo cromáticoAnálogas - Três cores vizinhas no círculo cromáticoTríades - Três cores equidistantes no círculo cromáticoDivisão Complementar - Três cores. Uma principal e uma cor de cada lado (sendo ambas complementares entre si)Esquema Quadrado - Dois pares de cores complementaresEsquema Retângulo - Quatro cores sendo um par complementar e um par análogo  Outra maneira de escolhermos cores é por meio de escalas padrão. Uma escala divergente é a que vai de um polo de cor até o outro. Uma escala sequencial é a que vai degradando uma mesma cor para a composição da escala. Uma escala qualitativa é a que reúne cores diferentes em uma mesma paleta. E, por fim, uma escala de cores com semânticas convencionais são escalas de cores que já possuem certo consenso na comunidade (por exemplo a escala Manchester usada em hospitais).  Componentes e Recomendações Ergonômicas​  Toda aplicação de ter o que chamamos de comportamentos elementares que podem ser entendidos como o básico para qualquer boa interação usuário-computador. Esses comportamentos ergonômicos elementares são:  Provisão de convite à interação por meio da indicação das ações possíveisProvisão do apoio às ações via redução da carga de trabalhoProvisão de feedback ao usuário em cada entrada de dados  A grande maioria das interações hoje em dia se dão por intermédio de uma Graphical User Interface (GUI) que, normalmente, utiliza padrões de janelas, ícones, menus e apontadores (WINP3). A abordagem usada para essas aplicações usa o padrão &quot;reconhecer, em vez de recordar&quot; que, como o nome diz, foca no uso guiado pelo reconhecimento de padrões em tela e não via memorização de padrões de uso.  Ícones  Durante a elaboração de qualquer aplicação, o projeto de ícones é relevante porque são eles que o usuário usa para o reconhecimento dos padrões de referência para o uso.  Para o alcance desse objetivo, temos alguns princípios norteadores para o uso dos ícones:  Metáfora - O uso de um conhecimento em um contexto para facilitar o entendimento. O exemplo clássico é o uso do ícone de um disquete como elemento de salvamento.Mapeamento Direto - Imagem parecida com o ícone a ser representado.Convenção - O significado de um ícone de se manter consistente ao longo de todo o sistema.  Erros e Alertas  Durante a comunicação entre computador e usuário, é muito comum o uso de mensagens de alerta e erro. Podemos elencar algumas boas práticas para o uso dessas ferramentas:  Uso de linguagem brandaNão usar dupla negativasO sentido dos verbos sempre deve apontar para o sistema. Por exemplo, &quot;Comando não reconhecimento&quot; ao invés de &quot;Comando incorreto&quot;Evitar o uso de caixa alta  Objetos de Interação  Aqui vamos ter uma série de recomendações sobre as melhores práticas a respeito dos objetos usados na elaboração de uma interface.  Em se tratando de objetos de seleção também temos algumas boas práticas a serem seguidas:  Listbox - Ordenar os elementos para facilitar a pesquisaRadio Button - Itens mutualmente excludentesCheck Box - Sempre permitir a seleção de múltiplas alternativas  Nos objetos de apresentação, temos de ficar atentos em:  Não usar hífen no final das linhasMáximo 60 caracteres por linhaUsar espaçamento entre parágrafosUsar bordas implícitas ou explícitasEvitar caixa altaFontes serifadas para textos longosFontes sem serifa para títulos e rótulos  No quesito preenchimento de formulários temos:  Usar diferenciação entre rótulo e dadosUsar diferenciação entre campos obrigatórios e opcionaisIndicar o que for text defaultUsar feedback sempre que houver envio dos dados ou salvamentoSempre ordenar de maneira satisfatória a navegação entre campos com uso da tecla tab  No fronte de interface podemos destacar:  Interfaces Web Maior atenção à arquitetura da informaçãoIndicação de como se mover no site Dispositivos Móveis Minimizar os níveis de navegaçãoMinimizar a quantidade de conteúdo exibidoReduzir a quantidade de entradas necessárias pelo usuárioAplicação tolerante com perda de sinal e desligamento do aparelho  Princípios e Regras de Design​  Agora vamos aprender alguns princípios gerais por dois grupos. Os princípios gestálticos são oriundos da escolha de pensamento Gestalt muito usada no estudo da psicologia. Complementarmente, vamos ver uma lista de princípios chamados de regras de ouro.  O princípios gestálticos são:  Proximidade - Entidades visuais próximas são entendidas como grupo.Alinhamento - Alinhamento são melhor percebidos que contornos irregulares.Simetria - Objetos simétricos são percebidos melhor que objetos assimétricos.Similaridade - Semelhança de objetos implica em unidade.Destino Comum - Objetos com um mesmo sentido são percebidos como grupo.Fecho - A mente costuma completar figuras incompleta para gerar regularidade.Região Comum - Objetos dentro de um contorno são percebidos como unidade.Conectividade - Objetos conectados são entendidos como unidade.  As regras de ouro são:  ConsistênciaFornecer AtalhosFornecer Feedbacks InformativosMarcar o Final dos DiálogosPermitir Reversão de AçõesFornecer Controle de Iniciativa do UserReduzir a Carga de Memória de Trabalho  Fontes Complementares: Aqui tem um artigo sobre as regras de ouro que explica melhor cada um desses pontos. Em tempo oportuno essa seção será atualizada com um resumo deles.  ","version":"Next","tagName":"h3"},{"title":"Avaliação da Qualidade de Sistemas Interativos​","type":1,"pageTitle":"Design de Interação","url":"/CC_site/docs/puc/segundo-periodo/design-interacao#avaliação-da-qualidade-de-sistemas-interativos","content":" ","version":"Next","tagName":"h2"},{"title":"Abordagens de Avaliação​","type":1,"pageTitle":"Design de Interação","url":"/CC_site/docs/puc/segundo-periodo/design-interacao#abordagens-de-avaliação","content":" O Processo de Avaliação de Sistemas Interativos​  Podemos definir as abordagens de avaliação de sistemas em diferentes modos.  No primeiro modo de separação, podemos nos ater ao momento da avaliação. Nesse caso podemos ter uma avaliação no começo ou no final do Desenvolvimento do sistema. Quando realizamos a avaliação no início do processo de projeto para nos asseguramos que estamos no caminho certo, estamos realizando a Avaliação Formativa. Na outra ponta, quando avaliamos no final do processo se todos os objetivos foram atingidos, é dito que fizemos a Avaliação Somativa.  A outra maneira de separar as abordagens de avaliação é quanto ao método de avaliação. Nesse caso, podemos destacar três abordagens:  Avaliação por Inspeção - Nessa abordagem o usuário não é envolvido. Ao invés disso, simulamos um usuário por meio de um inspetor que tenta se colocar na posição de user.Avaliação por Observação - Nessa abordagem os usuários participam e a avaliação é feita através do uso direto do sistema ou de alguma representação do mesmo.Avaliação por Investigação - Nessa abordagem os usuários participam, entretanto, a avaliação é feita mediante a aplicação de técnicas de investigação (questionário, focus group e etc).  ","version":"Next","tagName":"h3"},{"title":"Métodos de Avaliação​","type":1,"pageTitle":"Design de Interação","url":"/CC_site/docs/puc/segundo-periodo/design-interacao#métodos-de-avaliação","content":" Inspeção do Percurso Cognitivo​  Agora que aprendemos sobre algumas das abordagens de avaliação, podemos nos aprofundar um pouco mais em como colocar alguma dessas abordagens em prática por meio de métodos. Nesse tópico, focaremos nos métodos de avaliação por inspeção.  No método de Avaliação Heurística, nos baseamos em um conjunto de dez heurísticas (que são métodos de investigação) para avaliarmos se o sistema possui as características desejadas. As dez heurísticas de Nielses são:  Visibilidade do Estado do SistemaCorrespondência Sistema - Mundo RealControle e Liberdade do UserConsistência e PadronizaçãoReconhecimento ao invés de MemorizaçãoPrevenção de ErrosFlexibilidade e Eficiência de UsoProjeto Estético e MinimalistaAjuda ao User com ErrosAjuda e Documentação  Outra metodologia possível é a chamada Avaliação do Percurso Cognitivo. Nesse método, nós nos baseamos em quatro questões:  O user tenta alcançar o resultado desejado?O user nota que existe uma ação correta disponível?O user consegue associar a ação correta ao efeito que se quer atingir?O user percebe que está progredindo em direção à conclusão da tarefa?  Em ambos os métodos temos a coleta de dados, avaliação e preparação de avaliação baseadas nos fluxos e princípios que levantamos antes.  Inspeção Semiótica​  Nessa seção vamos aprender duas abordagens de avaliação da comunicabilidade de sistemas também baseados no processo de inspeção.  O Método de Inspeção Semiótica (MIS) é um tipo de avaliação que busca analisar a comunicabilidade do sistema por meio da emissão da metacomunicação. Metacomunicação é o estudo da capacidade de comunicar a própria dinâmica da comunicação entre interlocutores, ou seja, é o estudo da informação sobre a informação.  Comentário Bem filosófico né?! Eu, sinceramente, acho que não vale a pena entrar muito profundamente em cada tópico desse por agora. Vamos ficar apenas na superfície por enquanto.  O protocolo MIS é baseado em:  Inspeção da metacomunicação de recursos de ajuda e documentaçãoInspeção da metacomunicação em signos estáticosinspeção da metacomunicação em signos dinâmicosConfronto dos resultados anterioresAnálise da qualidade da metacomunicação  Cada item do protocolo leva em consideração os seguintes elementos:  Quem é o userO que se quer fazerQual a maneira preferida de se executar essa tarefaQual é o sistema projetadoQual a maneira que o sistema está projetado para realizar essa tarefa  Além dessa metodologia, temos o Método de Avaliação da Comunicabilidade (MAC) que é baseado em observação. O foco é avaliar a comunicação entre o designer e o user por meio da interface. Sempre que o user não compreender o que foi proposto pelo designer ou não souber expressar sua vontade por meio do sistema, dizemos que houve uma ruptura de comunicabilidade.  A maneira de investigação é baseada em 13 etiquetas com frases que simulam o que um user diria diante das situações experimentadas:  Cade?E agora?O que é isso?Epa!Onde estou?O que houve?Por que não funciona?Assim não dáVai de outro jeitoNão, obrigadoPra mim está bomSocorro!Desisto  Comentário De todos os assuntos, esse ai foi o que eu achei mais estranho. Talvez precisaremos expandir mais essa seção mas por hora, é o que temos.  Avaliação da Acessibilidade​  No quesito acessibilidade, queremos que a interface tenha os requisitos necessários dispositivos na análise Web Content Accessibility Guidelines (WCAG). Esse método de avaliação possui quatro princípios que devem ser observados nas interfaces:  Percepção: Alternativas em texto para todo conteúdo não textualAlternativas multimídia dinâmica e temporalConteúdo apresentável em diferentes formas sem perda da informação ou estruturaFacilitação a percepção visual e auditiva por meio da separação entre planos de fundo e primeiro plano Operação: Garantir que toda funcionalidade esteja disponível a partir do tecladoTempo de leitura de conteúdo suficienteEvitar formas de exibição que podem provocar convulsõesFacilitar a navegação, localização de conteúdos e localização das informações Compreensão: Conteúdo textual legível e compreensívelPáginas web funcionaisAuxíliar à correção de erros Robustez: Maximizar a compatibilidade com utilizadores atuais e futuros  Teste de Usabilidade​  O teste de usabilidade é um tipo de avaliação por observação e costumam responder perguntas sobre o funcionamento do sistema.  Durante o teste de usabilidade, cada tarefa realizada é medida para se obter dados como:  Grau de sucesso da execuçãoTotal de erros cometidosQuantos erros por tipo ocorreramTempo necessário para a conclusão  A coleta das informações pode variar de acordo com a vontade do designer. Pode variar desde observação visual simples até instrumentalização por meio de instrumentos.  Antes de se realizar o teste, é necessário definir as tarefas a serem executadas, qual o perfil de usuário, recrutamento dos usuários, material para observação, execução do teste-piloto a ser feito na seção de uso. Essa é a etapa de preparação do teste.  Após isso, passamos para a etapa de coleta dos dados por meio da aplicação dos testes e coleta das performances de uso.  Por fim, temos a interpretação e consolidação dos resultados que nos permite sumarizar os dados afim de tirarmos conclusões úteis sobre eles.  Investigação da Usabilidade​  Por fim, vamos aprender um pouco sobre a avaliação da usabilidade4 por meio da análise System Usability Scale (SUS) que usa o modelo de avaliação por investigação. Como já aprendemos, esse tipo de avaliação permite a interação do user com o sistema ou algum representante dele.  O SUS foi criado em 1986 e utiliza um questinário de 10 questões aplicadas após o uso do sistema ou do conhecimento sobre como ele funciona.  As questões aplicadas são:  Eu acho que gostaria de usar esse sistema com frequênciaEu acho o sistema desnecessariamente complexoEu achei o sistema fácil de usarEu acho que o precisaria de ajuda com conhecimentos técnicos para usar o sistemaEu acho que as funções do sistema são bem integradasEu acho que o sistema apresenta muita inconsistênciaEu imagino que as pessoas aprenderão como usar o sistema rapidamenteEu achei o sistema atrapalhado de usarEu me senti confiante ao usar o sistemaEu precisei aprender várias coisas novas antes de conseguir usar o sistema  Onde para cada item, temos as seguintes opções baseadas na escala Likert de resposta:  Discordo completamenteDiscordo parcialmenteNão concordo nem discordoConcordo parcialmenteConcordo completamente  Para a compilação usamos o seguinte cálculo de pontuação: 1) para as questões ímpares, subtraia 1 ponto da pontuação respondida; 2) para os itens pares subtraia 5; 3) Some todos os pontos; 4) multiplique por 2,5. A pontuação variará entre 0 a 100.  Um resultado esperado médio gira em torno de 68 pontos. Abaixo de 50 é sinal de problemas que podem indicar insucesso na solução.  Fontes Complementares::  Trabalho de conclusão de curso que avalia um aplicativo empregando o método SUS: SAPFI: um sistema de alerta para evitar aglomerações em filas de espera de praças de alimentaçãoLinks para um site externo. link.Trabalho de conclusão de curso que avalia um sistema empregando o método SUS: Proposta, Prototipação e Avaliação de Aplicação para Colaboração e Compartilhamento entre TorcedoresLinks para um site externo. link.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Design de Interação","url":"/CC_site/docs/puc/segundo-periodo/design-interacao#bibliografia","content":" BENYON, David. Interação Humano-Computador - 2ª edição. Pearson 466 ISBN 9788579361098.PADUA FILHO, Wilson de Paula. Multimídia conceitos e aplicações. 2. Rio de Janeiro LTC 2010 ISBN 978-85-216-1993-2.ROGERS, Yvonne; PREECE, Jennifer; SHARP, Helen. Interaction Design: beyond human-computer interaction, 5rd Edition. Wiley (O’Reilly). May 2019. ISBN: 9780470665763.COLBORNE, Giles. Simple and Usable Web, Mobile, and Interaction Design, Second Edition. New Riders (O’Reilly). ISBN: 9780134778181.PEREZ, Clotilde; BARBOSA, Ivan Santo. Hiperpublicidade, v. 1. Fundamentos e interfaces. São Paulo Cengage Learning 2018. ISBN 9788522116294 (Recurso online).    Footnotes​ Information Arquiteture, não confundir com AI (Artificial Inteligence). ↩ Por exemplo, usando uma base de dados de teste. ↩ Do inglês Windows, Icons, Menus and Pointing Devices. ↩ Eu não faço ideia do motivo de termos a seção anterior chamada &quot;Teste de usabilidade&quot; a agora termos a seção &quot;Investigação da usabilidade&quot; mas vamos lá. ↩ ","version":"Next","tagName":"h2"},{"title":"Fundamentos de Redes de Computadores","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/segundo-periodo/redes-computadores","content":"","keywords":"","version":"Next"},{"title":"Introdução às Redes de Computadores​","type":1,"pageTitle":"Fundamentos de Redes de Computadores","url":"/CC_site/docs/puc/segundo-periodo/redes-computadores#introdução-às-redes-de-computadores","content":" ","version":"Next","tagName":"h2"},{"title":"Conceitos Básicos​","type":1,"pageTitle":"Fundamentos de Redes de Computadores","url":"/CC_site/docs/puc/segundo-periodo/redes-computadores#conceitos-básicos","content":" Terminologia​  Tipos de Redes de Computadores​  Topologias de Redes​  Padronização de Redes​  ","version":"Next","tagName":"h3"},{"title":"Hardware de Rede​","type":1,"pageTitle":"Fundamentos de Redes de Computadores","url":"/CC_site/docs/puc/segundo-periodo/redes-computadores#hardware-de-rede","content":" Sinais​  Sinais Compostos e Largura de Banda​  Modulação​  Multiplexação​  Meios de Transmissão​  ","version":"Next","tagName":"h3"},{"title":"Modelos de Camadas​","type":1,"pageTitle":"Fundamentos de Redes de Computadores","url":"/CC_site/docs/puc/segundo-periodo/redes-computadores#modelos-de-camadas","content":" ","version":"Next","tagName":"h2"},{"title":"Modelo OSI​","type":1,"pageTitle":"Fundamentos de Redes de Computadores","url":"/CC_site/docs/puc/segundo-periodo/redes-computadores#modelo-osi","content":" Introdução​  Camadas Físicas e de Enlace​  Camadas de Rede e Transporte​  Camadas de Sessão, Apresentação e Aplicação​  ","version":"Next","tagName":"h3"},{"title":"Modelo TCP/IP​","type":1,"pageTitle":"Fundamentos de Redes de Computadores","url":"/CC_site/docs/puc/segundo-periodo/redes-computadores#modelo-tcpip","content":" Introdução​  Camada de Interface​  Camada de Internet​  Camada de Transporte​  Camada de Aplicação​ ","version":"Next","tagName":"h3"},{"title":"Desenvolvimento Mobile","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/terceiro-periodo/desenvolvimento-mobile","content":"","keywords":"","version":"Next"},{"title":"Fundamentos de Computação Móvel​","type":1,"pageTitle":"Desenvolvimento Mobile","url":"/CC_site/docs/puc/terceiro-periodo/desenvolvimento-mobile#fundamentos-de-computação-móvel","content":" ","version":"Next","tagName":"h2"},{"title":"Fundamentos​","type":1,"pageTitle":"Desenvolvimento Mobile","url":"/CC_site/docs/puc/terceiro-periodo/desenvolvimento-mobile#fundamentos","content":" Características de Aplicações Móveis​  Antes de aprendermos como desenvolver uma aplicação móvel na prática, pensemos um pouco sobre o que é uma aplicação móvel? Quais são as características dessas aplicações?  Podemos definir como aplicação móvel, qualquer solução de software desenvolvida para ser executada em dispositivos portáteis, normalmente, dotados de capacidade de comunicação com internet.  Existem algumas características que precisamos atender para o desenvolvimento de uma aplicação móvel efetiva:  Portabilidade: Nesse quesito, precisamos nos atentar ao tamanho e peso do dispositivo bem como dos seus acessórios. Isso é especialmente relevante no desenvolvimento de jogos em consoles portáteis como nintendo switch.Usabilidade: Existem vários tipos de pessoas que podem usar nossas aplicações. Pensando nessas realidade, precisamos nos ater às características relacionadas aos usuários que são nosso público alvo, as características do ambiente em que nossos usuários utilizarão e, por fim, as características do dispositivo que será usado para acesso ao nosso software.Funcionalidade: Normalmente, somos capazes de agrupar os aplicativos em dois grupos. O primeiro são aplicativos que operam de forma autônoma (sem necessidade de contato com servidores externos). O segundo grupo, se refere aos apps que consomem requisições para servidores.Conectividade: Não é estranho supor que a principal característica das aplicações móveis da atualidade é a sua conectividade a serviços externos. Essa comunicação pode ser feita de forma constante ou intermitente. Além disso, existem as aplicações inteiramente baseadas em dados locais no dispositivo do usuário.  Arquitetura de Aplicações Móveis​  Parecido com o que vimos na matéria de desenvolvimento web backend. Vamos aprender um pouco mais sobre a arquitetura das soluções web móveis.  A primeira parte que a gente aprendeu sobre arquitetura pode ser encontrada na matéria de desenvolvimento é back end. Dessa maneira vamos nos ater apenas à arquitetura de aplicações móveis.  O modelo mais usado de arquitetura de aplicações móveis é o modelo cliente e servidor. Nesse modelo, Temos a figura do banco de dados E da aplicação que se comunicam por meio da internet.  Comentário Isso mesmo lembra bastante a maneira como um site funciona. A principal diferença é que ao invés do navegador aqui temos o aplicativo.  Tipos de cliente​  Podemos separar os tipos de clientes em 2 grupos:  Thin Clients: Esse tipo de cliente depende muito pouco do hardware que o aplicativo rodará. Normalmente, usamos um navegador para acesso à aplicação. Esse tipo de cliente torna A manutenção das aplicações muito mais fáceis. O único ponto fraco desse tipo de cliente é que a aplicação só funcionará com acesso constante à internet.Fat Clients: Ao contrário dos clientes magros, os clientes gordos podem aceitar períodos de interrupção da comunicação entre a aplicação e o servidor. O problema é que o hardware que o roda a aplicação é muito relevante. Tornando o desenvolvimento e a manutenção do software específicos para cada aparelho em que a aplicação é instalada.  Tipos de Servidores​  Da mesma maneira que podemos separar os clientes em 2 categorias, podemos separar os servidores em 3 categorias baseada em camadas:  Arquitetura de uma camadaArquitetura de duas camadasArquitetura de três camadas  Nos 3 casos nós temos a existência de 3 áreas de atuação do servidor. Temos a camada de banco de dados, a de apresentação e a aplicação. No servidor de uma camada nós temos essas 3 interfaces funcionando no mesmo servidor. Por sua vez, no servidor de 2 camadas temos a separação entre o banco de dados e a aplicação com a apresentação do outro lado. Por fim, no servidor de 3 camadas temos a especialização em 3 máquinas diferentes para cada uma dessas atividades.  Como sempre não existe gabarito. Quanto mais camadas, mais controle sobre aplicação teremos, entretanto, O desenvolvimento será mais difícil e mais caro. Inversamente,o servidor de uma camada é muito mais fácil de desenvolver e manter sendo a customização do seu ponto fraco.  ","version":"Next","tagName":"h3"},{"title":"Ambiente de Desenvolvimento​","type":1,"pageTitle":"Desenvolvimento Mobile","url":"/CC_site/docs/puc/terceiro-periodo/desenvolvimento-mobile#ambiente-de-desenvolvimento","content":" Basicamente, existem 2 maneiras de se desenvolver uma aplicação mobile.  A primeira maneira é o desenvolvimento nativo que, no caso do Android é feito utilizando a linguagem Java/Kotlin, e, no ambiente a IOS, é feito com Swift ou Objective-C.  A segunda maneira é o desenvolvimento híbrido. Nesse caso, desenvolvemos uma aplicação usando uma linguagem e, em uma fase posterior, convertemos essa aplicação para o ambiente IOS ou Android.  Nessa matéria, usaremos a abordagem do desenvolvimento híbrido utilizando a tecnologia React Native que é inteiramente baseada em JavaScript.  Comentário Se você precisar de um reforço de JavaScript, nós temos uma parte da disciplina de desenvolvimento web front end que ensina o básico sobre ela.  React Native​  O nome React Native não é atoa. Podemos separar esse conceito em 2. O primeiro, React, se refere a um framework em JavaScript para construção de interfaces de usuário. O segundo, native, é uma alusão ao fato que, uma vez que a aplicação é construída, ela pode ser traduzida para código nativo de cada plataforma.  Comentário Não podemos achar que o React possibilita desenvolvimento fullstack de aplicações em JavaScript. Ela é uma biblioteca para criação de interfaces de usuário. Nada mais do que isso.  Crash Course em React​  Não tem jeito, para entender bem React Native precisamos entender pelo menos o básico do React.  Aqui em baixo temos, literalmente, o tutorial da documentação oficial do React com os principais componentes que precisam ser apreendidos.  Se preferir, pode ler o mesmo material nesse link.    O ideal é ter lido, pelo menos, toda essa parte de main concepts.  Crash Course em React Native​  Da mesma maneira que fizemos com o material do react, vamos colocar aqui em baixo o tutorial do React Native.  Se preferir, o mesmo material está disponível neste link.    Ferramentas de Desenvolvimento​  Agora que aprendemos um pouco sobre o que é o react e o react native, vamos aprender como desenvolver aplicações utilizando essas ferramentas.  No decorrer dessa disciplina, nós vamos utilizar um ambiente de desenvolvimento virtual Expo. A vantagem desse ambiente está no fato de podermos desenvolver as aplicações inteiramente no ambiente web e testar, em tempo real, o resultado das nossas alterações do código.  Uma vez com a conta criada, podemos usar a sessão de snacks para criar aplicações que rodam na própria interface do Expo.  Estrutura Padrão de um Projeto React Native​  Ao criar um snack no Expo a gente consegue perceber a estrutura básica de um projeto construído em React Native. No diretório do projeto, podemos ver 2 pastas (uma assets e uma components), um arquivo JS (que será o principal, normalmente chamado de App.js), um arquivo JSON (com as dependências do projeto) e um arquivo de README em markdown.  - assets/ - components/ | - AssetExample.js - App.js - package.json - README.md   Comentário Podemos rodar a aplicação que estamos desenvolvendo também no nosso próprio smartphone baixando o aplicativo do Expo no nosso celular. O app que temos que baixar é o Expo Go.  Mesmo Expo criando automaticamente um padrão de pastas, nós vamos utilizar o mesmo padrão que o professor usou na construção do projeto da disciplina.  - src/ | - components/ | - pages/ | - HomePage.js - App.js - package.json - README.md   Com essa nova estrutura, temos uma aplicação simples. Essa vai ser a aplicação que a gente vai evoluir ao longo de todo o microfundamento.  React Native Paper​  Da mesma maneira que o bootstrap facilita muito a construção de interfaces web com os componentes de visualização previamente construídos, podemos usar o react native paper para os componentes da nossa aplicação mobile.  Essa ferramenta é construída em cima dos componentes padronizados do Google Material Design.    React Native Local​  Para aqueles que (assim como eu) preferem o desenvolvimento localmente é possível configurar Um ambiente de desenvolvimento rodando o React Native localmente.  Abaixo temos um tutorial do Rocketseat explicando o passo a passo.    ","version":"Next","tagName":"h3"},{"title":"Desenvolvimento de Aplicações Móveis​","type":1,"pageTitle":"Desenvolvimento Mobile","url":"/CC_site/docs/puc/terceiro-periodo/desenvolvimento-mobile#desenvolvimento-de-aplicações-móveis","content":" Agora que sabemos o básico da teoria, vamos colocar em prática no desenvolvimento de uma aplicação. Nosso objetivo é desenvolver uma aplicação focada na gestão de combustível utilizando react native e o react native paper.  Comentário Eu não gostei da maneira como a parte prática foi ministrada nesse microfundamento da PUC. O professor focou demais em mostrar como o ecossistema possui funcionalidades então foi um showcase de componentes desnecessariamente. Em virtude disso, eu vou ter que ir atrás de um projeto coeso que tenha começo, meio e fim. Então os que tiverem pressa no assunto desse material, pode ir direto na bibliografia abaixo ou os materiais da primeira parte.  ","version":"Next","tagName":"h2"},{"title":"Bibliografia​","type":1,"pageTitle":"Desenvolvimento Mobile","url":"/CC_site/docs/puc/terceiro-periodo/desenvolvimento-mobile#bibliografia","content":" Bass, Len; Clements, Paul; Kazman, Rick. Software Architecture in Practice, Third Edition. Addison-Wesley Professional, 2012.Boduch, Adam; Derks, Roy. React and React Native - Third Edition. Packt Publishing. 2020.Ingeno, Joseph. Software Architect's Handbook. Packt Publishing, 2018.Richards, Mark; Ford, Neal. Fundamentals of Software Architecture. O'Reilly Media, Inc., 2020.Valentino Lee, Heather Schneider, Robbie Schell. Mobile Applications: Architecture, Design, and Development. Pearson. 2004. ","version":"Next","tagName":"h2"},{"title":"Algoritmos e Lógica de Programação","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica","content":"","keywords":"","version":"Next"},{"title":"Lógica de Programação e Estrutura de Controle, Funções e Procedimentos​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#lógica-de-programação-e-estrutura-de-controle-funções-e-procedimentos","content":" ","version":"Next","tagName":"h2"},{"title":"Conceito de Algoritmo​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#conceito-de-algoritmo","content":" Em resumo, um algoritmo é uma sequência de ordens que, se seguidas, deve gerar um resultado previsto e desejado. Não vale muito a pena aprofundar além disso agora.  ","version":"Next","tagName":"h3"},{"title":"Variáveis​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#variáveis","content":" Uma variável é uma posição na memória do computador. Isso mesmo, é algo com endereço definido, nada solto no universo ou obscuro dentro da máquina. Esse dado é gravado para posterior leitura por parte do programa que está sendo executado.  Podemos ter como origem do dado o próprio programa que está sendo executado ou o usuário por meio da entrada de dados ou, ainda, a leitura de dados previamente armazenados na memória do computador.  Cada variável possui vários tipos de atributos que podemos elencar na lista abaixo:  Tem um endereço na memóriaPossui um nome de identificaçãoArmazena um valorPossui um tipo de dados: Numérico - Inteiros e Reais (Double ou Ponto Flutuante)1Não numérico - Lógico e CaractereArranjos - Vetores e MatrizesArquivosetc  O endereço da memória é feita pelos endereços que possuem apenas 2 estágios de registro: 0 ou 1. Um bit é exatamente essa medida de registo. 1 byte é composto de 8bits. 1 kilobyte contém 1024bytes (2102^{10}210). 1 megabyte contém 1024KB (2202^{20}220). 1 gigabyte contém 1024MB (2302^{30}230). 1 terabyte possui 1024GB (2402^{40}240).  Ou seja, se um computador possui 3 gigas de memória RAM, ele tem 3 bilhões de bytes como endereços disponíveis para um registro na memória2. Cada byte possui um endereço único. Na memória RAM costuma-se usar a base Hexadecimal para definir os endereços. Vamos ver isso melhor na matéria de Arquitetura de Computadores.  Também vimos que as variáveis possuem identificadores. Em c# existem regras para a criação dos identificadores:  Devem começar com uma letraNão podem ter espaçosNão podem usar uma das palavras reservadas pela linguagemÉ case sensitive, ou seja, o nome &quot;Var&quot; é diferente do nome &quot;var&quot;  O identificador deve sempre ter algum sentido que permita a rápida interpretação por parte de algum leitor do código fonte da aplicação. Isso é fundamental para manutenção de códigos produzidos por várias pessoas diferentes. Entretanto, devemos evitar nomes de variáveis muito grandes. Na verdade, quanto menor o nome, mantido o sentido na leitura, melhor.  Outra boa prática é usar o camelCase para variáveis com mais de uma palavra. Esse padrão é bem simples: primeira palavra em minúsculo e a segunda com a primeira letra em maiúscula.  Declaração de Variáveis em c#​  Vamos aprender agora como declarar os 4 tipos mais simples de variáveis:  int para definir inteirosdouble ou float para definir números reaisstring para cadeia de caracteresbool para as variáveis booleanas (true ou false)  Comentário C# é uma linguagem fortemente tipada, entretanto, existe um tipo de tipagem implícita que é muito usado na prática onde o próprio compilador &quot;interpreta&quot; o tipo de variável. Ao longo desse microfundamento nós vamos usar apenas os tokens de tipagem explícita. Mas vale muito a pena a leitura da documentação oficial nesse link.  static void Main(string[] args) { int idade, numero; double peso, salario; string nomePai, rua, dtNasc; bool temCasa; }   Nesse código acima temos a declaração de várias variáveis de cada tipo. Basta colocar o tipo da variável seguido do nome de cada uma delas separadas por vírgula.  Comentário Em c# todas as linhas precisam conter um carácter de encerramento que é o ponto e vírgula ;. Sem esse token, o computador vai interpretar a próxima linha como sendo a continuação da anterior.  ","version":"Next","tagName":"h3"},{"title":"Etapas de um Algoritmo e Operador de Atribuição​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#etapas-de-um-algoritmo-e-operador-de-atribuição","content":" Podemos resumir um algoritmo simples como contendo apenas 3 etapas: 1) A entrada de dados; 2) O processamento e 3) A saída de dados.  Na etapa de processamento, podemos precisar de grande criatividade e esforço para produzir a saída de dados desejada. Como ferramenta para alcance desse objetivo, temos as estruturas básicas que são:  Estrutura Sequencial - Usada para garantir a ordem correta dos passosEstrutura Condicional - Usada para permitir contexto ou cenáriosEstrutura de Repetição - Usada para evitar repetir código sequencial  Operador de Atribuição​  Uma vez que já sabemos como atribuir uma variável ao seu tipo, precisamos aprender a como atribuir um valor a essas variáveis. Em c# a atribuição de valor é feita do seguinte modo:  idade = 28; numero = 9992233;   É possível fazer 3 tipos de atribuição de valor para uma variável: Valor fixo; Conteúdo de outra variável e Expressão aritmética ou booliana. Abaixo temos 3 exemplo disso.  idade = 28; // Valor fixo numero = idade; // Valor de outra variável idadeNum = idade + numero; // Valor por expressão idadeEqNum = idade == numero; // Valor por expressão booliana   Nesse ponto vale uma reflexão. Será que sempre precisamos separar as etapas de atribuição do tipo de dados e do valor? Ou podemos, no mesmo momento, definir o tipo de dados e o valor da variável? A resposta, para nossa sorte, é que é possível em c# atribuição de tipo e valor ao mesmo tempo. A sintaxe fica desse modo:  int idade = 28; int numero = idade; double = 2.3; string nome = &quot;bruno&quot;; int idadeNum = idade + numero; bool idadeEqNum = idade == numero;   Saídas de Dados​  Agora que fizemos esse pequeno desvio no assunto, vamos retornar para as estruturas. Por incrível que pareça, é melhor a gente começar pelo final. A etapa de saída de dados.  Em c# temos duas maneiras de saída de dados:  // Imprime a informação e cursor fica na mesma linha Console.Write('string'); // Imprime a info mas o curso vai pra proxima linha Console.WriteLine('string ' + var1 + ' string');   Nesses exemplos a gente pode perceber que podemos concatenar textos e variáveis textuais por meio do operador de soma. Além dessa forma, podemos fazer uso de PlaceHolders ou Interpolação de string como nos exemplos abaixo.  string nome = &quot;Bruno&quot;; // Concatenação Console.WriteLine(&quot;Meu nome é &quot; + nome + &quot;, obrigado!&quot;); // PlaceHolder Console.WriteLine(&quot;Meu nome é {0}, obrigado!&quot;, nome); // Interpolação Console.WriteLine($&quot;Meu nome é {nome}, obrigado!&quot;);   Os três exemplos geram o mesmo resultado mas são consideravelmente diferentes no método. Podemos usar o que for mais agradável para uma leitura do código e posterior manutenção do mesmo.  Entrada de Dados​  Agora que sabemos como fazer nosso programa imprimir resultados, vamos aprender como inputar dados nele. Em c# podemos inserir dados com o seguinte comando:  variavel = Console.ReadLine();   O input captado por esse comando sempre retorna uma string. Mas as vezes precisamos nos certificar que o input foi feito da maneira correta. Para isso podemos manipular os dados inseridos do seguinte modo:  // Valores Inteiros variavel = int.Parse(Console.ReaLine()); variavel = Convert.ToInt32(Console.ReadLine()); // Valores Reais variavel = double.Parse(Console.ReadLine()); variavel = float.Parse(Console.ReadLine()); variavel = Convert.ToDouble(Console.ReadLine()); // Valores Booleanos variavel = bool.Parse(Console.ReadLine()); // Valores String variavel = Console.ReadLine();   Depois que executamos um dessas maneiras de coletar os dados, é de boa prática fornecermos um output logo após a entrada do dado. Isso evita aquela sensação de dúvida se o programa está sendo executado ou não. Ou seja, é bom sempre manter a dupla ReadLine() com o WriteLine(). O nome que damos para essa dupla é &quot;Prompt&quot;.  Outra dica boa é usar o comando Console.ReadKey() no final do programa. Isso faz com que o console aguarde alguma tecla para finalizar. Evita que a aplicação abra e feche sem que o user consiga enxergar o resultado do processo.  ","version":"Next","tagName":"h3"},{"title":"Estrutura Sequencial​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#estrutura-sequencial","content":" Agora que sabemos como receber valores do usuário e como devolver nova informação a partir do processamento, vamos começar a estudar a etapa de processamento através do estudo das estruturas sequenciais.  Operadores e Funções Aritméticas​  Em c# nós temos os seguintes tokens para realizar as operações aritméticas:  + Soma- Subtração* Multiplicação/ Divisão% Resto da Divisão inteira  Além disso, temos a presença do que podemos chamar de operadores de atribuição combinada. Que faz a atribuição de valor com alguma operação aritmética:  soma += 100 é igual a soma = soma + 100subtracao -= 10 é igual a subtracao = subtracao - 10multiplica *= 2 é igual a multiplica = multiplica * 2divide /= 3 é igual a divide = divide / 3resto \\%= 2 é igual a resto = resto / 2  Não bastando essa grande variedade, temos os operadores de incremento e decremento:  Pré-incremento (++x) - Usa x + 1 antes do processamentoPós-incremento (x++) - Usa x + 1 após o processamentoPré-decréscimo (--x) - Usa x - 1 antes do processamentoPós-decréscimo (x--) - Usa x -1 após o processamento  Essa diferença de pre e pós é importante para as estruturas de repetição, porque podemos lidar com índices de tabelas que começam com valores diferentes. Mas, no geral, devemos olhar cada caso para escolher o que usar.  Existem outras operações que estão contidas em um objeto nativo chamado Math. Para fazermos potenciação usamos o método Math.Pow(). Para fazermos raiz quadrada podemos usar Math.Sqrt()3.  Expressões Aritméticas​  Agora podemos juntar tudo que vimos em um programa simples de cálculo da média de 5 valores. O código e o seu resultado podem ser vistos abaixo.  // Declaração dos tipos das variáveis int n1, n2, n3, n4, n5, soma; float media; // Input dos dados Console.WriteLine(&quot;Programa para cálculo da média de 5 valores.&quot;); Console.WriteLine(&quot;Por favor, forneça o primeiro número&quot;); n1 = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(&quot;Por favor, forneça o segundo número&quot;); n2 = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(&quot;Por favor, forneça o terceiro número&quot;); n3 = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(&quot;Por favor, forneça o quarto número&quot;); n4 = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(&quot;Por favor, forneça o quinto número&quot;); n5 = Convert.ToInt32(Console.ReadLine()); // Processamento soma = n1 + n2 + n3 + n4 + n5; media = soma / 5; // Output dos dados Console.WriteLine(&quot;Os números fornecidos foram:&quot;); Console.WriteLine(&quot;N1={0},N2={1},N3={2},N4={3},N5={4}&quot;, n1, n2, n3, n4, n5); Console.WriteLine(&quot;Cuja média é igual a {0}&quot;, media);     Outro exemplo que podemos usar é o do cálculo das raízes de uma função de segundo grau4. O programa abaixo recebe 3 valores e calcula as raízes, a imagem logo após nos mostra o resultado no prompt de comando.  // Programa para calcular o valor de x em uma equação de segundo grau // Declaração das variáveis double a, b, c, x1, x2; Console.WriteLine(&quot;Vamos resolver uma equação do tipo ax^2 + bx + c = 0&quot;); // Input das variaveis Console.WriteLine(&quot;Qual o valor de a? &quot;); a = Convert.ToDouble(Console.ReadLine()); Console.WriteLine(&quot;Qual o valor de b? &quot;); b = Convert.ToDouble(Console.ReadLine()); Console.WriteLine(&quot;Qual o valor de c? &quot;); c = Convert.ToDouble(Console.ReadLine()); x1 = (-b + Math.Sqrt(Math.Pow(b,2) - 4 * a * c)) / 2 * a; x2 = (-b - Math.Sqrt(Math.Pow(b, 2) - 4 * a * c)) / 2 * a; // Output dos resultados Console.WriteLine(&quot;Dados: a = {0}, b = {1} e c = {2}&quot;, a, b, c); Console.WriteLine($&quot;Equação: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0&quot;); Console.WriteLine(&quot;Resultado: x1 = {0} e x2 = {1}&quot;, x1, x2);     A essa altura já aprendemos como criar programas inteiros com as etapas de software que vimos anteriormente: input, processamento e output. Tudo isso em c#. Entretanto, no estado atual do código, nossos programas não estão muito competentes em se adaptar a diferentes tipos de inputs ou resultados.  Um exemplo prático é que, nesse segundo programa, podemos ter inputs que retornem um resultado indesejado como podemos ver na imagem abaixo.    ","version":"Next","tagName":"h3"},{"title":"Estrutura Condicional​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#estrutura-condicional","content":" A necessidade de lidarmos com diferentes situações ou contextos é o que nos leva a estudarmos as estruturas condicionais. Por meio dessas estruturas, podemos construir diferentes outputs de acordo com qualquer lógica que implementarmos e, com isso, evitar vários bugs nos nossos programas.  Operadores Relacionais​  Ao lidarmos com estrutura condicionais nós temos alguns operadores que nada mais são do que expressões lógicas que retornam apenas 2 resultados possíveis: true ou false. Esses operadores são como &quot;gatilhos&quot;\\ que são usados para controle do fluxo de processamento do código.  Operador\tOperação\tExemplo==\tIgualdade\tn1 == n2 &lt;\tMenor\ta &lt; 10 &gt;\tMaio\tb &gt; 1 &lt;=\tMenor igual\tc &lt;= 2 &gt;=\tMaior igual\td &gt;= 22 !=\tDesigualdade\te != 100  Na tabela acima, temos os operadores relacionais que são usados ao longo das estruturas condicionais simples e compostas.  Tome cuidado com o operador de igualdade == e o de atribuição =, afinal, eles usam o sinal de igualdade mas significam coisas diferentes.  Condição Simples e Composta​  Em c# o comando usado para criar uma condição simples é o if. Se a condição que colocarmos atrelada ao comando if retornar um true, o bloco de código atribuído a ele será executar, caso contrário, o código do bloco será ignorado.  // Parte condicional no calculo da equação de segundo grau delta = (Math.Pow(b, 2) - 4 * a * c); // Output dos resultados com condição if (delta &gt;= 0) { Console.WriteLine(&quot;Dados: a = {0}, b = {1} e c = {2}&quot;, a, b, c); Console.WriteLine($&quot;Equação: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0&quot;); Console.WriteLine($&quot;Delta: {delta}&quot;); Console.WriteLine(&quot;Resultado: x1 = {0} e x2 = {1}&quot;, x1, x2); }; if (delta &lt; 0) { Console.WriteLine(&quot;Dados: a = {0}, b = {1} e c = {2}&quot;, a, b, c); Console.WriteLine($&quot;Equação: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0&quot;); Console.WriteLine($&quot;Delta: {delta}&quot;); Console.WriteLine(&quot;Resultado: X não possui raiz real! &quot;); };   Com essa adaptação, nosso código estará preparado para o caso onde o interior da raiz (que chamamos de delta) seja negativo. Mas podemos ver que o nosso código ficou um pouco esquisito. Criamos dois blocos de código que são, claramente, relacionados entre si: Se um bloco for executado, o outro não será. Para facilitar o trabalho com essas situações, as linguagens de programação possuem as estruturas de condição compostas.  Esses são os casos onde, se o teste lógico retorna true, executamos um bloco, ou o outro bloco será executado caso o resultado lógico seja false. Com isso evitamos ter que criar dois testes com if. O token usado em c# para uma condição com dois blocos de códigos (ou seja, uma condicional composta) é o if-else. Abaixo nós reescrevemos a solução anterior mas agora fazendo uso do condional composto.  // Parte condicional no calculo da equação de segundo grau delta = (Math.Pow(b, 2) - 4 * a * c); // Output dos resultados com condição if (delta &gt;= 0) { Console.WriteLine(&quot;Dados: a = {0}, b = {1} e c = {2}&quot;, a, b, c); Console.WriteLine($&quot;Equação: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0&quot;); Console.WriteLine($&quot;Delta: {delta}&quot;); Console.WriteLine(&quot;Resultado: x1 = {0} e x2 = {1}&quot;, x1, x2); } else { Console.WriteLine(&quot;Dados: a = {0}, b = {1} e c = {2}&quot;, a, b, c); Console.WriteLine($&quot;Equação: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0&quot;); Console.WriteLine($&quot;Delta: {delta}&quot;); Console.WriteLine(&quot;Resultado: X não possui raiz real! &quot;); };   Agora sim nosso código está elegante e adaptado para as duas saídas possíveis de resultado para os inputs do usuário.  Operadores Booleanos e Comandos IF Aninhados​  Nós aprendemos que o bloco de código será executado sempre que a expressão lógica retornar um resultado true. Também vimos que existem os operadores relacionais que nos ajudam a construir essas expressões. Agora, vamos aprender os operadores booleanos que nada mais são do que os operadores lógicos clássicos (∧,∨,¬\\land, \\lor, \\neg∧,∨,¬).  Operador\tOperação\tExemplo&amp;&amp; (AND)\ttrue se tudo for true\tif (a &gt; 2 &amp;&amp; b == 1) (OR)\ttrue se um for true\tif (a &lt; 2b != 0) ! (NOT)\tfalse se true\tif (!(x==y))  Existem problemas que requerem mais de dois resultados no output. Nesse caso, não é suficiente usarmos apenas os tokens de condicional composto if-else da maneira como aprendemos até agora.  Para resolver esse problema temos a técnica de IF aninhados (nested) e a de IF escada (ladder). As duas formas produzem o mesmo resultado mas mudam significativamente legibilidade do nosso código. Abaixo temos um exemplo de cada.  // Leadder IF if (condicao1) comando1; else if (condicao2) comando2; else if (condicao3) comando3; ... else if (condicao_n-1) comando_n-1; else comando_n;   // Nested IF if (condicao1) comando1; else if (condicao2) comando2; else if (condicao3) comando3; else if (condicao4) comando4; ... else if (condicao_n-1) comando_n-1; else comando_n;   O Comando Switch e o Operador Ternário​  Agora que aprendemos a lidar com vários casos condicionais encadeados, podemos construir soluções relativamente complexas com várias saídas diferentes. Entretanto, quando tempos muitas situações possíveis, o nosso código pode ficar um pouco ruim de ser lido por outras pessoas.  Pensando nessa necessidade, os criadores do c# criaram um operador que simplifica ainda mais nosso trabalho. Sim, é isso mesmo, nós acabamos de aprender IFs aninhados e em escada e já vamos aprender uma maneira melhor de fazer exatamente o que eles fazem. Se acostume com isso. Em tecnologia existem quase sempre várias maneiras de se chegar no mesmo resultado.  O operador que é mais indicado para lidar com várias situações de saída é o switch-case. Cuja construção é bem mais legível que os IFs anteriores. Abaixo temos um exemplo.  // Lidando com varias condições com switch/case switch(opcao) { case op1: comandos1; break; case op2: comandos2; break; case op3: comandos3; break; ... case op_n: comandos_n; break; default: // bloco que sera executado se nenhuma // das anteriores for escolhida; }   Comentário Existem várias maneiras de se usar o switch. Eu não vou me aprofundar agora em todas elas. Mas vale muito a pena fazer uso dessa ferramenta para cenários de várias interações possíveis ou múltiplas saídas contextuais.  Para finalizar o nosso estudo das estruturas condicionais, vamos aprender como trabalhar com o Operador ternário. Esse nome é relativo ao número de operandos que esse comando usa (no caso, 3).  condicao ? expressao_true : expressao_false   A condição é uma expressão lógica (que usa operadores relacionais e booleanos) que só pode retornar true ou false. A expressão logo após o ponto de interrogação será o retorno do operador em caso de true. A expressão após os dois pontos é o retorno em caso de false.  Sim, é exatamente um caso de if-else só que em apenas uma linha. Como as soluções podem ficar muito grandes, é sempre bom termos em mente que quanto menos linhas, mais fácil será fazer manutenção nos nossos programas. O operador ternário é muito usado por programadores mais experientes. Abaixo temos um exemplo comparando as duas maneiras.  // Comparação entre if-else e operador ternário bool passou; double nota; // if-else if (nota &gt;= 60) passou = true; else passou = false; // operador ternario passou = nota &gt;= 60 ? true : false // maneira 1 passou = (nota &gt;= 60) ? true : false // maneira 2   Agora podemos ver claramente a vantagem do uso do operador ternário.  ","version":"Next","tagName":"h3"},{"title":"Estrutura de Repetição​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#estrutura-de-repetição","content":" Como sabemos, ainda temos mais um tipo de estrutura para estudarmos. Até agora, aprendemos como estruturar um código sequencialmente e como criar blocos de código que só serão executados se determinadas condições previamente definidas forem satisfeitas. Agora, vamos aprender como evitar ter que repetir blocos de códigos.  O c# possui 3 operadores de repetição:  // tipo 01 while (condicao) comando; // tipo 02 do comando; while (condicao); // tipo 03 for (inicial; expressao logica; atualizacao) comando;   Vamos ver um exemplo de como nosso código pode ser reduzir com o uso da estrutura de repetição. Primeiro, vamos ver um exemplo onde o programa recebe uma lista de 3 palavras (nome, nome do meio e sobrenome) e depois faz o print.  // Programa que recebe nome completo e // depois devolve uma mensagem de boas vindas string nome, mid, last; Console.WriteLine(&quot; Seja bem vindo(a)!&quot;); Console.WriteLine(&quot; Qual seu primeiro nome?&quot;); nome = Console.ReadLine(); Console.WriteLine(&quot; Qual seu nome do meio?&quot;); mid = Console.ReadLine(); Console.WriteLine(&quot; Qual seu sobrenome?&quot;); last = Console.ReadLine(); Console.WriteLine(&quot; Bem Vindo(a)!&quot;); Console.WriteLine(nome); Console.WriteLine(mid); Console.WriteLine(last); Console.WriteLine(&quot; E Volte sempre!&quot;);     Agora vamos refazer esse programa usando os 3 tokens de estrutura de repetição que o c# nos dá. Vamos usar a mesma ordem em que elas foram apresentadas.  Os Comandos WHILE, DO WHILE e FOR​  Repetição usando WHILE​  A repetição usando o token while é condicionada ao resultado de uma expressão lógica. Caso a expressão lógica retorne true, o bloco de código será executado até o seu final. Após a execução, é feita uma nova verificação da expressão lógica. O processo de loop só será finalizado caso a expressão lógica retorne o valor false. Abaixo temos a refatoração5 evitando a repetição de partes de partes do código anterior.  // Programa de nomes refatorado com while string nome, mid, last; int contador; // nome default nome = &quot;&quot;; mid = &quot;&quot;; last = &quot;&quot;; Console.WriteLine(&quot; Seja bem vindo(a)!&quot;); Console.WriteLine(&quot; Por favor, insira o seu nome completo.&quot;); Console.WriteLine(&quot; Obs. No máximo 3 palavras&quot;); contador = 1; while (contador &lt;= 3) { Console.WriteLine($&quot; Palavra nº {contador} do seu nome?&quot;); if (contador == 1) nome = Console.ReadLine(); else if (contador == 2) mid = Console.ReadLine(); else if (contador == 3) last = Console.ReadLine(); contador += 1; }; Console.WriteLine(&quot; Bem Vindo(a)!&quot;); Console.WriteLine(nome); Console.WriteLine(mid); Console.WriteLine(last); Console.WriteLine(&quot; E Volte sempre!&quot;);   Agora nós temos um loop usando a expressão &quot;a variável contador é menor igual a 3?&quot; sempre que a resposta for sim, o programa perguntará qual a n-ésima palavra do nome da pessoa. Pode parecer que nesse exemplo o uso do loop mais complicou do que facilitou. Mas o objetivo aqui é exercitar o uso desse operador, então devemos focar em compreender como usar o while.  Repetição usando DO-WHILE​  Para a nossa sorte, o operador DO WHILE é muito similar ao WHILE. A única diferença é que primeiro declaramos o bloco de código e, no final, colocamos a condição para sua execução. No exemplo abaixo temos o mesmo resultado que o de cima mas usando essa outra estrutura de operador.  // Programa de nomes refatorado com do-while string nome, mid, last; int contador; // nome default nome = &quot;&quot;; mid = &quot;&quot;; last = &quot;&quot;; Console.WriteLine(&quot; Seja bem vindo(a)!&quot;); Console.WriteLine(&quot; Por favor, insira o seu nome completo.&quot;); Console.WriteLine(&quot; Obs. No máximo 3 palavras&quot;); contador = 1; do { Console.WriteLine($&quot; Palavra nº {contador} do seu nome?&quot;); if (contador == 1) nome = Console.ReadLine(); else if (contador == 2) mid = Console.ReadLine(); else if (contador == 3) last = Console.ReadLine(); contador += 1; } while (contador &lt;= 3); Console.WriteLine(&quot; Bem Vindo(a)!&quot;); Console.WriteLine(nome); Console.WriteLine(mid); Console.WriteLine(last); Console.WriteLine(&quot; E Volte sempre!&quot;);   Repetição usando FOR​  Quando usamos nosso operador while, foi criada uma variável contador que era incrementada a cada iteração até que o teste lógico &quot;menor igual a 3&quot;\\ retorne false. A vantagem do operador de loop for é que podemos fazer isso diretamente no parâmetro da função.  O operador de loop for recebe 3 parâmetros, na ordem: condição inicial da variável de controle; expressão lógica (que retorna true ou false) e, por fim, um incremento ou decremento.  // Programa de nomes refatorado com for string nome, mid, last; int contador; // nome default nome = &quot;&quot;; mid = &quot;&quot;; last = &quot;&quot;; Console.WriteLine(&quot; Seja bem vindo(a)!&quot;); Console.WriteLine(&quot; Por favor, insira o seu nome completo.&quot;); Console.WriteLine(&quot; Obs. No máximo 3 palavras&quot;); contador = 1; for (contador = 1; contador &lt;= 3; contador++) { Console.WriteLine($&quot; Qual a palavra nº {contador} do seu nome?&quot;); if (contador == 1) nome = Console.ReadLine(); else if (contador == 2) mid = Console.ReadLine(); else if (contador == 3) last = Console.ReadLine(); }; Console.WriteLine(&quot; Bem Vindo(a)!&quot;); Console.WriteLine(nome); Console.WriteLine(mid); Console.WriteLine(last); Console.WriteLine(&quot; E Volte sempre!&quot;);   Contadores e Acumuladores​  Agora sabemos reduzir nossos códigos usando 3 tipos de tokens fornecidos pelo c#. Vamos ver um pouquinho mais a respeito do atributo de contador do loop for.  Um contador nada mais é do que uma variável do tipo constante que receberá a atualização do seu valor a cada loop. Se a situação inicial do nosso contador for igual a 1, a cada iteração ele receberá a expressão contador = contador + 1.  Podemos criar um contador diretamente no código através da atribuição do valor pela soma. Ou, podemos usar os operadores de incremento e decremento que aprendemos anteriormente. A cada iteração em uma estrutura de loop, a variável receberá +1 como incremento ou -1 no caso do decremento.  Podemos usar o operador de incremento tanto no bloco de código de um loop quanto como parâmetro. Em um for, quando colocamos o terceiro parâmetro igual a contador++, a cada iteração teremos +1 atribuído ao contador.  Um acumulador é muito parecido com um contador, a diferença é que a cada iteração nós podemos adicionar qualquer valor ao acumulador. Por exemplo, se queremos calcular a média de uma turma, teremos que somar todas as notas e dividir pelo quantitativo dos alunos da turma. Para isso, podemos criar um acumulador chamado soma_notas que recebe, para cada aluno, a nota através de um comando parecido com o exemplo a baixo.  double soma_notas = 0; for (n_aluno=0; n_alunos &lt;= qtd; n_aluno++) { soma_notas = soma_notas + nota };   A cada iteração, somamos o valor da variável nota à variável soma_notas.  ","version":"Next","tagName":"h3"},{"title":"Manipulação de Dados em Memória Primária e Secundária​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#manipulação-de-dados-em-memória-primária-e-secundária","content":" Ao longo do material nós usamos várias vezes frases como &quot;a medida que nosso código cresce&quot; ou &quot;para manter a simplicidade no processo de atualização&quot; e outras frases de mesmo teor. Isso não é em vão. Quando olhamos os códigos dos sistemas operacionais, por exemplo, podemos ver que a quantidade de linhas de código passam da casa do milhão. Manter tudo isso funcionando de modo coeso e atualizável é uma tarefa que demanda muita habilidade e planejamento.  Para nos ajudar nesse trabalho, vamos aprender sobre métodos de organização de código através do uso de funções e procedimentos.  ","version":"Next","tagName":"h2"},{"title":"Criando e Usando Funções e Procedimentos​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#criando-e-usando-funções-e-procedimentos","content":" Normalmente, quando estamos desenvolvendo uma solução de software, primeiro nós criamos um algoritmo que descreve os pormenores o que será feito e como será feito. Essa primeira etapa é focada na solução do problema.  A partir dela, devemos pensar em encontrar procedimentos que se repetem ao longo do código ou que podem ser usados para outros trabalhos similares. Sempre que identificarmos padrões que podem ser reutilizados, estamos diante de uma melhoria por modularização.  A modularização (também chamada de sub-rotinas ou sub-programas) é a prática de reduzir o nosso código em partes menores que recebem nomes diferentes dependendo da linguagem. Em linguagens orientadas à objeto como o c# nós chamamos de modularização.  A ideia é simples: menos linhas, mais fácil será a manutenção. Esse é um valor muito caro no meio do desenvolvimento profissional de software e devemos ter sempre essa postura em mente.  Existem dois tipos de métodos para modularização: funções, que sempre retornam algum valor, e procedimentos que não retornam nenhum valor. Abaixo vemos como criar esses dois tipos.  // criando uma função que retorna um inteiro int nome_metodo(string par1, float par2,..., int parn) { int valor_resultado; comando1; ... return valor_retorno; }; // criando um procedimento static void nome_procedimento (string par1, double par2,..., int parn) { comando1; ... };   Podemos ver que um procedimento em c# recebe esse tokenvoid antes de ser criado (ainda não aprenderemos o que significa esse termostatic).  Para usarmos um parâmetro não precisamos fazer nenhuma atribuição, basta chamar-lo com os seus parâmetros preenchidos e atribuídos ao tipo de variável correto. No caso de uma função, como ela retorna um resultado, precisamos atribuir o resultado a alguma variável. Abaixo temos um exemplo de como usar cada um desses métodos.  // chamando um procedimento nome_procedimento(par1,par2); // chamando um método resultado = nome_metodo(par1,par2);   Comentário Se não queremos usar nenhum parâmetro, basta definir o procedimento ou o método com os parênteses vazios, por exemplo,nome_procedimento().  A essa altura você já deve ter percebido que um procedimento nada mais é que um tipo de método. Só que ele possui uma regra diferente na hora da criação e não pode ter seu resultado atribuído a nenhuma variável. Desse modo, a modularização faz uso de dois métodos possíveis.  ","version":"Next","tagName":"h3"},{"title":"Passagem de Parâmetros​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#passagem-de-parâmetros","content":" Os parâmetros são variáveis que podem ser transferidos (também dizemos que eles são &quot;passados&quot;) para que o nosso método seja executado. Esses serão os valores que o nosso método vai receber e processar.  Podemos classificar os parâmetros em dois tipos: Formais, que são definidos na declaração (ou criação) do método e são trabalhados dentro do bloco de código interno a ele como se fossem variáveis novas; e os Reais, que são passados para o método no momento da invocação e serão atribuídos aos parâmetros formal como representantes das variáveis reais.  Quanto a passagem desses parâmetros, também temos duas nomenclaturas: Passagem por valor que é quando o parâmetro real é compilado para o parâmetro formal sem alteração do seu valor original e a Passagem por referência em que a manipulação feita dentro do bloco de código é espelhada nas variáveis de referência fora do nosso método.  Quando usamos a passagem por valor, estamos usando os parâmetros do tipo formais. Quando usamos a passagem por referência estamos usando os parâmetros reais.  int a = 5, b = 7; // exemplo de passagem por valor static void passagemValor(int x, int y) { int temp = x; x = y; x = temp } passagemValor(a,b); Console.Write($&quot;a = {a} e b = {b}&quot;); &gt; a = 5 e b = 7 // exemplo de passagem por referência static void passagemRef(ref int x, ref int y) { int temp = x; x = y; y = temp; } passagemRef(ref a, ref b); Console.Write($&quot;a = {a} e b = {b}&quot;); &gt; a = 7 e b = 5   Dicas e Boas Práticas​  o método Main() é uma função especial de um programa escrito em c#. Ele é automaticamente executado quando o programa é iniciado e todos os outros métodos estão contidos dentro dele.    Um método deve ser o menor possível. Se o objetivo é simplificar, devemos evitar ao máximo ter grandes blocos de código dentro de um método. Se está grande demais, não seria melhor quebrar em métodos menores?  Sempre devemos colocar nomes relevantes e esclarecedores.  Devemos evitar ter métodos com um número muito elevado de parâmetros. Cabe a mesma lógica sobre o tamanho: não seria melhor quebrar em mais métodos?  Agora que aprendemos mais sobre o métodos e boas práticas, podemos entender bem melhor a estrutura padrão de uma aplicação em c#.  using System; public class Program { public static void Main() { Console.WriteLine(&quot;Hello World&quot;); } }   Ainda não sabemos tudo que está nesse template padrão de programa em c# mas, definitivamente, já podemos dizer que entendemos algumas coisas desse código.  ","version":"Next","tagName":"h3"},{"title":"Manipulação de Arquivos em C#​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#manipulação-de-arquivos-em-c","content":" Aprendemos que um programa pode ser separado em 3 etapas e, até agora, todo o input da informação bem como o output está sendo feito via janela do terminal ou prompt de comando. Mas na vida real, é super raro (se é que acontece) de um usuário leigo ter que ficar usando o terminal para interagir com aplicações.  Uma outra maneira de coletarmos informação como input para o nosso processamento é por meio da leitura de arquivos e, consequentemente, também podemos ter como output do nosso código a escrita de um arquivo na memória do computador.  Para facilitar nossa vida, o c# já possui algumas classes (que podemos pensar como se fossem sinônimos de objetos) que foram criadas especialmente para lidar com esse trabalho. Essas classes de manipulação de arquivos estão guardadas em um namespace chamado System.IO6  As classes que aprenderemos aqui são:  StreamReader - Para criação de um fluxo de leitura do arquivo para o programaStreamWriter - Para criação de um fluxo de saída ou gravação do programa para o arquivo  A manipulação feita por um programa em um arquivo é, basicamente uma dessas operações abaixo:  Abrir para escritaAbrir para leituraEscrever dados no arquivoLer dadosFechar o arquivo  Agora o termo &quot;fluxo&quot; começa a ficar mais claro. Para um programa trabalhar um arquivo, ele precisa sinalizar para o sistema operacional que aquele arquivo está sendo trabalhado por ele. Por isso existe esse fluxo de abrir o fluxo, ler ou gravar dados e, por fim, fechar o fluxo. Isso libera o arquivo para ser usado por outros programas.  Abrir um arquivo para leitura​  Um arquivo não pode ser lido usando um instanciamento (que é a criação de uma variável do tipo de um objeto definido previamente) através do objeto StreamReader. Esse objeto é nativo e pode ser invocado sem precisar ser criado anteriormente. E, como todo objeto, possui métodos dentro dele (10 pra ser mais preciso) mas nós só vamos usar o mais básico.  // abrindo um arquivo para a leitura StreamReader NOME = new StreamReader(&quot;path.txt&quot;); StreamReader NOME = new StreamReader(&quot;c:\\temp\\path.txt&quot;); StreamReader NOME = new StreamReader(@&quot;c:\temp\\path.txt&quot;);   Agora que temos nosso objeto criado, para lermos o conteúdo só precisamos usar um dos métodos contidos nesse objeto criado.  // obtendo o texto string linha = NOME.ReadLine(); // ler todas as linhas de um arquivo linha = NOME.ReadLine(); while (linha != null) { ... linha = NOME.ReadLine(); };   Abrir um arquivo para escrita​  // criando o objeto de leitura em diferentes modos StreamWriter NOME = new StreamWriter(&quot;path.txt&quot;); StreamWriter NOME = new StreamWriter(&quot;c:\\temp\\path.txt&quot;); StreamWriter NOME = new StreamWriter(@&quot;c:\temp\\path.txt&quot;);   Qualquer arquivo que possa ser lida em um editor de texto (como o notepad) pode ser lida por esse método. Independente da extensão.  // usando o parâmetro append (true ou false) // conteúdo existente sera apagado StreamWriter NOME = new StreamWriter(&quot;path.txt&quot;,false); // conteúdo existente sera mantido StreamWriter NOME = new StreamWriter(&quot;path.txt&quot;,true);   Agora só precisamos saber como gravar os nossos dados no arquivo de texto. Isso é feito de maneira parecida com o comando que mostrava mensagens na tela do terminal de comando.  // gravando uma string no arquivo texto aberto arquivo.Write(string); // ou arquivo.WriteLine(string);   Fechando um Arquivo​  Para fechar o stream, seja na leitura ou na gravação, usamos o método Close() para garantir que o arquivo não vai ficar bloqueado por um esquecimento. Sempre devemos fechar os fluxos!  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Algoritmos e Lógica de Programação","url":"/CC_site/docs/puc/primeiro-periodo/algoritmo-logica#bibliografia","content":" Ana Fernanda Gomes ASCENCIO; Edilene Aparecida Veneruchi de CAMPOS. Fundamentos da Programação de Computadores: algoritmos, Pascal, C/C++ e Java - 2ª edição. São Paulo, SP : Pearson Education do Brasil, 2012H. DEITEL et. Al. C#: Como Programar. São Paulo: Makron Books, 2003John SHARP. Microsoft Visual C# 2013. Grupo A, 2014André Luiz Villar FORBELLONE, Henri Frederico EBERSPÄCHER. Lógica de programação: a construção de algoritmos e estruturas de dados. São Paulo: Prentice Hall, 2005.MANZANO, José Augusto N. G; OLIVEIRA, Jayr Figueiredo de. Algoritmos: lógica para desenvolvimento de programação de computadores 28. ed. rev. e atual. São Paulo, SP: Érica, 2016Sandra PUGA, Gerson RISSETTI. Lógica de Programação e Estrutura de Dados: com aplicações em Java - 2ª edição. São Paulo : Pearson, 2017    Footnotes​ Float possui precisão simples e Double possui dupla precisão. ↩ Isso é muito impressionante! ↩ Embora a gente saiba que a radiciação é uma potência de fração. ↩ Se você não se lembra como resolver um problema desse, seu professor da sexta série está rindo de você nesse exato minuto. ↩ Refatorar é o processo de mudar o código e obter o mesmo resultado no final. É uma ótima prática a ser feita. ↩ IO significa Input/Output. ↩ ","version":"Next","tagName":"h2"},{"title":"Estatística Descritiva","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/terceiro-periodo/estatistica-descritiva","content":"","keywords":"","version":"Next"},{"title":"Bibliografia​","type":1,"pageTitle":"Estatística Descritiva","url":"/CC_site/docs/puc/terceiro-periodo/estatistica-descritiva#bibliografia","content":" ANDERSON, David Rayetal. Estatística aplicada a administração e economia. 4. ed. São Paulo: Cengage Learning, 2019. E-book. ISBN 9788522128006. FONSECA, Jairo Simonda. Curso de estatística. 6. São Paulo Atlas 2012 ISBN 9788522477937. TRIOLA, Mario F. Introdução à estatística. 12. ed. Rio de Janeiro: LTC - Livros Técnicos e Científicos, c2017. E-book. ISBN 9788521634256. COSTA, Giovani Glaucio de Oliveira. Curso de estatística básica. 2. São Paulo Atlas 2015 1 recurso on-line ISBN 9788522498666. LARSON, Ron; FARBER, Elizabeth. Estatística aplicada. 6. ed. São Paulo: Pearson Education do Brasil, c2016. E-book. ISBN 9788543004778. LEVINE, David M.; STEPHAN, David; SZABAT, Kathryn A. Estatística: teoria e aplicações usando Microsoft Excel em português. 7. ed. Rio de Janeiro, RJ: LTC - Livros Técnicos e Científicos, c2016. E-book. ISBN 9788521631972. MOORE, DavidS.; NOTZ, William; FLIGNER, Michael A. A estatística básica e sua prática. 7. ed. Rio de Janeiro: LTC, c2017. E-book. ISBN 9788521634294. MORETTIN, Pedro Alberto; BUSSAB, Wilton de Oliveira. Estatística básica. 9. ed. São Paulo: Saraiva, c2017. E-book. ISBN 9788547220228. ","version":"Next","tagName":"h2"},{"title":"Gerência de Configuração","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-configuracao","content":"","keywords":"","version":"Next"},{"title":"Planejamento da Configuração e Controle de Mudanças​","type":1,"pageTitle":"Gerência de Configuração","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-configuracao#planejamento-da-configuração-e-controle-de-mudanças","content":" ","version":"Next","tagName":"h2"},{"title":"Introdução à GCS​","type":1,"pageTitle":"Gerência de Configuração","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-configuracao#introdução-à-gcs","content":" Eu não sei para vocês, mas para mim, o nome Gerência de Configuração de Software (GCS) me parece muito curioso.  Normalmente, configuração é algo que pensamos ser apenas uma coisa relacionada a alguns aspectos de como uma aplicação deve funcionar1.  Importância da Gestão de Configuração​  O Gerenciamento de Configuração de Software (GCS) está relacionado com as políticas, processos e ferramentas para gerenciamento de mudanças dos sistemas de software, contemplando algumas atividades que fazem parte da gestão de qualidade do software.  É papel do GCS alinhar e permitir que existam várias versões em desenvolvimento simultaneamente sem que isso acarrete em perdas e retrabalho demasiados. Para permitir essa gestão complexa, existem vários padrões de gerenciamento de configuração, tais como o ISO 9000, CMM e CMMI.    Atividades da GC​  A primeira coisa que precisamos entender é que a GCS é uma subarea da Engenharia de Software.  As principais atividades da GCS são as seguintes:  Controle de Versão: Processo de manter o controle de versões de componentes e dos sistemas de software usados.Construção de Sistema: Processo de build de um sistema executável, compilado que interliga todos os componentes, bibliotecas e informações de modo coeso e útil.Gerenciamento de Mudanças: Controle das mudanças causadas em um software para garantir o foco nas urgências e custo-benefício das mesmas.Gerenciamento de Lançamentos\\Releases: Gestão dos releases de modo a controlar os lançamentos segundo seu grau de importância.  Com esse panorama, somos capazes de olhar o diagrama abaixo (que mostra o modelo RUP) e observarmos como e porquê a GCS é variável em esforço de acordo com a fase do projeto.    ","version":"Next","tagName":"h3"},{"title":"Processo de Gerenciamento de Mudanças​","type":1,"pageTitle":"Gerência de Configuração","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-configuracao#processo-de-gerenciamento-de-mudanças","content":" Planejamento do Processo de GCS e Etapas da Identificação e do Planejamento​  Podemos afirmar que um processo de software pode ser dividido em 3 categorias principais:  Programas de computador (código fonte ou executáveis)Artefatos que descrevem os programasDados\\Conteúdo  Basicamente, todo o nosso trabalho como desenvolvedores sempre envolverá essas 3 realidades de modo inexorável. Para efeitos didáticos, podemos separar as atividades de GCS em 2 grupos, um no lado da execução e outro no planejamento.  Durante o processo de planejamento da configuração, temos uma série de etapas que ditam e ordenam os processos e produtos gerados para uma correta implementação da GCS dentro de uma empresa:  Baseline (guia geral do projeto)RepositórioControle de Mudança e ConfiguraçãoEstimativa de Status de ConfiguraçãoIdentificação dos MarcosTreinamentos e Recursos  Durante todas essas atividades temos a criação de documentos relacionados ao processo de controle de alterações. Podemos destacar:  Documento de arquiteturaDocumento de implantaçãoPlano de gerenciamento de configuraçãoDocumento de permissões de pastas e acessos por perfilDocumento de controle de baselinesDocumento de negócioPlano do projetoPlanilha de contagem de ponto de funçãoDocumento de processo de negócioChecklist de revisão técnicaRelatório de revisão técnicaPlano de testePlano de resultado de testeRoteiro de testeEspecificação de casos de uso  Controle de Mudança​  No controle de mudanças temos vários conceitos que vale a pena termos um local para consulta posterior.  Termo\tExplicaçãoItem de configuração ou item de configuração de software (SCI, do inglês software configuration item)\tQualquer coisa associada a um projeto de software (projeto, código, dados de teste, documentos, etc.) que tenha sido colocado sob controle de configuração. Muitas vezes, existem diferentes versões de um item de configuração. Itens de configuração têm um nome único. Controle de configuração\tO processo de garantia de que versões de sistemas e componentes sejam registradas e mantidas para que as mudanças sejam gerenciadas e todas as versões de componentes sejam identificadas e armazenadas por todo o tempo de vida do sistema. Versão\tUma instância de um item de configuração que difere, de alguma forma, de outras instâncias desse item. As versões sempre têm um identificador único, o qual é geralmente composto pelo nome do item de configuração mais um número de versão. Baseline\tUma baseline é uma coleção de versões de componentes que compõem um sistema. As baselines são controladas, o que significa que as versões dos componentes que constituem o sistema não podem ser alteradas. Isso significa que deveria sempre ser possível recriar uma baseline a partir de seus componentes. Codeline\tUma codeline é um conjunto de versões de um componente de software e outros itens de configuração dos quais esse componente depende. Commit\tEnvio de uma mudança ao repositório. Mainline\tTrata-se de uma sequência de baselines que representam diferentes versões de um sistema. Release\tUma versão de um sistema que foi liberada para os clientes (ou outros usuários em uma organização) para uso. Espaço de trabalho\tÉ uma área de trabalho privada em que o software pode ser modificado sem afetar outros desenvolvedores que possam estar usando ou modificando o software. Branching\tTrata-se da criação de uma nova codeline de uma versão em uma codeline existente. A nova codeline e uma codeline existente podem, então, ser desenvolvidas independentemente. Merging\tTrata-se da criação de uma nova versão de um componente de software, fundindo versões separadas em diferentes codelines. Essas codelines podem ter sido criadas por um branch anterior de uma das codelines envolvidas. Construção de sistema\tÉ a criação de uma versão de sistema executável pela compilação e ligação de versões adequadas dos componentes e bibliotecas que compõem o sistema.  ","version":"Next","tagName":"h3"},{"title":"Gerenciamento de Versões e Releases​","type":1,"pageTitle":"Gerência de Configuração","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-configuracao#gerenciamento-de-versões-e-releases","content":" Elementos de Gerenciamento de Versões e Gerenciamento de Releases​          ","version":"Next","tagName":"h3"},{"title":"Gerenciamento de Entregas e Ferramentas de Gerenciamento de Configuração​","type":1,"pageTitle":"Gerência de Configuração","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-configuracao#gerenciamento-de-entregas-e-ferramentas-de-gerenciamento-de-configuração","content":" ","version":"Next","tagName":"h2"},{"title":"Integração, Entrega e Implantação Contínuas​","type":1,"pageTitle":"Gerência de Configuração","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-configuracao#integração-entrega-e-implantação-contínuas","content":" Integração contínua​  Integração contínua (CI - Continuous Integration) é o processo de engenharia de software que está sendo amplamente utilizado no movimento DevOps para isolar as mudanças para que elas possam ser imediatamente testadas e relatadas quando são adicionadas à base de código maior.  O processo de integração contínua é fundamental para a implementação do DevOps. A palavra DevOps é originada a partir da composição dos prefixos Dev (desenvolvimento) e Ops (operações). Ele inclui a automação do desenvolvimento e teste sempre que as alterações no código são feitas.  A metodologia de integração contínua permite que você compartilhe o código e teste fazendo as mudanças no repositório de controle de versão compartilhada. Desta forma, qualquer um pode obter a versão mais recente do código. Isso ajuda a construir, testar e validar o processo completo. DevOps é a união de pessoas, processos e tecnologias para fornecer continuamente valor aos clientes.    Entrega e implantação contínua​  A entrega contínua (CD – Continuous Delivery) permite que as equipes de desenvolvimento automatizem o processo que move o software pelo ciclo de vida de desenvolvimento de software e pode fornecer muitos benefícios ao provisionar uma caixa de ferramentas integrada, incluindo o seguinte:  Reduza o tempo de implantação por meio de testes e desenvolvimento contínuos;Diminua os custos associados ao desenvolvimento de software tradicional;Dimensione o desenvolvimento de software com base no tamanho do projeto;Implante o código automaticamente em cada fase do ciclo de desenvolvimento.  A implantação contínua (CD - Continuous Deployment) é uma estratégia de desenvolvimento de software em que as alterações de código em um aplicativo são liberadas automaticamente no ambiente de produção. Essa automação é impulsionada por uma série de testes predefinidos. Depois que as novas atualizações passam nesses testes, o sistema envia as atualizações diretamente para os usuários do software.  A implantação contínua oferece vários benefícios para empresas que buscam dimensionar seus aplicativos e portfólio de TI. Primeiro, ele acelera o tempo de lançamento no mercado, eliminando o atraso entre a codificação e o valor do cliente – normalmente dias, semanas ou até meses.  Para conseguir isso, os testes de regressão devem ser automatizados, eliminando assim os caros testes de regressão manual. Os sistemas que as organizações implementam para gerenciar grandes pacotes de mudanças na produção – incluindo planejamento de lançamento e reuniões de aprovação – também podem ser eliminados para a maioria das mudanças.    ","version":"Next","tagName":"h3"},{"title":"Ferramentas de GCS​","type":1,"pageTitle":"Gerência de Configuração","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-configuracao#ferramentas-de-gcs","content":" Funções das Ferramentas de GCS​  À medida que a complexidade do desenvolvimento de softwares aumenta, faz-se cada vez mais necessária a implementação tanto de processos de GCS quanto de ferramentas que automatizem os processos. Com essa implementação, cada alteração no software fica vinculada a registros dentro das ferramentas de GCS, garantindo a rastreabilidade de todas as mudanças e maior qualidade nos serviços e produtos entregues. Assim, a GCS é importante para a garantia da qualidade de software, a sua verificação e a sua validação, bem como para as revisões e auditorias.  Controle de Versão com Git ou Subversion (SVN)​  Git e Subversion são duas ferramentas muito populares usadas para controle versão em projetos de software. O Git é um sistema de controle de versão distribuído que apresenta crescente adoção na comunidade de desenvolvimento de software em geral, especialmente após sua popularização através do serviço de hospedagem de códigos GitHub.  Utilização de Ferramentas para Controle de Versões de Software​  Nesse contexto, vale a pena dominar as ferramentas de controle de versão e, sem dúvida, GIT e Github.  Aqui tem um link de um curso do MIT sobre isso. link.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Gerência de Configuração","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-configuracao#bibliografia","content":" Sommerville, I., Engenharia de Software, Pearson, 10a. edição, 2019. Pressman, R. S., Maxim, B. R., Engenharia de Software – Uma abordagem - profissional, AMGH, 8a. edição, 2016. Malhone, M. M., Frigeri, M., A importância do gerenciamento de - configuração para o ciclo de vida do software: um estudo de caso - baseado nas diretrizes da engenharia de software, RBTI-Revista - Brasileira em Tecnologia da Informação, ISSN 2675-1828, v.3, n.1, - 2021. Gonçalvez, P. F., Barreto, J. S., Zenker, A. M., Fagundes, R. D. R., - Rocha, B. C., Birfeld, K., Weinfurter, M. R., Testes de Software e Gerência de Configuração, Grupo A, 2019. Filho, A. B. , Spínola, R. O., Costa, M. N., Kalinowski, M., Gerência de Configuração - Definições Iniciais, Ferramentas e Processos, Engenharia de Software Magazine, 2010.    Footnotes​ Como por exemplo, a configuração do app do whatsapp para mostrar ou não as notificações na tela bloqueada do seu smartphone. ↩ ","version":"Next","tagName":"h2"},{"title":"Modelagem de Dados","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados","content":"","keywords":"","version":"Next"},{"title":"Projeto de Banco de Dados​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#projeto-de-banco-de-dados","content":" ","version":"Next","tagName":"h2"},{"title":"Fundamentos de Banco de Dados​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#fundamentos-de-banco-de-dados","content":" Abordagem de Arquivos x Banco de Dados​  Podemos definir um banco de dados como:  Uma coleção de dados relacionados, persistentes1 [...] que tem por objetivo atender uma comunidade de usuários.  Dessa feita, podemos ver que antes de modelar e projetar nosso banco, temos que ter em mente o propósito de uso e sua real necessidade.  Outro conceito muito próximo é o de Sistema Gerenciador de Banco de Dados (SGBD):  Um software que incorpora as funções de definições, recuperação e alteração de dados em um BD  Ou seja, Banco de dados é um conceito com foco no conteúdo. Enquanto, SGBD é um conceito com foco na tecnologia que vai manipular o conteúdo armazenado (ex: MySQL, MSSQL, Firebird e etc).  O Passado​  Mas nem sempre existiu a abordagem de banco de dados. Antigamente, cada programa precisava ser responsável pelos próprios arquivos que persistiam as informações.  O modo de persistir dados era com enfoque de arquivos. Onde meio que tudo era salvo em plain text ou algum formato de texto estruturado como um csv da vida e os sistemas tinham que trabalhar com isso.  Desse modo, era praticamente impossível intercambiar informações entre aplicações porque não se tinha um template geral para consulta e persistência dos dados.  Isso gerava a necessidade de cada aplicação ter sua própria base (mesmo que a informação fosse comum à vários setores). Agora, imagine que existam 3 tabelas produto e que o valor de venda dele foi alterado. Existe uma chance real que algum time simplesmente esqueça de atualizar em uma das réplicas o que poderia causa graves prejuízos à empresa.  Tipos de Linguagens e Tipos de Profissionais​  Linguagens DDL E DML​  Já vimos que um banco de dados é relacionado ao conteúdo que será persistido para consulta posterior. Dessa feita, como tudo em tecnologia, precisamos de uma linguagem para interagir com o SGBD afim de criarmos as definições dos dados e manipular o que tivermos salvo.  Existem 2 tipos de linguagens que usamos para essa tarefa:  DDL (Data Definition Language): Usada para criar tabelas, criar visões, definir relações entre elas e as características de cada valor.DML (Data Manipulation Language): Muito mais usada na prática diária. É responsável por manipular (select, insert, delete, update) os dados persistidos. Pode ser de 2 tipos. Procedural: Onde o user define qual dado será acessado e como chegar nele. Mais usados em triggers e rotinas automáticas.Não Procedural: Onde define apenas qual dado acessar.  Comentário Ao longo dos estudos vamos nos deparar com um conceito chamado stored procedure e é exatamente isso que acabamos de ver acima.  Para aprofundar um pouco mais, abaixo temos dois exemplos de DML.  /* DML Procedural */ BEGIN DECLARE @EmployeeName VARCHAR(50); DECLARE @EmployeeId INT = 101; SELECT @EmployeeName = Name FROM Employees WHERE EmployeeID = @EmployeeId; PRINT @EmployeeName; END;   /* DML Não Procedural */ SELECT Name FROM Employees WHERE EmployeeID = 101;   Podemos ver que na DML não procedural, deixamos a cargo do motor da linguagem julgar qual melhor rota para acessar as informações que solicitamos2.  Principais atuantes em um projeto de BD​  Como papéis principais em um projeto de banco de dados, podemos destacar:  Administrador de Dados (AD) Arquiteta a estrutura de informação da empresaAdministra a descrição da base de dados3Define padrões de codificação (template de nome de tabela, campos e etc)Profundo conhecedor das regras de negócio Administrador de Banco de Dados (DBA) Foco na otimização e performanceGerencia o SGBDÉ responsável pela estrutura de armazenamento (migrations, carga de dados e etc) Analista de Sistemas/Engenheiro de Software/Desenvolvedor Constrói soluções que consomem o SGBDDeve procurar otimizar suas queries de modo a sempre custar pouco para o processamento do SGBD Usuário Final Podem ser tanto no nível operacional quanto gerencial  Níveis do SGBD e Etapas do Projeto de BD​  Níveis do SGBD​  Um SGBD pode ser divido em 3 níveis de abstração:  Nível Interno/Físico Atuação do DBA com foco no como os dados são armazenados em disco e como melhorar a performance de acesso aos mesmos. Nível Conceitual/Lógico Atuação do DA com foco em quais dados são salvos no BD e seus relacionamentos. Nível Externo/Visão Atuação de Devs e Users com objetivo de acessar os dados disponíveis. Sempre sendo necessário apenas uma parte do todo.  Info Abaixo temos dois conceitos derivados desses que acabamos de ver. Hoje em dia, podem parecer simples mas, no passado, a separação entre camadas físicas e lógicas eram bem menor do que hoje em dia.  Independência Física: Quando alterações na camada física não impactam a camada lógica.4  Independência Lógica: Quando alterações na camada lógica não impactam a camada física.  Etapas de um Projeto de BD​  Tal qual as etapas, durante a elaboração de um projeto de BD temos um estudo para cada camada, ou seja:  Projeto Conceitual Foco na informação, independente da implementação do SGBD.Definição dos tipos e das relações.Criação dos Modelos de Entidade-Relacionamento (MER). Projeto Lógico É nessa etapa que temos a definição das tabelas, relações de campos e chaves.Etapa onde é escolhido a classe do SGBD (Relacional, NoSQL, Redes e etc). Projeto Físico Implementação real no hardware.Definição do SGBD propriamente dito (Oracle, MySQL, MSSQL, MariaDB e etc)Quanto de recursos precisarão ser alocados bem como as políticas de backup.Criação dos Perfis de acesso.  ","version":"Next","tagName":"h3"},{"title":"Modelagem de Entidades e Relacionamentos (MER)​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#modelagem-de-entidades-e-relacionamentos-mer","content":" Modelagem de Entidades e Atributos​  Agora que sabemos os profissionais e os tipos de projetos de banco de dados, vamos entrar na teoria sobre a modelagem de dados propriamente dita.  Podemos conceituar a Modelagem de Dados como a conversão de fatos relevantes em estruturas bem definidas com regras de dependência expressas em um modelo gráfico e descritivo.  O foco aqui é em quais dados existirão no banco de dados, independente de como eles serão armazenados no SGBD.  Um dos modelos conceituais5 mais usados é o Modelo Entidade-Relacionamento (MER). Essa técnica permite demonstrar facilmente a relação descrita acima por meio de representações gráficas simples entre as entidades.  Diferentes tipos de notação​  No material didático dessa disciplina usamos a notação de Peter Chen como base. Entretanto, eu tenho um motor de geração de diagramas nativo na biblioteca que uso para construir esse site que segue a notação de James Martin.  Atenção A notação de James Martin tem alguns apelidos como &quot;IE Notation&quot; ou ainda &quot;Crow's Foot Notation&quot;.  O importante é sempre entender a lógica geral. Nesse artigo da wikipédia temos um exemplo de como podemos mostrar uma mesma relação de diferentes modos.    Dica Existem várias ferramentas para escrever esses tipos de diagramas. Aqui, eu vou usar a Mermaid Link da documentação.  Entidades e Atributos no MER​  Entidades são objetos do mundo real ou abstrações de informação.  Atributos são elementos que identificam as entidades e descrevem suas características.  Atributos podem ser de vários tipo, para nomear alguns:  Simples: CPF, Altura, Preço.Compostos: Compostos por partes, como Telefone = País + DDD + Numero.Monovalorados: Recebem 1 valor por entidade.Multivalorados: Vários valores por entidade.Derivados: IMC que é uma função da altura e peso.Chave: Valores distintos que podem ser usados para identificar as entidades.  Abaixo eu coloco um exemplo de entidade no modelo Crow's foot onde podemos ver que os atributos são definidos por tipo, nome e se é primary key no próprio retângulo da entidade. Na notação de Chen eles são elipses ligadas à entidade.    Para simplificar nosso material, eu vou omitir nas entidades os atributos sempre que possível assim cada entidade vai ser representada apenas por um retângulo com o nome. Mas lembre-se que na hora de fazer um MER de verdade as entidades devem estar sempre com seus atributos.  Atenção O conceito de atributo composto só se aplica ao modelo de Chen. No modelo de James nós somos obrigados a simplificar a notação para atributos simples (o que facilita a etapa de mapeamento em tabelas). O conceito de atributo multivalorado também se aplica somente ao modelo de Chen. No modelo de James nós somos obrigados a converter atributos multivalorados em uma nova entidade e criar uma ligação entre elas.  Modelagem de Relacionamentos​  Alguns conceitos importantes para a modelagem de relacionamentos:  Relacionamento é qualquer associação com significado entre uma ou várias entidades  Cardinalidade é a propriedade do relacionamento que expressa a quantidade de ocorrências. Por exemplo, 1-1, 1-n, n-n e etc.  Totalidade é a especificação da condição de existência entre classes de modo que uma só pode existir se o relacionamento com outra existe. Pode ser parcial/opcional ou total/obrigatória6.  Comentário Não sei você, mas, pra mim &quot;totalidade total&quot; é um nome bem ruim pra um conceito. Dessa feita, vou usar o termo &quot;totalidade obrigatória&quot; sempre que for me referir a essa propriedade.    Nós lemos esse diagrama acima da seguinte forma: Um departamento pode possuir entre 0 a N empregados. Similarmente, qualquer empregado só pode pertencer a um único departamento.  Mais um exemplo dado no curso:    Nesse segundo exemplo nós temos um esquema básico de uma faculdade. Podemos ver que um departamento pode ofertar N materias e essas matérias podem ser ofertada em N turmas. Um aluno, por sua vez, só pode pertencer a 1 único curso.  Modelo de Entidades e Relacionamentos Estendido​  Entidades Fracas e Relacionamentos Múltiplos​  Até agora já sabemos mostrar entidades, suas propriedades e suas relações com outras entidades. Agora vamos aprimorar mais um pouco nosso modelo representativo adicionando hierarquia entre entidades.  Entidade Forte: É qualquer entidade que existe por ela mesma e possui uma PK.  Entidade Fraca: É toda entidade que não tem chave própria, ou seja, precisa ser identificada por meio de um relacionamento com outra entidade e por um identificador fraco (chave parcial).  Relacionamentos Estendidos: São os relacionamentos entre mais de duas entidades (chamados de relacionamentos não binários).  Abaixo temos um exemplo de entidade fraca chamada transacao. Chamamos ela de entidade fraca porque ela precisa das chaves estrangeiras das contas para fazer sentido.    Agora vamos ver um exemplo mais complexo onde temos relacionamentos não binários.    Aqui podemos ver que um registro de funcionário precisa indicar tanto a cidade quanto o departamento para que seja possível saber sua lotação.  Atributos de Relacionamentos​  Na notação de Peter Chen também é possível derivar atributos dos relacionamentos igual fazemos com as entidades. A ideia é evidenciar quais dados surgem a partir da relação entre entidades.  Atributos de Relacionamentos: São atributos derivados da associação entre entidades e não são oriundos das entidades per se.  Aviso Essa derivação de atributos para relacionamentos só é encontrada no modelo de Chen. Dessa feita, vemos que a tendência do mercado é alocar esses atributos diretamente a uma classe.  Um exemplo de atributo de relacionamento pode ser encontrado na imagem abaixo.    Veja que o relacionamento OPOS tem um atributo diretamente nele. Mas isso causa uma certa dificuldade quando vamos pensar nas tabelas do SGBD pois temos que definir onde esse atributo do relacionamento será salvo.  Modelagem de Supertipos e Subtipos​  Algo comum de se deparar na construção de um modelo de banco de dados é relações de hierarquia entre as entidades. Desse modo, precisamos evoluir nosso modelo representativo para indicar classes gerais e classes específicas.  Comentário Essa é justamente a discussão que vimos na matéria de Programação Modular.  Generalização: Atributos de uma classe genérica/superclasse/supertipo que indica atributos comuns a uma gama de outras entidades.  Especialização: Processo de definir em detalhes uma classe genérica adaptando-a em casos mais concretos.  Na declaração de subtipos, devemos investigar como os tipos derivados podem ser classificados entre si.  Para os casos onde uma entidade só pode ser de um subtipo7 usamos o termo disjunção.  Para os casos onde podem haver mais de uma relação8 usamos o termo sobreposição.  Outra relação importante de se definir é se a superclasse precisa ser definida em termos de subclasse.  Se a classe geral tiver uso sem uma especialização, usamos o conceito de subtipo total.  Caso ela tenha uso mesmo sendo classe geral mas permita uma especialização, dizemos que ela é subtipo parcial.  Aviso Essa parte de subtipo e supertipo com classes total ou parcialmente separadas também só existe no modelo de Chen. Com o tempo, o mercado foi percebendo que &quot;menos é mais&quot; e tendeu para modelos que são mais fáceis de ler e entregam um resultado parecido em termos de compreensão.  Abaixo temos um diagrama que reflete a mesma ideia do pertencimento parcial usando o diagrama de Crow's foot mas lembre-se que isso é apenas para efeito didático.    O diagrama acima é uma aproximação de como o modelo de Chen trata a especificação das classes. A ideia é evidenciar que, dado um funcionário, ele só pode ser de um único subtipo ou do tipo genérico.  Em outras palavras, podemos ter um registro de funcionário genérico mas, também, especificado entre as outras 3 categorias.  Agora vamos ver um exemplo de completude total onde a especificação se torna obrigatória.    Nesse exemplo de uma concessionária de veículos, vemos que, dado um veículo, ele tem que pertencer obrigatoriamente há uma subcategoria.  Para encerrar essa parte, vamos ver um exemplo usando sobreposição ao invés de disjunção. No caso, modelamos o cenário de uma indústria que precisa controlar um insumo produtivo que pode vir tanto do seu estoque quanto do fornecedor.    ","version":"Next","tagName":"h3"},{"title":"Projeto de Banco de Dados Relacionais e Não Relacionais​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#projeto-de-banco-de-dados-relacionais-e-não-relacionais","content":" ","version":"Next","tagName":"h2"},{"title":"Modelo Relacional de Banco de Dados​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#modelo-relacional-de-banco-de-dados","content":" Surgiu em meados da década de 70 por E.F. Codd como uma definição puramente derivada da teoria de conjuntos da matemática.  Em 1974, a IBM tentou implementar através do Sistema R o primeiro SGBD capaz de usar a, então novidade, Linguagem de Consulta Estruturada ou Structured Query Language (SQL) para recuperação de dados.  Conceitos do Modelo Relacional e Chave Primária​  Agora vamos levantar alguns conceitos chaves do modelo relacional.  Relação é qualquer tabela de valores onde cada linha representa uma relação de valores relacionados a uma mesma entidade. Por isso o nome do modelo é Modelo Relacional.  Tupla são as linhas de uma relação (linhas na tabela) que são obrigatoriamente distintas entre si.  Atributo são o cabeçalho de cada coluna, também chamado de campo da tabela. A quantidade de atributos9 define o grau da relação.  Chamamos de Domínio qualquer conjunto de valores válidos10 para um atributo.  Atenção Não podemos confundir Domínio com Tipo Físico do atributo. Tipo físico é relacionado ao modo como a variável é salva no hardware (ex: string, int, float e etc). Domínio é a lista de valores aceitos no atributo.  Aqui temos um exemplo de implementação de domínio na prática  CREATE TABLE Funcionarios ( Nome VARCHAR(100) NOT NULL, Idade INT NOT NULL CHECK (Idade BETWEEN 18 AND 65), Departamento VARCHAR(50) NOT NULL CHECK (Departamento IN ('RH', 'TI', 'Financeiro')) );   Além dos conceitos acima, existem algumas regras que o modelo relacional adota implicitamente que são importante de se ter em mente:  Os valores dos atributos são atômicos ou seja, só existe 1 endereço para cada intersecção linha-coluna.No modelo relacional se admite o valor nulo que não é igual à string vazia ou zero.  Definições de chaves e Atributos Participante de chaves​  Podemos definir, usando notação de conjuntos, o conceito de superchave e chave em um esquema relacional.  Uma Superchave (superkey) de um esquema relacional R={A1,A2,...,An}R = \\{ A_1, A_2, ..., A_n \\}R={A1​,A2​,...,An​} é um conjunto de atributos S⊆RS \\subseteq RS⊆R que possui a propriedade que não existem duas tuplas t1t_1t1​ e t2t_2t2​ em qualquer relação autorizada rrr de RRR em que seja verdade que t1[S]=t2[S]t_1[S] = t_2[S]t1​[S]=t2​[S].  Uma Chave KKK é uma superchave com a propriedade adicional que, caso seja removido qualquer atributos de KKK, ela deixará de ser uma superchave.  A Chave Primária é a coluna (ou combinação delas) que define de maneira cabal a distinção entre entidades em uma dada tabela.  Comentário Aprofundaremos mais esse conceito quando vermos a parte de dependência funcional.  Para identificarmos uma chave primária basta nos perguntarmos se existe algum atributo que identifique toda a tupla de modo inequívoco.  Chave Primária Composta é a identificação criada a partir de mais de um atributo da relação (aka tabela).  Atenção Não podemos dizer algo como &quot;chaves primárias&quot; para o caso da chave composta porque o conceito de chave primária só admite singular. Mesmo que nossa chave seja feita através de múltiplas colunas.  Chave Alternativa é outra coluna que também pode ser usada como chave primária mas que foi preterida por outra.  Um Atributo Primário (Prime Attribute) é qualquer atributo que faça parte de alguma chave candidata.  Integridade Referencial e Chave Estrangeira​  A chave estrangeira nada mais é do que a implementação real de um relacionamento.  Chave Estrangeira ou **Foreign Key (FK) ** é a referência de uma chave primária em outra tabela de modo que contém o mesmo domínio de dados.  Com esse conceito, já podemos evoluir nosso entendimento de entidades em mais uma maneira de classificação das mesmas.  Para se garantir a integridade da relação, temos algumas regras que devem ser seguidas:  Integridade de Domínio: O domínio da FK deve ser o mesmo que o da PK a qual faz referência.Integridade de Entidade: Se existe uma FK, deve existir uma entidade na tabela de referência.Integridade de Chave: Não se admite duplicidade de PK.Integridade Referencial: A FK ou é um valor nulo ou um valor que obedece a relação PK(t1[FK]=t2[PK])PK(t_1[FK] = t_2[PK])PK(t1​[FK]=t2​[PK]).  Essas restrições acima são verificadas sempre que uma nova tupla (ou linha na tabela) é inserida.  No caso de exclusão ou atualização, podem haver situações que a manipulação da tupla que contenha uma PK referenciada em FK não é permitida forçando a adoção de algum saneamento. Temos três cenários possíveis:  ON DELETE/UPDATE SET NULL - Todas as FK serão mudadas para nulo.ON DELETE/UPDATE SET DEFAULT - Todas as FK adotam um valor default definido na DDL.ON DELETE/UPDATE CASCADE - Autoriza a propagação do delete em todas as referências.  Aviso Só use CASCADE junto com commit das mudanças na query porque você deve sempre ser capaz de reverter esse impacto gerado em caso de algo sair errado.  ","version":"Next","tagName":"h3"},{"title":"Mapeamento do Modelo de Entidades e Relacionamentos para Modelo Relacional​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#mapeamento-do-modelo-de-entidades-e-relacionamentos-para-modelo-relacional","content":" Mapeamento de Entidades e Atributos​  Até agora, nós estávamos focados em aprender os diagramas do modelo MER que mostram as entidades, seus atributos e seus relacionamentos. Mas no final desse trabalho, é necessário converter (ou mapear) essas entidades em tabelas.  Atenção A etapa de desenho das entidades, atributos e relacionamentos é chamada de Modelo Entidade Relacionamento (MER). Por sua vez, quando implementamos esse desenho em um SGBD nós temos um Modelo Relacional.  Na hora de mapear nossas entidades, existem algumas técnicas que podemos fazer uso para cumprirmos essa tarefa.  Técnicas de Mapeamento de Entidades:  Mapeamento de Entidade Regular: Toda entidade forte se torna uma tabela e cada atributo se torna uma coluna11.Mapeamento de Atributos Multivariados: Todo atributo multivalorado12 será convertido em uma tabela com a FK apontando para a entidade forte.Mapeamento de Entidade Fraca: Criamos uma tabela para a entidade fraca com a FK de alguma entidade forte.  Mapeamento de Relacionamentos​  Na hora de mapear os relacionamentos, nosso foco tem que ficar na definição das FK nas tabelas de referências aos objetos de completude parcial ou total.  Casos de Relacionamentos 1:1 ou 1:N​  Para definir onde nossa FK será implementada, basta se perguntar qual a entidade dependente da outra. Um exemplo clássico é o de conta em um banco.    Só pode haver uma conta se anteriormente existir um cliente. Um cliente pode ter mais de uma conta mas todas elas precisam se remeter ao id do cliente para fazer algum sentido. Similarmente, uma hipoteca só pode existir se o cadastro do cliente existir antes, a diferença é que cada cliente só pode ter uma única hipoteca por vez.  Caso de Relacionamento N:N​  Esse caso é mais complexo porque cada entidade por se referenciar mais de uma vez a outra. A melhor saída desse caso é a criação de uma tabela nova que usa FK de cada entidade para criar uma linha na tabela de relacionamento.    Caso de Relacionamento N-ário​  Esse caso é mais raro e indica uma relação múltipla entre mais de duas entidades. No geral, podemos quebrar em relacionamentos binários mas por agora vamos aprender também esse meio de mapeamento.    Similar ao caso 1-N, tivemos que nos valer de uma tabela de relacionamento. A diferença é que a chave primária composta aumentou de 2 (caso 1-N) para N valores.  Casos de Generalização-Especificação​  Bancos de dados não implementação herança. Dessa feita, nós temos que converter os relacionamentos de completude parcial e total em tabelas.  Voltando no exemplo dos veículos. Nós temos 3 opções do que fazer.    Maneiras de mapear:  Criar uma tabela veiculo com colunas adicionais que só serão preenchidas no casos específicos de carro e caminhao sinalizando na coluna tipo colocando null quando não relevante.Criar tabelas carro e caminhao com as colunas pertencentes à tabela veiculo. Desse modo, teremos duas classes independentes entre si mas com algumas colunas de sentido compartilhado.Criar uma tabela para cada entidade, passando a FK do relacionamento veiculo como indicativo.  Comentário Cada uma das abordagens tem prós e contras mas, na minha experiência, o terceiro caso é o mais comum.  ","version":"Next","tagName":"h3"},{"title":"Problemas de Desenho em Bancos Relacionais​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#problemas-de-desenho-em-bancos-relacionais","content":" Se aplicarmos tudo que aprendemos até o momento, ainda seremos passíveis de cometer erros que podem comprometer o desempenho e, por fim, a utilidade do nosso modelo.  Nessa seção, vamos elencar alguns dos casos mais comuns que levaram ao desenvolvimento de uma metodologia de avaliação de desenho de modelos relacionais que veremos na seção de Normalização.  Sentido Semântico dos Atributos Obtuso​  Sempre desenhe um esquema relacional de modo que seja fácil explicar o seu sentido, para isso, não misture atributos de entidades diferentes e de relacionamentos em uma mesma tabela (relação).  No geral, essa regra se baseia no fato que devemos pensar em cada relação como representante de uma entidade ou de um relacionamento. Desse modo, se misturarmos atributos de mais de uma entidade ou relacionamento, estaremos aumentando desnecessariamente a complexidade do sentido semântico do nosso modelo.  Exemplo Abaixo temos um exemplo do que não fazer pois acabamos misturando informações relativas ao departamento que são relacionadas exclusivamente à outra entidade separada da entidade EMPREGADO_DEPARTAMENTO (que por sua vez, é basicamente a entidade empregado com informações adicionais de departamento). Para corrigir isso, devemos indicar separar completamente o relacionamento entre essas entidades de modo atômico. Agora, vamos ver como deveria ser: Para entender intuitivamente onde estava o problema, basta se colocar no papel de alguém que ia explicar a tabela EMPREGADO_DEPARTAMENTO. Veja que você ia precisar explicar quais colunas se referiam ao funcionário e quais se referiam ao departamento. No exemplo corrigido, tudo fica super simples porque só correlacionamos as entidades sem misturar nenhum dos seus atributos.  Informação Redundante em Tuplas e Anomalias de Atualização​  Devemos desenhar um esquema relacional de modo a não produzir anomalias de insert, deletion ou update. Caso seja impossível evitar, devemos nos assegurar que os programas sempre levarão as anomalias em consideração na hora de interagir com o banco.  Seguindo o exemplo do caso anterior, podemos ver que a tabela empregado_departamento sempre irá repetir as informações do departamento para cada empregado. Isso tem impacto no custo de storage do servidor de banco de dados e, como se não fosse suficiente, pode levar a anomalias vários tipos de anomalias.  Essa junção entre informações de diferentes entidades em uma nova relação chamamos de Natural Join.  Somente por termos um mal design nas tabelas, nos expomos a várias anomalias que podemos elencar abaixo.  Anomalias de Inserção Para criar uma nova entrada de empregado, sempre será necessário consultas as informações do departamento e duplicar essas mesmas informações em cada linha de empregados que estão lotados no mesmo departamento. Caso o empregado não tenha departamento ainda, teremos que inserir NULL em todas as colunas referentes ao departamento.Nós simplesmente não seremos capazes de inserir um novo departamento que ainda não tem nenhum funcionário porque o cpf é PK. Anomalias de Deleção Caso um departamento perca todos os seus empregados, nós perderemos a informação do departamento definitivamente porque ela só existe na tabela empregado_departamento. Anomalias de Modificação Se mudarmos o nome de um departamento, termos que fazer update em todas as linhas de empregados lotados no mesmo. Qualquer erro nesse update e teremos dados conflitantes na base de dados.  informação Em alguns casos, teremos que pensar nos relatórios ou consultas frequentes que serão demandas. Caso haja necessidade de se consultar entidades com relacionamentos de maneira misturada, devemos usar views ao invés de jogar essa responsabilidade para o banco de dados. Em casos que demandam muita performance, podemos usar stored procedures junto com triggers para garantir que sempre teremos dados livres de anomalias na tabela que precisa conter atributos misturados. O conceito dado para uma tabela desse tipo é view materializada.  Valores NULL Desnecessários em Tuplas​  Evite a todo custo adicionar atributos em relações de base (ou seja, entidades básicas) que terão valores NULL frequentemente. A regra geral é NULL ser sempre uma exceção.  Ao invés de termos relações (ou tabelas) grandes com vários campos opcionais, devemos dar preferência à quebra desses campos em relacionamentos com outras tabelas usando FK. A explicação disso é que NULL é um dado, e por ser um dado, ele ocupa espaço no storage e pode causar problemas de operação de queries dado que trabalhar com dados nulos não é sempre trivial.  Outro problema sério é que o sentido semântico de um campo nulo é notadamente ambíguo. Por exemplo, podemos pensar que uma coluna (ou atributo) nulo signifique:  Que o valor na tupla é &quot;não aplicável&quot;.Que o valor na tuple é &quot;desconhecido&quot;.Que o sabemos que o valor existe mas, naquele momento, é incerto ou resta pendente.  Como saber com certeza o que cada campo anulável (ou nullable) realmente quer dizer? Claramente, estamos aumentando o risco de falha no entendimento do nosso modelo de dados.  Tuplas Espúrias​  Devemos evitar relações que contenham atributos comparáveis com atributos PK e FK de outras relações.  A ideia desse problema surge quando temos que fazer JOIN por atributos que não são PK (e se não mapeados, também não serão FK) de nenhuma relação. O impacto disso é que a tabelar resultante do JOIN poderá ter tuplas (ou linhas) que não fazem sentido (por isso chamadas de espúrias).  Exemplo Se quisermos uma consulta que nos diga todos os empregados por projeto com o nome completo do empregado, teremos problemas pois só temos a coluna CIDADE_PROJETO como possibilidade de JOIN. Isso causaria linhas que não fazem sentido onde um nome completo de um funcionário estaria ligado a um cpf de outro.  ","version":"Next","tagName":"h3"},{"title":"Normalização​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#normalização","content":" Vamos recapitular o que já aprendemos até agora:  Sabemos criar modelos relacionais representativos de uma implementação real de entidades e relações.Já sabemos os erros mais comuns que um desenho ruim pode causa.  Agora, precisamos de ferramentas para medir a qualidade do nosso design. Esse esforço de avaliar o modelo é chamado normalização mas vamos dar uma definição mais precisa logo à frente.  Contexto Histórico Um pouco de história A primeira pessoa a propor o processo de normalização foi Codd em 2 artigos super relevantes pra nossa área. No artigo A Relational Model of Data For Large Share Data Banks temos a definição inicial de todo o esquema de bancos relacionais e da primeira forma normal. No artigo “Further Normalization of the Data Base Relational Model” in Rustin [1972], fora proposto as outras duas formas normais e o processo de normalização. Originalmente, foram propostas 3 formas normais sendo que a definição mais formal da terceira forma foi dada posteriormente por Boyce e Codd. Com o passar dos anos, foram definidas mais 2 formas normais que são baseadas nos conceitos de dependências multivaloradas e dependências conjuntas.  Para conseguirmos entender bem o que é normalização precisaremos de um conceito que é a base na qual construiremos nossa análise.  Informação Quem quiser uma abordagem de vídeo desse mesmo assunto, pode conferir na aula abaixo. Aula no Youtube  Dependência Funcional​  Até agora, sempre representamos nosso banco de dados em termos de tabelas e entidades, entretanto, nada nos impede de abstrair um desenho13 de banco de dados relacional como um conjunto de nnn atributos AiA_iAi​ de modo que i∈{1,2,...,n}i \\in \\{1,2,...,n\\}i∈{1,2,...,n}. Ou seja, nosso banco de dados pode ser definido como R={A1,A2,...,An}R = \\{A_1, A_2, ..., A_n\\}R={A1​,A2​,...,An​}.  Uma Dependência Funcional (DF), escrita por X→YX \\rightarrow YX→Y14, sendo XXX e Y⊂RY \\subset RY⊂R, define uma limitação para as tuplas possíveis que podem expressar uma relação rrr de RRR. Essa relação entre tuplas quaisquer t1t_1t1​ e t2t_2t2​ deve satisfazer a seguinte regra: Para qualquer t1t_1t1​ e t2t_2t2​ em rrr, deve ser verdade que se t1[X]=t2[X]t_1[X] = t_2[X]t1​[X]=t2​[X], então, t1[Y]=t2[Y]t_1[Y] = t_2[Y]t1​[Y]=t2​[Y].  Se for definido em RRR que não é possível existir duas tuplas de modo que t1[X]=t2[X]t_1[X] = t_2[X]t1​[X]=t2​[X] temos, então, uma chave candidata visto que é um valor (ou conjunto de valores) que exprime uma relação atômica.  Exemplo Calma, nem é tão complexo quanto parece. A primeira coisa é lembrar que tupla pode ser entendido nesse contexto como linhas das tabelas. Nesse caso em especial, estamos dizendo algo como: &quot;Se duas linhas dos atributos X são iguais, com certeza absoluta, essas linhas também serão iguais nos atributos Y, se Y tiver uma dependência funcional de X&quot;. Temos essa certeza porque sabemos que Y depende de X. Então, se X diz que algo é igual, Y também dirá a mesma coisa. Para simplificar, podemos pensar X e Y como um atributo só. Por exemplo, X = cpf e Y = nome. Nós sabemos que, se 2 cpfs são iguais, eles precisam estar se referenciando à uma mesma pessoa. Como os cpf iguais implicam em estarmos falando de uma mesma pessoa, os campos nome referentes a cada entrada do cpf também serão iguais. Por isso, podemos dizer que nome depente de cpf. Ou, na linguagem formal, cpf →\\rightarrow→ nome.  Aviso Preste muita atenção nesse conceito porque o Navathe se refere a ele como &quot;O conceito mais importante na teoria do design de esquemas relacionais&quot;. Quem sentir dificuldade com a linguagem usada, vale a pena conferir a parte de matemática  Agora que sabemos o que é uma dependência funcional, estamos prontos para usar esse conceito na definição de uma metodologia formal para melhoria e teste do nosso desenho de banco dados relacional.  Formas Normais baseadas em Chaves Primárias​  Para construir nossa metodologia de avaliação de esquemas relacionais, nós vamos supor que:  Para cada relação, existe um conjunto de dependências funcionais.Para cada relação, existe uma definição de chave primária.  Chamamos de Processo de Normalização o conjunto de testes (baseados nas duas condições acima) feitos nos modelos relacionais para mensurar a forma normal que o esquema (ou modelo) pode ser avaliado.  Se bem executado, o processo de normalização acarreta a redução de 2 problemas:  Reduzir redundânciaRedução de anomalias nos processos de DML que alteram dados.  Chamamos de Forma Normal a referência ao mais alto grau de condições que uma relação15 contém. A definição de cada forma normal é derivada exclusivamente do conceito de dependência funcional sobre os atributos de uma relação.  Se uma determinada relação não passar no teste para uma forma normal, será necessário fazer uma decomposição em relações menores até se obter a adequação à forma.  Comentário Tecnicamente, a única condição para se ter a terceira forma normal é a segunda. Visto que, como vamos ver, a primeira não é condição para a segunda, é, tecnicamente, possível se ter a terceira forma normal apenas com o alcance da segunda. Mas por motivo de desenvolvimento histórico, vamos ver as formas em sequência.  Primeira Forma Normal (1NF)​  A primeira forma normal está condita no artigo original de Cobb que introduziu o modelo relacional. Naquele contexto, todo o processo de normalização estava contido nessa única regra.  Basicamente, a primeira forma normal rege a criação de relações proibindo a existência de:  Atributos multivaloradosAtributos compostos  Todo domínio de um atributo deve ser composto de valores atômicos .  Comentário A primeira forma normal não tem uma definição matemática precisa porque ela está atrelada ao cerne do próprio modelo relacional. Entender os benefícios dessa forma normal é, em suma, entender os benefícios do modelo relacional como um todo.  Exemplo Atributo Multivalorado Imagine uma tabela DEPARTAMENTO abaixo: ID\tESTADO\tCIDADE1\tSP\tSÃO PAULO 2\tMG\t(BELO HORIZONTE, BETIM) 3\tPA\t(SANTAREM, BELEM, ALTAMIRA) A primeira forma normal proíbe que uma relação como essa seja criada porque o atributo cidade não é atômico. O processo de normalização 16 nesse caso entregaria uma tabela assim ID\tESTADO\tCIDADE1\tSP\tSÃO PAULO 2\tMG\tBELO HORIZONTE 2\tMG\tBETIM 3\tPA\tSANTARÉM 3\tPA\tBELÉM 3\tPA\tALTAMIRA onde a PK é o ID e CIDADE.  Exemplo de Atributo Composto Pensemos num caso onde temos a tabela EMPREGADO_PROJETO que relaciona dados do empregado e quais projetos ele está atuando. Poderíamos pensar que projeto é um atributo composto que contém, nele mesmo, dados do ID_PROJETO e HORAS que o empregado está atuando. Desse modo, podemos chegar, erradamente, ao desenho abaixo: CPF\tNOME\tID_PROJETO\tHORAS1234\tZE DA SILVA\t1 2\t10 20 Esse tipo de relação não é permitida porque, novamente, temos a quebra da atomicidade no atributo da tupla.  Segunda Forma Normal (2NF)​  Para definirmos a 2NF precisamos expandir um pouco o nosso entendimento de dependência funcional para os tipos total e parcial.  Se X→YX \\rightarrow YX→Y tiver uma dependência funcional total, então, se removermos qualquer atributo Ai∈XiA_i \\in X_iAi​∈Xi​, qualquer outra combinação de atributos do tipo (X−Ai)(X - A_i)(X−Ai​) não terá uma dependência funcional com YYY.  Se a regra acima não for cumprida, dizemos que X→YX \\rightarrow YX→Y é uma dependência funcional parcial.  Dado um esquema de relação RRR, é dito que ele é 2NF se todos os atributos não primários Ai∈RA_i \\in RAi​∈R possuem uma dependência funcional completa em relação a qualquer chave de RRR.  Comentário Para entender melhor essa passagem, basta pensar que, se estamos falando de dependência funcional total a partir de qualquer chave. Isso força que todas as colunas dependentes de valor (do lado direito da dependência funcional) sejam inteiramente dependentes à todas as chaves da tabela.17  Exemplo Observe a tabela abaixo: CPF\tPROJETO_ID\tHORA\tE_NOME\tP_SIGLA\tP_CIDADE Mesmo que escolhamos CPF e PROJETO_ID como chaves primárias, ainda estaríamos violando a 2NF porque a regra de dependência de atributos não primários não seria satisfeita. Embora, de fato, CPF e PROJETO_ID sejam atributos primários (que não possuem dependência funcional), a 2NF nos cobra que todos os atributos não primários sejam totalmente dependentes funcionais da nossa PK. Por exemplo, P_SIGLA e P_CIDADE são dependentes funcionais exclusivamente de PROJETO_ID. E_NOME é dependente exclusivamente de CPF. Por fim, HORA é o único atributo que realmente é dependente de CPF e PROJETO_ID ao mesmo tempo. O defeito dessa tabela é que nós apenas juntamos coisas que não indicam a subordinação correta à chave primária. Para resolver, basta decompor essa relação em relações que de fato exprimem a dependência funcional total entre os atributos não primários e a chave primária. CPF\tPROJETO_ID\tHORACPF\tE_NOMEPROJETO_ID\tP_SIGLA\tP_CIDADE  Terceira Forma Normal (3NF)​  Para definirmos a 3NF, precisamos expandir um pouco mais o conceito de dependência funcional para o tipo transitivo.  Chamamos de dependência funcional transitiva se existir um conjunto de atributos Z⊂RZ \\subset RZ⊂R que não é nem candidato à chave nem um subconjunto de nenhuma chave de RRR e, também, for verdade que X→ZX \\rightarrow ZX→Z e Z→YZ \\rightarrow YZ→Y.  Exemplo Vamos entender melhor esse conceito com um exemplo. Pensemos numa tabela com os seguintes campos: NOME\tCPF\tDTNASCIMENTO\tDEP_ID\tDEP_NOME Se nossa PK for exclusivamente o atributo CPF. Teremos um caso de dependência transitiva entre CPF →\\rightarrow→ DEP_NOME porque o nome do departamento é dependente do DEP_ID que, por sua vez, é dependente da PK nessa relação. Comentário Veja como, além da dependência funcional transitiva, essa tabela também fere a 2NF. Agora, veja o conceito da 3NF e entenda como elas se relacionam.  Dizemos que um esquema relacional está na 3NF se estiver na 2NF e, também, nenhum atributo não primário de RRR possuir dependência transitiva em relação à PK de RRR.  Outra maneira, mais geral, de definir a 3NF é:  Uma relação está na 3NF se, para qualquer dependência funcional não trivial X→YX \\rightarrow YX→Y, for verdade que, em RRR, qualquer XXX é uma superkey ou YYY for um atributo primário de RRR.  Dessa definição mais formal, podem ver que, para uma relação estar na 3NF é necessário que:  Todo atributo não primário seja totalmente dependente de todas as chavesTodo atributo não primário não possua dependência transitiva relativa à nenhuma chave  Boyce-Codd Normal Form (BCNF)​  Pg 517.  Surpresa! Temos uma &quot;nova&quot; forma normal que não é necessariamente &quot;nova&quot;. A 3NF foi refinada com o passar do tempo para casos mais específicos que ainda poderiam contemplar a 3NF mas que gerariam problemas.  Dizemos que uma relação está na BCNF se, para cada dependência funcional não trivial X→AX \\rightarrow AX→A, for verdade que XXX é uma superkey de RRR.  A diferença está no fato 2 que vimos logo acima. A 3NF só cobra que atributos não primários não tenham dependência transitiva mas não que eles estejam em uma superkey.  O toda relação que contempla a BCNF está, por definição, contemplando a 3NF. Mas a recíproca não é verdadeira.  Quarta e Quinta Formas Normais​  Embora, como dito anteriormente, se tenham desenvolvido testes para além da terceira forma normal, Navathe adverte que a praticidade das quarta e quinta formas normais é debatível porque são &quot;baseadas em condições raras e difíceis para planejadores de bancos de dados e usuários compreender e detectar&quot;.  Outro ponto importante é que existe uma escolha entre performance vs normalização. Onde, quanto maior a normalização do esquema, menor será seu desempenho (porque teremos cada vez mais condições para controle).  Denormalização é o processo de contrariar as regras de uma dada forma normal e persistir um JOIN entre entidades ou relacionamentos como uma relação-base.  As vezes, precisamos denormalizar para ganhar performance (sempre tendo em mente o risco que isso trará).  ","version":"Next","tagName":"h3"},{"title":"Banco de Dados Não-Relacionais​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#banco-de-dados-não-relacionais","content":" Database NoSQL​  ","version":"Next","tagName":"h3"},{"title":"Segurança​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#segurança","content":" Segurança de Banco de Dados​  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Modelagem de Dados","url":"/CC_site/docs/puc/segundo-periodo/modelagem-dados#bibliografia","content":" ELMASRI, Ramez; NAVATHE, Shamkant B. Sistemas de banco de dados. 7 ed. São Paulo: Person, 2018.MARTIN, James. Principles of Data Base Management.CHEN, Peter. Modelagem de dados: A abordagem para Projeto Lógico.E.F. Codd. A Relational Model of Data For Large Shared Data Banks. Comm. ACM 13, 6 (June 1970), 377-387.ROB e Coronel. Database Systems: Design. Implementation and Management Wadworth Series (1993).E.F. Codd. A Relational Model of Data For Large Share Data Banks.E.F. Codd. Further Normalization of the Data Base Relational Model.    Footnotes​ Ou seja, que continuam salvos mesmo depois do computador desligar. ↩ Na esperança que ele sempre tome uma decisão otimizada de como acessar o dado. Mas fique tranquilo, quase sempre ele escolhe o melhor caminho. ↩ Também conhecido como dicionário de dados. ↩ Por exemplo, trocar o SGBD do MSSQL para MySQL. Em tese, é possível realizar essa migração sem alterar a estrutura das tabelas visto que ambos são do tipo SQL. ↩ Ou seja, estamos ainda na etapa de um projeto conceitual. ↩ Pense no exemplo de um colégio infantil. O cadastro responsavel_aluno só pode existir se o cadastro anterior aluno já existir. Agora se for uma instituição superior de ensino, que possui alunos maiores de 18 anos, esse campo pode ser opcional apenas para alunos menores de idade. ↩ Por exemplo, se um atleta de futebol é goleiro, ele não pode ser atacante. ↩ Por exemplo, um funcionário de um banco pode ser, também, um cliente do mesmo banco. ↩ Por exemplo, uma tabela pessoa com 2 colunas: nome e idade. É dita como sendo uma relação de grau 2. ↩ Para explicar melhor esse conceito, podemos pensar em uma tabela que tenha a coluna grau_de_instrucao. Ela só pode aceitar um valor string dentro da lista [fundamental, medio, superior]. Essa lista de opções é o domínio do atributo grau_de_instrucao. ↩ Atributos compostos no modelo de Chen simplesmente se tornam colunas ignorando o nome do atributo. Por exemplo, se a classe pessoa tem um atributo composto endereco que contém outros atributos como rua e numero. Nós vamos colocar as colunas rua e numero como colunas da tabela pessoa. No modelo de James, a gente nem precisa bater cabeça com isso porque a notação dele não permite atributos compostos. ↩ Já vimos lá em cima no conteúdo que atributos multivalorados só existem no modelo de Chen. No de James nós somos obrigados a converter esse conceito em uma entidade fraca. ↩ Isso não quer dizer que é uma boa ideia representar um banco de dados como uma tabela única. Significa apenas que podemos pensar num banco de dados como um conjunto de atributos (independente de qual tabela cada atributo está). ↩ Lê-se algo como &quot;Y é dependente funcional de X&quot;. ↩ Que também podemos chamar de tabela. ↩ Hoje em dia ta tão fácil aprender que eu nem precisei fazer a tabela ajustada na mão, só pedi pro chat gpt fazer isso. Mais do que nunca, o que importa agora é saber o que deve ser feito ao invés de perder tempo implementando. ↩ Se você não entendeu a explicação, volte na parte que a gente define chaves e revisa os conceitos. ↩ ","version":"Next","tagName":"h2"},{"title":"Modelagem e Gestão de Processos de Negócios","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/terceiro-periodo/modelagem-processos","content":"","keywords":"","version":"Next"},{"title":"Modelagem de Processos de Negócios​","type":1,"pageTitle":"Modelagem e Gestão de Processos de Negócios","url":"/CC_site/docs/puc/terceiro-periodo/modelagem-processos#modelagem-de-processos-de-negócios","content":" ","version":"Next","tagName":"h2"},{"title":"Fundamentos de Processos de Negócios​","type":1,"pageTitle":"Modelagem e Gestão de Processos de Negócios","url":"/CC_site/docs/puc/terceiro-periodo/modelagem-processos#fundamentos-de-processos-de-negócios","content":" Conceitos​  Mapeamento e Modelagem​  ","version":"Next","tagName":"h3"},{"title":"Metodologia para Modelagem​","type":1,"pageTitle":"Modelagem e Gestão de Processos de Negócios","url":"/CC_site/docs/puc/terceiro-periodo/modelagem-processos#metodologia-para-modelagem","content":" BPMN​  ","version":"Next","tagName":"h3"},{"title":"Gestão de Processos de Negócios​","type":1,"pageTitle":"Modelagem e Gestão de Processos de Negócios","url":"/CC_site/docs/puc/terceiro-periodo/modelagem-processos#gestão-de-processos-de-negócios","content":" ","version":"Next","tagName":"h2"},{"title":"Metodologias para Gestão e Avaliação​","type":1,"pageTitle":"Modelagem e Gestão de Processos de Negócios","url":"/CC_site/docs/puc/terceiro-periodo/modelagem-processos#metodologias-para-gestão-e-avaliação","content":" Gestão Orientada para Processos​  ","version":"Next","tagName":"h3"},{"title":"Gerenciamento de Desempenho​","type":1,"pageTitle":"Modelagem e Gestão de Processos de Negócios","url":"/CC_site/docs/puc/terceiro-periodo/modelagem-processos#gerenciamento-de-desempenho","content":" Objetivos, Metas e Indicadores​  ","version":"Next","tagName":"h3"},{"title":"Tecnologias para Gestão​","type":1,"pageTitle":"Modelagem e Gestão de Processos de Negócios","url":"/CC_site/docs/puc/terceiro-periodo/modelagem-processos#tecnologias-para-gestão","content":" BPMS e Automação de Processos​ ","version":"Next","tagName":"h3"},{"title":"Gerência de Projetos","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-projetos","content":"","keywords":"","version":"Next"},{"title":"Fundamentos da Gerência de Projetos e Visão PMI/PMBok​","type":1,"pageTitle":"Gerência de Projetos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-projetos#fundamentos-da-gerência-de-projetos-e-visão-pmipmbok","content":" ","version":"Next","tagName":"h2"},{"title":"Fundamentos da Gerência de Projetos​","type":1,"pageTitle":"Gerência de Projetos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-projetos#fundamentos-da-gerência-de-projetos","content":" Conceitos Básicos​  A primeira coisa que temos que deixar claro é a diferença entre atividades de Operação e de Projeto. A operação tem como principal caraterística a repetição das suas rotinas. Um projeto, por outro lado, tem caráter linear que se encaminha para a sua conclusão.  Um Programa é definido como um conjunto de projetos semelhantes agrupados para um melhor gerenciamento.  Uma Carteira ou Portfólio de projetos é o conjunto de projetos agrupados por organização que irá desempenhá-los. Independentes da semelhança entre eles.  Um Project Management Office - PMO é o grupo de pessoas que gerencia a carteira de projetos da empresa ou organização.  Um Subprojeto é um pedaço de um projeto maior que é desmembrado para melhorar a organização das atividades.  Conceito de Projeto​  Agora vamos definir o conceito de Projeto que vamos trabalhar nesse microfundamento.  &quot;Um esforço temporário empreendido para criar um produto, serviço ou resultado exclusivo&quot;. PMBoK, 2017.  Gerência de Projetos​  Segundo o PMBoK, a Gerência de Projetos é aplicação de conhecimentos, habilidades e técnicas para se atingir os requisitos de um projeto.  Esse conjunto de ferramentas vão desde as hard skills quanto as soft skills na gestão e montagem da equipe que fará as atividades.  Para uma boa gerência, é necessário que as atividade sejam acompanhadas de modo a utilização otimizada dos recursos dentro do planejamento inicial. Para isso, o monitoramento contínuo é necessário, bem como, que sejam disponibilizados os insumos e recursos necessários.  Ciclo de Vida de Projeto​  Basicamente, temos os modelos Prescritivos que são mais burocráticos e rígidos e os modelos Ágeis que são mais velozes e mais aptos à mudanças ao longo do desenvolvimento.  Não existe certo e errado, existe o contexto em que o projeto será executado. Cada caso é único e deve ser estudado com toda a atenção.  Como Nasce um Projeto​  As demandas que geram os projetos podem surgir de todos os lugares. Uma terminologia comum a ser usada é a de Clientes Internos e Clientes Externos para separar os casos onde as necessidades a serem satisfeitas estão dentro ou fora da empresa que será responsável pela execução do projeto.  ","version":"Next","tagName":"h3"},{"title":"Visão do Project Management Institute - PMI​","type":1,"pageTitle":"Gerência de Projetos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-projetos#visão-do-project-management-institute---pmi","content":" Project Management Institute - PMI​  Fundado em 1969, é um instituto referência mundial em gerenciamento de projetos. Cada associação atrelada ao PMI USA é chamado de &quot;capítulo&quot; e, no Brasil, está presente em vários estados.  É ele quem produz o guia mais famoso da área, o Guia PMBoK. Além dele, temos outras publicações como:  PM NetworkPM TodayProject Management JournalInformation Source Guide  E faz vários congressos e encontros ao longo do mundo.  Além dessa parte de produção de conteúdos e encontros, existem várias certificações disponíveis pelo PMI:  CAPMPMPPgMPPfMPPMI-ACPPMI-RMPPMI-BPAPMI-SP  Guia PMBoK​  É a principal referência no que tange à gerência de projetos. Ele define que um projeto nada mais é que um grupo de processos relacionados para o atingimento de uma meta.  Na versão 6, temos 49 tipos de processos organizados em 5 grupos:  IniciaçãoPlanejamentoExecuçãoMonitoramento e ControleEncerramento    Projetos no Contexto Organizacional​  Dependendo do contexto da organização em que o projeto for implementado, a probabilidade de sucesso por ser maior ou menor a depender das características culturais da organização. Damos o nome desses fatores de Fatores Ambientais da Empresa (FAR)  Podemos elencar alguns fatores importantes nessa relação:  Fatores Internos: Cultura, Estrutura e GovernançaGeografia das instalações e recursosInfraestruturaSoftware e tecnologias disponíveisDisponibilidade dos recursosCapacidade do capital humano Fatores Externos: Condições de mercadoStakeholdersLegislaçãoGoverno  Outra coisa que pode ser muito importante para a realização de um projeto é a base de conhecimentos disponíveis internamente na empresa. Segundo o PMBoK, damos o nome de Ativos de Processos Organizacionais (APO) a esse repositório de processos e planos disponíveis ao uso interno.  Podemos separar os APO em duas categorias:  Processos, políticas e procedimentosBases de conhecimento organizacionais  O conhecimento do contexto da organização é importante para que o gerente de projeto seja capaz de cumprir os planejamentos dos projetos de sua responsabilidade.  Estrutura Organizacional​  Dentre os tópicos relacionados, a estrutura organizacional é muito relevante porque, a depender dela, algumas etapas do projeto podem ser grandemente afetadas.  Podemos destacar as principais estruturas atualmente como sendo:  Estrutura Funcional: Foco na especialização e na rotina. Muito usado em grandes empresas e no setor público.Estrutura por Projeto: Foco na autonomia no cumprimento das metas. Atores temporários atrelados à projetos. Maior celeridade na comunicação.Estrutura Matricial: É um misto das duas. Possui alguma flexibilidade na comunicação entre projetos mas pode causar problemas de falta de clareza na cadeia de comando.  Comentário Na vida real, nenhuma organização é 100% classificável de acordo com essas estruturas. Mas conhecê-las ajudará muito caso, quem sabe algum dia, nos encontremos no papel de gerente de projeto.  Áreas da Gerência de Projetos​  Segundo o PMBoK podemos dividir a gerência de projetos em 10 áreas:  Integração - Foco na relação entre as demais áreasEscopo - Foco no atendimento dos requisitosCronograma - Cumprimento dos prazos estipuladosCustos - Foco no montante de recursos necessários para o atingimento das metasQualidade - Seguimento de padrões e normas estabelecidasRecursos - Foco na utilização otimizada dos recursos demandadosComunicações - Informações sobre o projeto de qualidade e tempestivamenteRiscos - Mapeamento das dificuldades externas que podem refletir no projetoAquisições - Responsável pela compra dos insumos necessáriosStakeholders - Relacionamentos com os atores relevantes e interessados no projeto  Tempo em Projetos​  Uma das áreas que acabamos de ver é a de Cronograma. Podemos destacar essa área porque ela é muito relevante para o alcance das metas.  O tempo é o ativo que é mais estudado e, para muitos pesquisadores, é a área mais importante da gerência de projetos.  O PMBoK elenca 6 processos pertencentes à essa área:  Planejar o gerenciamento do cronogramaDefinir as atividadesSequenciar as atividadesEstimar as duraçõesDesenvolver o cronogramaControlar o cronograma  Na construção do cronograma podemos usar várias representações gráficas. Como por exemplo:  Diagrama de SetasDiagrama de Rede PERTGráfico de Gantt  Comentário Existem várias ferramentas para gerenciamento. O MS-Project, ClickUp, Trello, Primavera, OpenProj e outros  Recursos em Projetos​  Os recursos do projeto incluem todas as condições materiais necessárias para o projeto. Isso vai além de apenas insumos materiais. Contempla também capital humano, treinamento, infraestrutura de TI e etc.  Para se usar os recursos da melhor maneira possível, é necessário que o time de recursos esteja bem alinhado com o planejamento afim de otimizarem as aquisições e contratações no tempo certo para evitar ociosidade de uso ou custo de armazenagem desnecessário.  De longe, a parte mais difícil e necessário do setor de gerenciamento de recursos é a seção de Recursos Humanos. Existem milhares de técnicas, ferramentas e pesquisas sobre como otimizar os recursos humanos em uma organização e, por esse material ter escopo de overview, não vamos nos aprofundar nesse tema.  Gestão Financeira de Projetos​  Normalmente, um cliente faz 2 perguntas em qualquer proposta de projeto: &quot;Quanto vai custar?&quot; e &quot;Quanto tempo vai levar?&quot;.  Essas perguntas são clássicas e, é óbvio, são umas das mais difíceis de se responder inicialmente porque só se sabe o custo real de um projeto no final do mesmo. Isso nos obriga a ter que estimar custos e necessidades que surgirão ao longo das etapas de projeto.  As etapas de trabalho da área de orçamento é parecida com as etapas das outras áreas. Começamos com a estimativa dos esforços. Passamos para a estima dos custos relacionados. Por fim, devemos controlar para sabermos se as estimativas estão de acordo com a realidade.  Para finalizarmos essa parte. Vale destacar os dois artefatos mais importantes produzidos por essa área:  Cronograma FinanceiroOrçamento do Projeto  Riscos em Projetos​  Se tivéssemos certeza que um risco aconteceria, ele deixaria de ser um risco.  Essa natureza especulativa dos riscos é o cerne da área de gestão de risco do projeto. Para tanto, esse setor sempre deve levar em consideração 2 aspectos na análise dos riscos: probabilidade e complexidade.  Os processos de trabalho dessa área pelo PMBoK são:  Planejar os riscosIdentificar os riscosAnálise qualitativaAnálise quantitativaPlanejamento das respostas EscalarPrevenirTransferirMitigarAceitar Implementação das respostasMonitoramento dos riscos  ","version":"Next","tagName":"h3"},{"title":"Gerenciamento Prescritivo e Ágil de Projetos e Uso de Ferramentas​","type":1,"pageTitle":"Gerência de Projetos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-projetos#gerenciamento-prescritivo-e-ágil-de-projetos-e-uso-de-ferramentas","content":" ","version":"Next","tagName":"h2"},{"title":"Gerenciamento Tradicional​","type":1,"pageTitle":"Gerência de Projetos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-projetos#gerenciamento-tradicional","content":" Cronograma de Projeto - PERT/CPM​  Aprendemos anteriormente sobre a importância da gestão do tempo em um projeto. Para tanto, a necessidade de se construir um bom cronograma é fundamental.  Várias são as técnicas que podem ser usadas para essa construção. Dentre elas, vamos aprender aqui a chamada Program Evaluation Review Technique (PERT).  A maneira de construir um cronograma PERT é analisando cada tarefa envolvida na conclusão dos projetos para, no final, termos um gráfico de redes (grafos).    Normalmente, o PERT é aplicado em grandes projetos porque permite:  A definição de prazosVisão detalhada da sequência de tarefas a serem executadasFacilita a gestão do tempo alocado em cada tarefa  Também é muito comum vermos o PERT associado a outra sigla chamada Critical Path Method (CPM) que possui uma abordagem muito parecida e foi desenvolvido praticamente ao mesmo tempo2.    A principal característica do CPM é que ele mostra as tarefas que possuem um prazo projetado maior de cumprimento. Essas tarefas serão o foco da gestão porque, caso seja possível reduzir os tempos previstos para a conclusão das mesmas, o projeto terá grandes avanços nas entregas.  A criação do método PERT/CPM teve sua motivação no projeto Polaris de construção de um submarino nuclear em 1957.  Construção dos Diagramas - PERT/CPM​  Agora vamos aprender como construir um diagrama PERT/CPM.  Para tal, precisamos nos certificar que temos os seguintes dados a respeito do nosso projeto:  Lista das tarefas a serem executadas até a conclusão do projetoDefinição das relações de precedência e subsequência entre essas tarefasAs estimativas dos tempos para cada tarefa O PERT usa 3 estimativas de tempo: Mais ProvávelOtimistaPessimista Em cima dessas estimativas, calcula-se a média ponderada para ter o valor usado  Podemos usar o diagrama de grafos do PERT para descrever as tarefas do seguinte modo:    Existem também alguns conceitos que podemos nos deparar na construção de um cronograma que vão ajudar muito na nossa comunicação com outros profissionais da área:  Primeira Data de Início (PDI)Primeira Data de Término (PDT)Folga Livre (FL)Última Data de Início (UDI)Última Data de Término (UDT)Folga Total (FT)  As primeiras datas são os cenários otimistas onde, caso a atividade seja feita no tempo previsto, o projeto será beneficiado pelo adiantamento de uma atividade. Ao contrário, as últimas datas são os casos em que as atividades iniciarem na última data possível para que o projeto não tenha um atraso.  A FT é a soma de todas as FL.  Todos esses conceitos podem ser vistos naquele gráfico do CPM logo acima.  De posse desses conceitos podemos ver que o caminho crítico é precisamente o caminho que não apresenta nenhuma FL, ou seja, que levará o maior número de tempo necessário para o somatório das suas tarefas.  Project Libre​  A partir daqui, o microfundamento é baseado na parte prática do gerenciamento. Portanto, ele pressupõe que nós estamos usando algum software de gestão. Como eu disse lá em cima, existe uma tonelada de programas hoje em dia.  O programa usado no curso foi do Project Libre. Vou colocar a primeira aula de um curso inteiro que está disponível no youtube aqui sobre como usar esse programa para aqueles interessados nele.    Monitoramento e Controle​  A atividade de monitoramento é filha do planejamento. Pode ser focada em processos ou em resultados. O foco no processo é o processo tradicional que tende a ser mais burocrático e lento enquanto o foco em entregas é o principal objetivo das metodologias ágeis de desenvolvimento.  Não tem certo e errado, cada projeto deve ser avaliado e, a depender de onde se quer chegar, opta-se pela metodologia mais adequada.  A atividade e monitoramento tem como objetivo:  Minimizar os danos que a complexidade do projeto pode trazer para as entregasReduzir incertezas e riscosAdministrar conflitosAcompanhar o andamento do planejamento  Abaixo temos uma lista de técnicas usadas nessa área:  ReuniõesCronogramasGráfico de GanttRede PERT\\CPMPlanos 5W2HAnálise SWOTMonitoramento de Partes Interessadas (Poder x Interesse)KanBanBurndown Chart  Encerramento de Projeto​  Uma vez monitorado, a última fase que nos resta é o término.  Nessa fase temos que levantar as entregas finais e compilar os aprendizados gerados ao longo de todas as etapas de monitoramento.  Perfil do Gerente de Projetos​  Um bom gerente de projetos deve ter algumas características desejáveis:  Conhecimento das normasEntendimento do ambienteConhecimento de gerenciamento geralHabilidades interpessoais  E deve estar preparado para alguns conflitos clássicos dessa área:  Conflito autoridade x responsabilidadeEstimativas erradasDisputas de poder nas equipesProcura por salvador\\culpadoPressões de grupos de interesseFalta da maturidade da equipeFalta de engajamento  ","version":"Next","tagName":"h3"},{"title":"Gerenciamento Ágil​","type":1,"pageTitle":"Gerência de Projetos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-projetos#gerenciamento-ágil","content":" Gerência Ágil de Projetos​  Já aprendemos um pouco sobre esse tema lá no primeiro período. Então vou ser bem sucinto aqui.  Breve histórico​  Para a gente que está começando a vida de desenvolvedor agora, isso tudo parece muito simples, mas o passado era completamente diferente no mercado de tecnologia.  Entre as décadas de 60 e 90, não existiam métodos amplamente divulgados e padronizados de desenvolvimento. Era tudo mato mesmo.  A primeira vitória significativa na tentativa de padronização ocorreu em 1990 com a criação do Rational Unified Process (RUP) que também vimos na matéria de introdução a engenharia de software.  O Manifesto Ágil​  Com o passar do tempo, o foco na entrega se tornou cada vez mais evidente até que o Manifesto Ágil criou o marco para a mudança do método de gestão de projetos no começo do século XXI. Dele podemos derivar os seguintes princípios:  Foco na entrega de software o mais rápido e com máxima frequência possívelAceitação às mudanças de requisitos a qualquer tempoMaior aproximação com o clienteFomentar um clima de sinergia e colaboração  Só pra gente ter uma ideia, eu pedi pro ChatGPT dar um resumo de quem foram os caras que assinaram esse manifesto.  Kent Beck: um desenvolvedor de software americano, conhecido por ter criado o Extreme Programming (XP) e por ter trabalhado em projetos como o Smalltalk e o C++. Mike Beedle: um consultor de gerenciamento de projetos e desenvolvedor de software americano, que também ajudou a desenvolver o Enterprise Scrum. Arie van Bennekum: um consultor holandês de gerenciamento de projetos, que trabalhou em vários projetos de desenvolvimento de software usando metodologias ágeis. Alistair Cockburn: um consultor de gerenciamento de projetos e desenvolvedor de software britânico, conhecido por ter criado o método Crystal para desenvolvimento de software. Ward Cunningham: um desenvolvedor de software americano, conhecido por ter criado a primeira wiki e por ter trabalhado em projetos como o Framework para Desenvolvimento de Aplicações (FDP) em Smalltalk. Martin Fowler: um consultor de desenvolvimento de software britânico, que escreveu vários livros sobre design de software e desenvolvimento ágil, e que ajudou a popularizar o Refactoring. James Grenning: um desenvolvedor de software americano, que trabalha com XP e ajuda a promover práticas ágeis em todo o mundo. Jim Highsmith: um consultor americano de gerenciamento de projetos, que ajudou a popularizar o Agile Project Management e o Adaptive Software Development. Andrew Hunt: um desenvolvedor de software americano, conhecido por ter escrito o livro &quot;The Pragmatic Programmer&quot; e por ter trabalhado em vários projetos de software usando metodologias ágeis. Ron Jeffries: um desenvolvedor de software americano, conhecido por ter criado o XP com Kent Beck e por ter trabalhado em vários projetos de desenvolvimento de software usando metodologias ágeis. Jon Kern: um consultor americano de gerenciamento de projetos, que trabalhou em vários projetos de desenvolvimento de software usando metodologias ágeis. Brian Marick: um consultor americano de gerenciamento de projetos, que trabalha com XP e ajuda a promover práticas ágeis em todo o mundo. Robert C. Martin: um consultor americano de desenvolvimento de software, que escreveu vários livros sobre design de software e metodologias ágeis, e que ajudou a popularizar o TDD (Desenvolvimento Guiado por Testes). Steve Mellor: um engenheiro de software britânico, conhecido por ter criado a linguagem de modelagem de sistemas OO (OOM) e por ter trabalhado em projetos de software usando metodologias ágeis. Ken Schwaber: um consultor americano de gerenciamento de projetos, que ajudou a desenvolver o Scrum e a promover práticas ágeis em todo o mundo. Jeff Sutherland: um consultor americano de gerenciamento de projetos, que ajudou a desenvolver o Scrum e a promover práticas ágeis em todo o mundo. Tem uma ampla experiência em liderança, gerenciamento e desenvolvimento de software. Dave Thomas: um desenvolvedor de software canadense, conhecido por ter criado a linguagem de programação Elixir, por ter trabalhado em projetos como o desenvolvimento da linguagem Ruby e por ter escrito vários livros sobre programação e desenvolvimento de software, incluindo &quot;Programming Elixir&quot; e &quot;The Pragmatic Programmer&quot;. Dave é um forte defensor de metodologias ágeis e da programação funcional.  Junto com o manifesto surgiram os 14 princípios ágeis. Quando as coisas vão ficando muito grandes pra decorar eu acho que não vale a pena. Pra quem achar importante, pode pesquisar pra ler a respeito.  Para encerrar esse apanhado podemos destacar os principais métodos ágeis hoje no mercado:  XPScrumLeanTDD  O Método Ágil Scrum​  Já vimos um pouco desse assunto na parte de introdução à engenharia de software mas aqui vamos dar mais contexto sobre ele.  O método é baseado no guia do scrum que eu fiz questão de inserir aqui no material.    O método do Scrum é mais indicado para projetos com as seguintes características:  Projetos de curta duraçãoEquipe reduzidaProximidade entre membros da equipeUma equipe com algum nível de preparoPresença do clienteAmbiente informal  Ele pode ser integrado à ferramentas como o kanban e pode ser associado a outros métodos ágeis de gestão de projetos.  Comentário Como já aprendemos sobre os papéis, os artefatos e os eventos do scrum antes, não vou repetir esse conteúdo aqui. Caso não se lembre do que estou falando, volte no primeiro período e revise.  No planejamento de um sprint, devemos sempre responder essas duas questões norteadoras:  O que deve ser entregue?Qual o trabalho necessário para essa entrega?  Introdução ao XP​  O eXtreme Programming (XP) é um outro método ágil muito comum no Brasil e no mundo. Alguns dos nomes do manifesto ágil foram os criados desse método.  O foco do XP é no desenvolvimento orientado para a entrega do código no menor tempo possível.  As premissas do XP são:  Equipes pequenasProjetos curtosDe 1.000 a 250.000 linhas de código  O papéis dos atores atuante no XP são:  Programadores (foco principal)Treinador\\TécnicoAcompanhador\\TrackerCliente  Valores do XP:  ComunicaçãoFeedbackCoragemSimplicidadeRespeito  Para finalizar essa seção de listas, temos as 12 práticas preconizadas pelo XP:  PlanejamentoFases PequenasMetáfora para ExplicaçãoDesign SimplesTestesRefatoramentoProgramação PareadaPropriedade ColetivaIntegração ContínuaSemana de 40 horasCliente Junto do DesenvolvimentoPadronização do Código  Dessas práticas, podemos destacar que o foco na parte de testes é muito relevante na aplicação desse método.  Frameworks e Práticas Ágeis​  Agora que aprendemos sobre os 2 métodos mais usados. Vamos fazer uma passagem rápida sobre os outros que, mesmo não sendo tão famosos, são usados por inúmeros times de desenvolvimento ao redor do mundo.  Dynamic Systems Development Method (DSDM)​  Nascido na década de 1990 no Reino Unido, ele é um dos mais antigos. Tem como características:  Desenvolvimento incrementalColaboração cliente-desenvolvimentoFunções integradasFlexibilidade dos requisitos  Test Driven Development (TDD)​  O TDD é fruto do XP tendo como ponto central o teste de software. O foco é tanto que tudo se inicia no desenho dos testes antes do código.  O método de desenvolvimento no TDD é:  Escrever o teste que apontará um status vermelhoFaz-se a atualização do sistema para atendimento dessa nova funcionalidadeRefaz-se o teste para que o status seja verdeRefatoração do código da funcionalidadePróximo teste  Lean Development​  Também nascido em 1990, surgiu no contexto da indústria automotiva. Seu principal foco é o gasto mínimo de recursos.  Tem como guia os seus 7 princípios:  Eliminar desperdíciosAmpliar o conhecimentoFortalecer o timeEntregas rápidasOtimizar o todoConstruir qualidadeAdiar decisões  Crystal Family​  É um leque de métodos criado por Alistair Cockburn. Tem como principais práticas:  Entregas regularesMonitoramento do progressoEnvolvimento direto com clienteInspeções constantes nos incrementosfeedback para ajuste do produto  Método Squad​  Surgido em 2014 no Spotify, é um método que tem como base:  Squad - Grupo interdisciplinar de pessoas com uma missãoO líder que serve ao grupoEquipes sempre pequenas  Tem como princípios:  ComunicaçãoChapters - Pessoa com especialidade que compõe um SquadTribes - Conjunto de Squads com objetivos parecidosGuilds - Lideranças de alianças de Squads  Conclusão ou Como escolher?​  A bem da verdade, na vida real, a chance de eu ou algum de vocês ter que decidir qual metodologia a empresa que a gente for trabalhar vai usar é bem baixa.  Entretanto, saber sobre esses métodos pode ajudar muito no processo de adaptação quando iniciarmos nossa caminhada no mundo do desenvolvimento e, quem sabe, realmente essa responsabilidade caia no colo de algum de nós.  O importante é entender os principais pontos de cada metodologia afim de sermos capaz até mesmo de mesclar as principais vantagens para o cumprimento de um projeto.  ","version":"Next","tagName":"h3"},{"title":"Ferramentas e Técnicas​","type":1,"pageTitle":"Gerência de Projetos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-projetos#ferramentas-e-técnicas","content":" Ferramentas e Técnicas para Planejamento​  Existem uma infinidade de ferramentas disponíveis hoje em dia para a realização das atividades de gestão de projetos. Independente disso, as ferramentas que escolhermos devem ter algumas features desejáveis como:  Métricas e estimativasCronogramasGestão de equipesOrçamento  Além disso, precisamos garantir que algumas características do projeto estejam bem definidas:  Escopo e IdeiasFormação das equipes  Essas características se aplicam tanto à metodologias ágeis quanto às tradicionais com maior e menor grau de significância para cada um desses itens.  Ferramentas e Técnicas para Gestão​  Uma vez feito o planejamento, o próximo passo é a gestão para que os objetivos sejam alcançados ao final do prazo e dos recursos disponíveis no projeto.  Da mesma maneira que temos várias ferramentas disponíveis no planejamento, também temos várias opções para a gestão. Entretanto, vale destacar que existe pouca probabilidade que nós encontremos um software que atenda perfeitamente todas as várias áreas da gestão de um projeto.  Normalmente, o mesmo sistema que permite o planejamento também permite a gestão. O motivo disso é que a gestão é a próxima etapa lógica ao processo de planejamento então muitas informações são parecidas.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Gerência de Projetos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-projetos#bibliografia","content":" GUIA do conhecimento em gerenciamento de projetos: (Guia PMBOK®). 6. ed. São Paulo: Project Management Institute, 2017. xxix, 755 p. ISBN 9781628251920., Nº de Exemplares: 7.VALERIANO, Dalton L. Gerenciamento Estratégico e Administração por Projetos. Pearson 324 ISBN 9788534612081.VITOR L. MASSARI. Gerenciamento Ágil de Projetos - 2ª Edição. Editora Brasport 0 ISBN 9788574528939.BROD, Cesar. Scrum: guia prático para projetos ágeis. 2. ed. São Paulo, SP: Novatec, 2015. 198 p. ISBN 9788575224410.    Footnotes​ E olha que eu sou formado em Economia. ↩ PERT é de 1957 e o CPM é de 1958. ↩ ","version":"Next","tagName":"h2"},{"title":"Gerência de Requisitos","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-requisitos","content":"","keywords":"","version":"Next"},{"title":"Administração e Rastreabilidade de Requisitos​","type":1,"pageTitle":"Gerência de Requisitos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-requisitos#administração-e-rastreabilidade-de-requisitos","content":" ","version":"Next","tagName":"h2"},{"title":"Introdução à Gerencia de Requisitos​","type":1,"pageTitle":"Gerência de Requisitos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-requisitos#introdução-à-gerencia-de-requisitos","content":" Requisitos de Software​  Como disse Frederick Brooks: &quot;A parte mais difícil de construir um sistema de software é decidir exatamente o que construir&quot;.  É exatamente nesse contexto que as técnicas de elicitação de requisitos e definição de escopo que a engenharia de software desenvolveu atuam. Uma vez definido o que se deseja, nascem os Requisitos de Software.  Podemos entender os requisitos como características e limitações que nossa solução terá. Além disso, esse conceito está relacionado à documentação a respeito dessas duas naturezas.  Existem diferentes tipos de requisitos de software. Podemos agrupa-los em:  Requisitos Funcionais - &quot;O que o software deve fazer?&quot;Requisitos Não Funcionais - &quot;Como o software deve operar?&quot;  Além dessa classificação quanto a tipo de requisito, podemos agrupa-los segundo o seu nível de abstração:  Requisitos de Produto - Características sobre o produto em siRequisitos de Projeto - Características do processo de desenvolvimentoRequisitos de Sistema - Características sobre a arquitetura da solução  Quando estamos redigindo o artefato que contém os requisitos temos que nos atentar para captar os atributos dos requisitos para que todos os envolvidos possam usar essa fonte de informação de maneira efetiva.  Dentre os atributos, podemos destacar alguns muitos importantes:  IdentificadorNomeDescriçãoVersãoAutorFonteRiscoPrioridadeResponsávelTipoStatus do ConteúdoStatus da ValidaçãoStatus do AcordoEsforço\\DificuldadeVersão\\ReleaseObrigações LegaisReferência Cruzada com outros requisitosObservações  Comentário Pois é, quem achava que gerir requisito era só anotar em post-it tá muito enganado. Tudo isso deve ser, idealmente, coletado para que o processo de desenvolvimento seja feito de maneira produtiva e que o produto final atenda as expectativas do clientes.  Stakeholders​  Até aqui, temos um bom entendimento de que precisamos entender profundamente o que nossa solução fara e como será feito. Entretanto, ainda temos uma pergunta muito importante a ser respondida: Para quem?.  É justamente para responder essa pergunta que temos mais uma palavra em inglês para aprendermos (e parecer inteligentes naquele churrasco de domingo). A palavra é Stakeholder.  Esse termo é usado para definir as partes interessadas (podem ser indivíduos específicos ou grupos de pessoas) no programa que vamos construir. Essas partes podem ser de dentro ou fora da organização. A única regra para a definição é ser impactado com o nosso produto de software.  Basicamente, podemos dividir os stakeholders em três grandes grupos:  ExternosInternosTime de desenvolvimento  Desse modo, os requisitos sempre são relacionados a, pelo menos, um stakeholder. Normalmente, um projeto possui um número bem grande deles.  Um grupo de stakeholders particularmente muito importante são os Clientes e, dentro desse grupo, os Usuários. São eles (principalmente o segundo) quem realmente trazem as demandas concretas que terão grande relevância no desenvolvimento do nosso sistema.  Aqui tem um vídeo com um resumo animado desse assunto que vimos.    Atividades de Gerenciamento de Requisitos​  A essa altura, já percebemos que qualquer software, que não seja um aplicativo pessoal que criamos para resolver problemas apenas nossos, possui uma grande lista de requisitos. Diante disso, precisamos de técnicas para agrupar, priorizar, validar e acompanhar esses vários requisitos.  É justamente nesse contexto que a Engenharia de Requisitos surge. Inicialmente, podemos dividi-la em dois grupos de atividades:  DesenvolvimentoGerenciamento  Na primeira fase, estamos conhecendo melhor as necessidades e levantando a real necessidade1. Essa fase é dividida em quatro subareas:  Elicitação - levantamento dos requisitosAnálise - verificação da harmonia dos requisitosEspecificação - produção da documentaçãoValidação - aprovação do baseline pelo cliente  Cabe a gerência de requisitos o acompanhamento da fase de desenvolvimento para que as mudanças (que sempre irão ocorrer) sejam adequadamente inseridas e documentadas para o atingimento da meta. Similar a fase de desenvolvimento, temos quatro subareas dessa atividade:  Controle de VersãoControle de MudançasAcompanhamento do StatusRastreabilidade  ","version":"Next","tagName":"h3"},{"title":"Administração de Requisitos​","type":1,"pageTitle":"Gerência de Requisitos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-requisitos#administração-de-requisitos","content":" Controle de Versão​  Não podemos nos enganar. Nossa cabeça ao ler algo como &quot;controle de versão&quot; pensa logo em versionamento de código com git e github mas não é nada disso que vamos lidar agora.  O controle de versão como subárea da engenharia de requisitos é a atividade relacionada ao controle da documentação de baseline que é a guia para as fases de desenvolvimento de artefatos do projeto.  Sempre que o cliente muda de ideia, é responsabilidade dessa área em atualizar a documentação e comunicar a todos os setores impactados com essa mudança afim de evitar que algum esforço seja desperdiçado em atividades que não estão mais contempladas na baseline vigente do projeto.  Para manter o controle da documentação, usamos comumente o versionamento semântico para indicar as mudanças. Normalmente, podemos dividir as versões em 3 componentes:  Major Version + Minor Version + Patch  Como exemplo, nesse momento eu estou escrevendo esse trecho do material no Visual Studio Code versão 1.77.0. Ou seja, Major Version = 1, Minor Version = 77 e patch = 0.  Acompanhamento do Status​  Não adianta nada levantar todas as necessidades sem que haja um trabalho de atualização do status em cada um deles.  O trabalho de acompanhamento é crucial para responder preguntas como &quot;Quantos porcento do projeto já foi implementado?&quot; ou &quot;Ainda faltam quantas funcionalidades para ser implementadas?&quot;.  Cada requisito deve receber um status que foi previamente acordado de acordo com a prática de desenvolvimento de cada local. Normalmente, temos os seguintes status nos projetos:  PropostoEm progressoRascunhadoAprovadoImplementadoVerificadoDeferidoDeletadoRejeitado  Isso mesmo, vale muito a pena manter memória inclusive das ideias que foram descartadas porque, em várias situações, elas podem ser fontes de insights úteis.  ","version":"Next","tagName":"h3"},{"title":"Rastreabilidade de Requisitos​","type":1,"pageTitle":"Gerência de Requisitos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-requisitos#rastreabilidade-de-requisitos","content":" Tipos de Rastreabilidade​  Se temos uma certeza é a de que o projeto sofrerá mudanças ao longo do tempo. A medida que as necessidades do nosso cliente mudam, os requisitos também serão modificados. Para isso, temos que ser capazes de rastrear o impacto que essas mudanças trarão ao nosso pojeto.  Para isso, temos que ser capazes de realizar as ligações entre os requisitos e os elementos do sistema (outros requisitos, artefatos, código e etc).  A ligação entre requisitos é chamada de rastreabilidade horizontal. Já a relação entre os requisitos e os artefatos gerados por causa dele(s) é chamada de rastreabilidade vertical.  O nome dessa habilidade é o que chamamos de rastreabilidade de requisitos. É ela que nos permite interligar para saber quais impactos as mudanças terão no nosso projeto.  Matriz de Rastreabilidade​  Agora que sabemos a importância da rastreabilidade. Temos que saber como fazer esse trabalho. De longe, a principal ferramenta usada para essa tarefa complexa é a matriz de rastreabilidade.  Para a construção, colocamos todos os requisitos, stakeholders e artefatos nas linhas e nas colunas colocamos requisitos e artefatos. Usamos uma marcação (como um x) para indicar que linha e coluna são relacionados.    ","version":"Next","tagName":"h3"},{"title":"Priorização e Gerência de Mudanças de Requisitos​","type":1,"pageTitle":"Gerência de Requisitos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-requisitos#priorização-e-gerência-de-mudanças-de-requisitos","content":" ","version":"Next","tagName":"h2"},{"title":"Priorização de Requisitos​","type":1,"pageTitle":"Gerência de Requisitos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-requisitos#priorização-de-requisitos","content":" Identificando Prioridades​  Todo projeto possui sempre duas restrições: tempo e dinheiro. Diante disso, ser capaz de indicar as prioridades é fundamental.  É claro que, uma vez que tenhamos nossa matriz de rastreabilidade preenchida. Não será muito complexo saber quais são os requisitos mais centrais ao nosso projeto, uma vez que, é comum que requisitos mais importantes sejam mais relacionados que os menos relevantes.  Além disso, temos algumas técnicas para elicitar os requisitos junto ao cliente. Podemos destacar 4 técnicas principais usadas nesse processo.  In or Out​  Essa técnica envolve classificar os requisitos em duas categorias: &quot;dentro&quot; ou &quot;fora&quot; do escopo do projeto. Os stakeholders são solicitados a revisar e categorizar cada requisito como relevante e necessário (&quot;dentro&quot;) ou irrelevante ou fora do escopo (&quot;fora&quot;). Isso ajuda a identificar os requisitos que são essenciais para o sucesso do projeto.  Pairwise Comparison and Rank Ordering​  Essa técnica envolve comparar e classificar os requisitos em pares. Os requisitos são apresentados aos stakeholders em pares, e eles devem indicar qual requisito é mais importante ou prioritário em cada par. Com base nas respostas, é possível construir uma lista classificada dos requisitos por ordem de importância.  Three-Level Scale​  Nessa técnica, os requisitos são classificados em três níveis: alta prioridade, média prioridade e baixa prioridade. Os stakeholders avaliam cada requisito e atribuem um dos três níveis de prioridade, com base na importância percebida do requisito para o sucesso do projeto. Essa técnica é simples e eficiente para classificar os requisitos em categorias de prioridade.  Uma vez que tenhamos essa avaliação, vamos classificar os requisitos com base em 2 critérios:  Urgente x Não tão urgenteImportante x Não tão importante  Com base nessa classificação saberemos em que etapas focar primeiro no processo de desenvolvimento.  MoSCoW (Must-have, Should-have, Could-have e Won't-have)​  Nessa técnica, os requisitos são agrupados em quatro categorias:  Must-have: São requisitos essenciais, sem os quais o projeto não pode ser considerado bem-sucedido.Should-have: São requisitos importantes, mas não essenciais. Sua inclusão é altamente desejável, mas o projeto pode progredir sem eles.Could-have: São requisitos considerados como opcionais ou desejáveis. Sua inclusão pode trazer benefícios adicionais ao projeto, mas não são críticos.Won't-have: São requisitos que não serão incluídos no projeto atual, mas podem ser considerados para projetos futuros.  $100 (hundred dollar)​  Os stakeholders recebem uma quantia fictícia de &quot;100 dólares&quot; e devem distribuir esse dinheiro entre os diferentes requisitos, de acordo com a importância percebida de cada um. Eles podem gastar mais dinheiro nos requisitos mais importantes e menos dinheiro nos requisitos menos prioritários.  ","version":"Next","tagName":"h3"},{"title":"Gerência de Mudanças de Requisitos​","type":1,"pageTitle":"Gerência de Requisitos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-requisitos#gerência-de-mudanças-de-requisitos","content":" Processo de Controle de Mudanças​  Agora que sabemos levantar, relacionar e priorizar os requisitos. Precisamos de uma última habilidade relacionada a gestão que é a gestão de mudanças.  O foco dessa atividade é reduzir o risco e padronizar o processo de mutação das necessidades do cliente para que a coerência do projeto não seja comprometida bem como esclarecer como essas mudanças trarão impactos ao projeto.  Para isso temos um artefato de solicitação de mudança. Com status parecidos ao dos requisitos:  SubmetidaAvaliadoAprovadoRealizadaVerificadaEncerradaRejeitadaCancelada  Comitê de Controle de Mudanças​  Como uma mudança dos requisitos é algo que pode ter impacto profundo no projeto em andamento, é muito comum a construção de um grupo de trabalho chamado de Comitê de Controle de Mudanças\\Change Control Board para que uma avaliação interdisciplinar seja realizada nessas mudanças potenciais afim de termos uma avaliação melhor do impacto da mesma no todo do projeto.  Quem vai compor esse comitê é uma lista ampla de profissionais que vão desde o time de desenvolvimento até o staff gerencial.  Análise de Impacto de Mudanças​  Podemos dizer que a maior responsabilidade do Comitê de Controle de Mudanças seja a avaliação do impacto de uma mudança proposta. Isso é feito com base nos instrumentos que já vimos anteriormente nesse microfundamento e a experiência do board para sabermos se vale a pena.  A análise sempre deve se basear no trade-off entre custo e benefícios da proposta.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Gerência de Requisitos","url":"/CC_site/docs/puc/terceiro-periodo/gerencia-requisitos#bibliografia","content":" REINEHR, Sheila. Engenharia de requisitos. Porto Alegre SAGAH 2020 1 recurso online - (Engenharia de software). ISBN 9786556900674. Capítulos 2, 3 e 14.CARLOS EDUARDO VAZQUEZ; GUILHERME SIQUEIRA SIMÕES. Engenharia de Requisitos: - software orientado ao negócio. Editora Brasport 0 ISBN 9788574527963.WIEGERS, Karl; JOY, Beatty. Software Requirements (Developer Best Practices). - Microsoft Press. ISBN 0735679665. Capítulos 1, 2, 3 e 27.VALENTE, Marco Tulio. Engenharia de Software Moderna: Princípios e Práticas para Desenvolvimento de Software com Produtividade, 2020.PRESSMAN, Roger S.; MAXIM, Bruce R. Engenharia de software: uma abordagem profissional. 8. ed. Porto Alegre: AMGH, 2016. E-book ISBN 9788580555349.SOMMERVILLE, Ian. Engenharia de software, 10ª ed. Pearson 768 ISBN 9788543024974.PAULA FILHO, Wilson de Pádua. Engenharia de software, v. 2 projetos e processos. 4. - Rio de Janeiro LTC 2019 1 recurso online ISBN 9788521636748.VETORAZZO, Adriana de Souza. Engenharia de software. Porto Alegre SAGAH 2018 1 - recurso online ISBN 9788595026780.WAZLAWICK, Raul Sidnei. Engenharia de software conceitos e práticas. Rio de Janeiro GEN LTC 2013 1 recurso online ISBN 9788595156173.    Footnotes​ Acredite, não é nada raro o próprio cliente não ter uma noção estrutura da real necessidade dele. Cabe ao gerente de requisitos fazer essa extração das necessidades e amadurecer a ideia na cabeça do cliente. ↩ ","version":"Next","tagName":"h2"},{"title":"Qualidade de Processos de Software","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/terceiro-periodo/qualidade-processos","content":"","keywords":"","version":"Next"},{"title":"Fundamentos da Qualidade de Software​","type":1,"pageTitle":"Qualidade de Processos de Software","url":"/CC_site/docs/puc/terceiro-periodo/qualidade-processos#fundamentos-da-qualidade-de-software","content":" ","version":"Next","tagName":"h2"},{"title":"Introdução a Qualidade de Software​","type":1,"pageTitle":"Qualidade de Processos de Software","url":"/CC_site/docs/puc/terceiro-periodo/qualidade-processos#introdução-a-qualidade-de-software","content":" Conceitos da qualidade de software​  Podemos discutir um tempão sobre como definir o conceito de qualidade. Entretanto, podemos entender como Qualidade de Software a capacidade de estar em conformidade com os requisitos do sistema. Outra maneira de conceitualizar, é dizer que é a capacidade de cumprir a expectativa do cliente relacionadas ao produto a ser desenvolvido.  ","version":"Next","tagName":"h3"},{"title":"Projeto de Software​","type":1,"pageTitle":"Qualidade de Processos de Software","url":"/CC_site/docs/puc/terceiro-periodo/qualidade-processos#projeto-de-software","content":" Projeto de software​  O primeiro passo para a construção de uma solução é, como já vimos tantas e tantas vezes ao longo do curso, a criação do Projeto de Software que terá como obrigação cumprir as necessidades elencadas na elicitação dos requisitos feita anteriormente. Não podemos falar de qualidade sem levar em consideração os requisitos.  Na construção do projeto temos duas etapas:  Projeto Preliminar - Vamos buscar traduzir os requisitos em um modelo de arquitetura geral da solução.Projeto Detalhado - Vamos elaborar todos os documentos que estudamos nos outros microfundamentos de gestão.  Um projeto deve ser capaz de conciliar esforços de compreensão de diversas áreas. O professor da matéria propõe uma equação matemática para elucidar essas áreas:  Projeto=Objetos+Atividades+Prazos+Recursos Necessaˊrios+Riscos/IncertezasProjeto = Objetos + Atividades + Prazos + Recursos\\ Necessários + Riscos/IncertezasProjeto=Objetos+Atividades+Prazos+Recursos Necessaˊrios+Riscos/Incertezas  Gestão de Projeto de Software​  Se existe o trabalho de criar um projeto, então, vai existir o trabalho de monitorar o processo de criação. Podemos resumir esse trabalho gerencial em:  Planejamento Escopo preliminar do produtoEstimativa de prazosProcessos de desenvolvimento Controle da Execução Alocação dos recursosValidação das entregasReplanejamentoAcompanhamento das tarefas e orçamento Monitoramento Progresso do processoQualidade dos produtosProdutividadeFinanças do projeto  Como dá pra perceber. Não é a toa que existe o cargo de gerente de projeto como uma das carreiras em um ambiente de tecnologia. Pra dar uma ideia ainda maior de como isso é relevante, aqui em baixo tá a página de anúncios de vagas do linkedin com vagas de gerente de projeto (da pra ver que não paga nada mal).    ","version":"Next","tagName":"h3"},{"title":"Processo e Produto de Software​","type":1,"pageTitle":"Qualidade de Processos de Software","url":"/CC_site/docs/puc/terceiro-periodo/qualidade-processos#processo-e-produto-de-software","content":" Processo de software​  Também chamado de Processo de Desenvolvimento de Software, é onde queremos atuar e é o motivo de estarmos lendo esse material agora mesmo. Como vimos em vários outros microfundamentos, existem dois grantes tipos de processos de software:  Processos em Cascata Levantamento de requisitosProjeto de alto nívelProjeto detalhadoCodificaçãoTestesImplantação Processos Ágeis Produção incremental e iterativaCiclos de incrementosPouco foco na documentaçãoDesign da solução criado ao longo do processoEquipes de menor porte  Produto de software​  Se temos um processo de software, é claro que vamos ter um produto no final dele. Mas o que seria essa entrega? Bom, podemos definir como resultado da entrega um conjunto de elementos listados na equação abaixo.  Produto de Sofware=Programa+Procedimentos+Documentac\\ca~o+DadosProduto\\ de\\ Sofware = Programa + Procedimentos + Documentação + DadosProduto de Sofware=Programa+Procedimentos+Documentac\\c​a~o+Dados  Além dessa entrega, temos os processo derivados da utilização do sistema criado a medida que os usuários utilizam o produto. Desse modo, as atividades de manutenção e ajuste de bugs são também relacionadas ao produto de software.  ","version":"Next","tagName":"h3"},{"title":"Normas e Maturidade de Processos de Software​","type":1,"pageTitle":"Qualidade de Processos de Software","url":"/CC_site/docs/puc/terceiro-periodo/qualidade-processos#normas-e-maturidade-de-processos-de-software","content":" ","version":"Next","tagName":"h2"},{"title":"Normas técnicas aplicadas a Qualidade de Software​","type":1,"pageTitle":"Qualidade de Processos de Software","url":"/CC_site/docs/puc/terceiro-periodo/qualidade-processos#normas-técnicas-aplicadas-a-qualidade-de-software","content":" Normas Técnicas​  ","version":"Next","tagName":"h3"},{"title":"Processo de Avaliação da Qualidade de Software​","type":1,"pageTitle":"Qualidade de Processos de Software","url":"/CC_site/docs/puc/terceiro-periodo/qualidade-processos#processo-de-avaliação-da-qualidade-de-software","content":" Processo de Avaliação​  ","version":"Next","tagName":"h3"},{"title":"Maturidade de processos de software​","type":1,"pageTitle":"Qualidade de Processos de Software","url":"/CC_site/docs/puc/terceiro-periodo/qualidade-processos#maturidade-de-processos-de-software","content":" Introdução aos Modelos de Maturidade de Processos de Software​  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Qualidade de Processos de Software","url":"/CC_site/docs/puc/terceiro-periodo/qualidade-processos#bibliografia","content":" PRESSMAN, Roger S.; MAXIM, Bruce R.; ARAKAKI, Reginaldo; ARAKAKI, Julio; ANDRADE, Renato Manzan de; TORTELLO, João E. N. Engenharia de software: uma abordagem profissional. 8. ed. Porto Alegre: AMGH, 2016. 1 recurso online ISBN 9788580555349.SOMMERVILLE, Ian. Engenharia de Software. 10. ed. São Paulo: Pearson Prentice Hall, 2019. 1 recurso online ISBN 9788543024974.Gallotti, Giocondo Marino Antônio. Qualidade de Software. 1 ed. São Paulo: Pearson Prentice Hall, 2016. 1 recurso online ISBN 9788543020358.Zanin, Aline et all. Qualidade de Software. Porto Alegre: SAGAH, 2018. E-book. Language: Portuguese, Base de dados: SIB PUC Minas – Busca Integrada.HIRAMA, Kechi. Engenharia de software qualidade e produtividade com tecnologia. Rio de Janeiro GEN LTC 2011 1 recurso online ISBN 9788595155404.MORAIS, Izabelly Soares de. Engenharia de software. Porto Alegre SAGAH 2020 1 recurso online (Ciência da computação). ISBN 9788595022539. ","version":"Next","tagName":"h2"},{"title":"Algoritmo e Estrutura de Dados","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/segundo-periodo/algoritmo-estrutura-dados","content":"","keywords":"","version":"Next"},{"title":"Coleções Nativas das Linguagens de Programação​","type":1,"pageTitle":"Algoritmo e Estrutura de Dados","url":"/CC_site/docs/puc/segundo-periodo/algoritmo-estrutura-dados#coleções-nativas-das-linguagens-de-programação","content":" Vamos relembrar alguns assuntos que aprendemos no período passado na matéria de Algoritmos e Abstração de Dados.  Arrays  São um tipo de tipo abstrato de dados homogêneos. É um conjunto de variáveis apresentadas em uma lista onde cada elemento recebe um índice de 0 a n-1.  A notação de um array depende do tipo nativo da variável com um par de colchetes.  int[] array; // array de inteiros double[] nota; // array de ponto flutuante   Para criarmos um vetor em c# usamos o token new.  ind = new int[10]; nota = new double[12];   No exemplo acima, criamos dois arrays. O primeiro é um array de inteiros de 10 posições e o segundo é um array de double de 12 posições.  Para popularmos o array com valores, usamos o índice da posição como nos exemplos abaixo.  int vet = new int[3]; vet[0] = 1; // valor 1 na primeira posição vet[1] = 10; // valor 10 na segunda posição // valor 1 como a soma dos valores // da posição 2 e 12 vet[0] = vet[1] + vet[11];   Podemos nos valer dos operadores de repetição para sistematicamente fazer uso dos valores de um array.  // operador de posição do array int pos = 0; // Loop para inserir manualmente os // valores no nosso vetor de 3 posicoes for (int i = 0; i &lt; 3; i++) { vet[i] = int.Parse(Console.ReadLine()); } // Loop para sabermos quais valores foram // salvos pelo user for (int i = 0; i &lt; 3; i++) { Console.WriteLine(vet[i]); }   Se tentarmos acessar um valor fora do index de um array com uma posição não aceita, vamos receber um erro chamado Index out of Range Exception.  Comentário Aqui o professor propõe um exercício onde fazemos o input de um nome de aluno e a nota dele. A partir disso, o sistema calcula a média da turma e mostra a lista dos alunos que estão acima de média da turma. Fica ai o desafio para o leitor.  Listas, Pilhas e Filas  A partir do array, podemos entender tipos abstratos de dados que nos darão a base para o estudo desse microfundamento.  O primeiro TAD que vamos aprender é a Lista. Uma lista é um objeto que contém um array que recebe elementos em qualquer posição, um contador de elementos no array e métodos de inserção e remoção.  Uma lista possui alguns métodos úteis para manipulação dos dados:  ConstrutoresInserção de ElementosRemoção de ElementosMostrar ElementoPesquisar indexOrdenar  Como estamos falando de um objeto, o comportamento de cada método deve ser analisado na classe que será instanciada nele.  ","version":"Next","tagName":"h2"},{"title":"Principais Coleções​","type":1,"pageTitle":"Algoritmo e Estrutura de Dados","url":"/CC_site/docs/puc/segundo-periodo/algoritmo-estrutura-dados#principais-coleções","content":" Aprendemos na disciplina de programação modular que existem várias coleções nativas no ambiente .NET que são otimizadas e devem compor o nosso repertório de soluções.  Vale lembrar que para ter acesso às coleções precisaremos acessar o namespace System.Collections.  Agora vamos aprender algumas classes interessantes para o nosso estudo.  ArrayList​  O ArrayList é um objeto similar ao array com a vantagem de podermos redimensionar dinamicamente o seu tamanho (o array simples tem tamanho fixo). A documentação oficial pode ser encontrada nesse link.  Possui um método chamado Capacity que permite a manipulação da capacidade do nosso ArrayList. Por default, o seu valor é zero e, ao inserirmos um elemento, ele muda para quatro. A capacidade do ArrayList dobra automaticamente sempre que temos a necessidade de inserir novos elementos além da capacidade anterior.  Além do método de capacidade, temos o Count que nos dá o número de elementos no ArrayList.  O uso dele é feito através da instanciação do objeto por meio de dois comandos possívels.  // criação sem informar a capacidade ArrayList al1 = new ArrayList(); // criação informando a capacidade inicial ArrayList al2 = new ArrayList(10);   Aqui temos um exemplo simples da utilização desse objeto1.  using System; using System.Collections; class MainClass{ public static void Main (string[] args){ ArrayList al = new ArrayList(); Console.Write(&quot;al.Capacity({0}) | al.Count({1})&quot;,al.Capacity, al.Count); al.Add(1); al.Add(&quot;string qualquer&quot;); al.Add(3.1415); Console.Write(&quot;al.Capacity({0}) | al.Count({1})&quot;,al.Capacity, al.Count); } }   Outra manipulação comum de se utilizar é a de operações em todos os elementos de um ArrayList. Para isso, podemos usar os operadores de repetição como o for e, além desse, um operador cujo token é foreach.   [...] ArrayList al = new ArrayList(); [...] // forma 1 for(int i = 0; i &lt; al.Count(); i++) { Console.WriteLine(al[i]); } // forma 2 foreach(object o in al) { Console.WriteLine(al[o]); } // forma 3 foreach(int num in al) { soma = soma + num; }   Além dos métodos de capacidade e contagem, temos métodos que nos permitem interagir com o nosso arraylist:  Add - Insert de um valor com retorno da posiçãoInsert - Insert de um valor na posição indicadaRemove - Remove um valorRemoveAt - Remove um valor em um determinado indexRemoveRange - Remove uma quantidade de elementos a partir de um indexClear - Remove todos os elementosContains - Teste lógico se um valor existe no arraylistIndexOf - Retorna o index da primeira ocorrência de um valorLastIndexOf - Retorna o index da última ocorrência de um valorReverse - Inverte a ordemSort - Ordena os elementosToArray - Copia os valores em um arrayTrimToSize - Altera o capacityBinarySearch - Realiza uma busca binaria2  Podemos aprender um pouco melhor o uso de alguns desses métodos a partir de um exemplo. Vamos construir um programa que lê 5 inteiros, somar todos em um arraylist e calcular a média deles. Depois disso, vamos mostrar os valores que são maiores que a média. Para isso, vamos usar dois métodos de laços de repetição, um for e um foreach.  using System.Collections; ArrayList list = new ArrayList(); double media = 0; for (int i = 0; i &lt; 5; i++d) { int valor = int.Parse(Console.ReadLine()); list.Add(valor); media += valor; } media /= 5; foreach(object o in lista) { if((int)o &gt; media) { Console.WriteLine(o); } }   Comentário O comando dentro da condicional (int)o é uma das várias maneiras de se converter um item de uma lista em um inteiro. Chamamos essa maneira de TypeCasting3 Além dela poderíamos usar int.Parse() ou Convert.ToInt32(). Aqui tem um texto falando mais sobre isso e a aqui temos a própria documentação da Microsoft.  Queue, Stack e Hashtable​  Além da lista vamos aprender outros conceitos de estrutura de dados muito usados no desenvolvimento de aplicações: Pilhas e Filas.  Uma Pilha ou Stack é um TAD que possui a característica que o primeiro elemento que entra é o último elemento que sai. A essa característica damos o nome de First In, Last Out (FILO).  Comentário Pense em uma pilha de pratos sujos na pia. O prato que foi colocado primeiro é o último prato que será limpo pois está na base da pilha de louça suja.  Uma Fila ou Queue é um TAD em que o primeiro elemento que entra é o primeiro a sair. O nome dessa característica é Fist In, First Out (FIFO).  As duas classes possuem métodos parecidos (dadas as diferenças já comentadas acima):  enqueue/push - Inserção de objetosdequeue/pop - Remoção de objetosclear - Remoção de todos os objetoscontains - Retorno se um objeto está contidopeek - Retorna o próximo objeto na ordem de remoçãocount - Quantidade de elementos na estrutura  Aqui o professor propõe um desafio bem legal. Vamos ver um código c# com um programa de fila e transcrever para idioma o que o programa faz.  Queue f = new Queue(); f.Enqueue(1); f.Enqueue(2); f.Enqueue(3); Console.Write(&quot;Fila: ({0}) / ({1}) / ({2})&quot;,f.Contains(1), f.Count, f.Peek()); Console.WriteLine(f.Dequeue()); Console.Write(&quot;Fila: ({0}) / ({1}) / ({2})&quot;,f.Contains(1), f.Count, f.Peek());   Agora um outro programa para uma pilha.  Stack p = new Stack(); p.Push(1); p.Push(2); p.Push(3); Console.Write(&quot;Pilha: ({0}) / ({1}) / ({2})&quot;,p.Contains(1), p.Count, p.Peek()); Console.WriteLine(p.Pop()); Console.Write(&quot;Pilha: ({0}) / ({1}) / ({2})&quot;,p.Contains(1), p.Count, p.Peek());   A terceira estrutura de dados que vamos aprender é chamada Hashtable. Essa estrutura é do tipo dicionário, ou seja, para cada entrada de dados, temos uma par chave-valor. Podemos dividir o nome desse TAD em duas palavras: hash e table.  Table é simplesmente uma alusão à tabela. O que temos de novidade aqui é o termo hash.  Comentário Esse material é, em tese, um resumo dos conteúdos dados na graduação da PUC-MG, entretanto, quando eu sinto que o tópico está demasiadamente superficial, eu simplesmente não consigo evitar de expandir o conteúdo originalmente dado. Essa parte eu tirei do livro &quot;Data Structures and Algorithms with Python&quot;.  A primeira coisa que precisamos para entender o que é esse conceito de hash é compreender que programas acessam a memória e que o tempo necessário para realizar esse trabalho pode variar de acordo com a maneira que os programas são construídos. Para lidar com essa preocupação os cientistas da computação criaram o conceito de notação Omnicron ou Big-Oh.  Formalmente, dada uma lista qualquer de tamanho nnn, cujo tempo de acesso médio para coleta de um elemento dessa lista é dado pode f(n)f(n)f(n). Podemos definir que:  O(g(n))={f∣∃d&gt;0,n0∈Z+i0≤f(n)≤dg(n),∀n≥n0}\\mathcal{O}(g(n)) = \\{ f | \\exists d &gt; 0, n_0 \\in \\mathbb{Z}^+ i 0 \\leq f(n) \\leq d g(n),\\forall n \\geq n_0 \\}O(g(n))={f∣∃d&gt;0,n0​∈Z+i0≤f(n)≤dg(n),∀n≥n0​}  Calma, respira. Não é nada difícil. Essa notação matemática toda ai quer dizer que podemos definir um grupo funções O(g(n))\\mathcal{O}(g(n))O(g(n)) que são formadas por todas as funções fff4 em que temos algum ddd maior que zero e um n0n_0n0​ que é inteiro e positivo, de modo que, f(n)f(n)f(n) é maior igual a zero e menor igual a ddd vezes g(n)g(n)g(n) para todo nnn maior igual a n0n_0n0​.  Quando dizemos que um determinado programa tem O(1)\\mathcal{O}(1)O(1), estamos dizendo que g(n)=1g(n) = 1g(n)=1, ou seja, que nosso programa pertence ao conjunto de funções fff que, dado um valor qualquer de ddd, tem o tempo de leitura de um elemento entre a faixa de tempo 0≤f(n)≤d0 \\leq f(n) \\leq d0≤f(n)≤d para qualquer nnn da nossa lista.  Tudo isso é pra dizer que essa notação é usada para designar a relação entre o tempo de completude de uma tarefa e o tamanho dos dados necessários para a sua realização (que começa em n0n_0n0​ e vai até nnn). Quando esse acesso à informação de um elemento qualquer não é afetado pelo volume de dados da lista, dizemos que ele possui um tempo de execução constante denotado por O(1)\\mathcal{O}(1)O(1).  Várias operações básicas possuem essa característica como somar, multiplicar ou comparar valores, levam apenas o tempo de um ciclo de computação para ser realizadas.  Agora que entendemos (bem por cima). o conceito de complexidade, podemos entender o conceito de hash. A primeira coisa que precisamos saber é que hashing é uma técnica muito eficiente de pesquisar por um valor.  Imaginem que temos um conjunto de vários elementos e queremos testar se um valor qualquer faz parte ou não desse conjunto. Não é difícil perceber que, caso o tamanho do conjunto aumente muito, o tempo necessário para essa verificação será cada vez maior porque teríamos de verificar se todos os ítens do nosso conjunto são iguais ao elemento que queremos verificar. Entretanto, é ai que podemos aplicar a técnica de hashing para reduzir a complexidade dessa tarefa para O(1)\\mathcal{O}(1)O(1).  Para isso, precisamos compreender que, pelo princípio do acesso randômico, o acesso a qualquer elemento em uma lista é O(1)\\mathcal{O}(1)O(1). Tudo que precisamos fazer é usar uma função que &quot;traduza&quot; os elementos do nosso conjunto para uma lista de referência (ou index). A partir disso, podemos verificar a pertinência de um elemento qualquer simplesmente usando a mesma função para ver se esse novo index já existe na nossa lista de index do conjunto.  Essa função especial é chamada de função de hash.  Tal qual as outras classes, também temos métodos muito úteis que vale a pena conhecer:  add - Insere um objeto com o index na tabelaremove - Remove um objetoclear - Remove todos os objetoscontains - Teste se a tabela contém um objeto com uma dada chavecontainsKey - idem containscontainsValue - Teste se a tabela contém um determinado valorcount - Quantos objetos temos  Só temos que ter alguns cuidados ao usarmos uma estrutura de hashtable porque podemos ter problemas de colisões primárias que acontecem quando a posição no array de index já está ocupada por um elemento.  ","version":"Next","tagName":"h3"},{"title":"Coleções Genéricas​","type":1,"pageTitle":"Algoritmo e Estrutura de Dados","url":"/CC_site/docs/puc/segundo-periodo/algoritmo-estrutura-dados#coleções-genéricas","content":" Começamos a ver esse assunto em programação modular e agora vamos adentrar um pouco mais nele.  Uma grande diferença entre as coleções anteriores e às genéricas é que nas últimas temos que declarar os tipos no momento da criação sem possibilidade de misturar tipos dentro do objeto. Enquanto as classes padrões permitiam qualquer tipo de dados misturados.  Comentário O &lt;T&gt; na escrita dessas classes é justamente para indicar que somos obrigados a indicar o tipo do dado no momento da criação do objeto.  Cada collection apresentada nas seções anteriores desse capítulo possui uma versão genérica de modo que seus métodos e propriedade são, em algum grau, análogos. Todas elas são acessíveis pelo namespace System.Collections.Generic.  Em termos de analogias, podemos fazer os seguintes paralelos.  Padrão\tGenericArrayList\tList&lt;T&gt; ou LinkedList&lt;T&gt; Queue\tQueue&lt;T&gt; Stack\tStack&lt;T&gt; Hashtable\tDictionary&lt;TKey,TValue&gt;  List&lt;T&gt;​  A documentação oficial pode ser encontrada nesse link.  A declaração é feita por:  List&lt;T&gt; variavel = new List&lt;T&gt;();  As propriedades de contagem e capacidade são iguais às da arraylist. Os métodos de busca, inserção, remoção, conversão para array e outros são iguais também.  Uma mudança que vale a pena destacar é no método TrimToSize() que na lista genérica vira o método TrimExcess().  Para aprendermos melhor a diferença entre o ArrayList e a lista genérica, vamos definir uma classe Aluno que vamos usar na construção de dois programas que farão a mesma atividade.  class Aluno { public int matricula; public string nome; public string email; // construtor vazio public Aluno() { this.nome = &quot;&quot;; this.email = &quot;&quot;; this.matricula = 0; } // construtor public Aluno(string nome, int matricula, string email) { this.nome = nome; this.email = email; this.matricula = matricula; } // procedimento public void Mostrar() { Console.WriteLine(&quot;nome: &quot; + nome + &quot;mat: &quot; + matricula + &quot; email: &quot; + email); } }   Podemos ver que essa classe possui dois construtores e um método chamado Mostrar que imprime na tela os dados do objeto.  Agora vamos comparar dois programas que realizam a mesma tarefa onde, em um usamos ArrayList e, no outro, usamos Lista genérica.  // PROGRAMA USANDO ARRAYLIST // using System; using System.Collections; class Aluno { [...] } // Procedimento de impressão dos elementos da ArrayList public static void Mostrar(ArrayList al) { foreach(object o in al) { ((Aluno)o).Mostrar(); } } // programa usando o ArrayList public static void Main (string[] args) { ArrayList al = new ArrayList(); // Inserindo 5 alunos usando números aleatórios for(int i = 0; i &lt;5; i++) { int num = Math.Abs((new Random()).Next()) % 100; al.Add(new Aluno(&quot;Aluno &quot; + num, num, &quot;aluno&quot; + num + &quot;@a.com.br&quot;)); } // Inserindo um aluno manualmente Aluno a = new Aluno(&quot;Bruno&quot;, 101, &quot;bruno@gmail.com&quot;); al.Insert(2,a); // Mostrando o primeiro elemento ((Aluno)al[0]).Mostrar(); // Removendo o aluno inserido manualmente al.Remove(a); // Teste de Contains if (al.Contains(a) == true) { Console.WriteLine(&quot;Elemento encontrado!&quot;); } else { Console.WriteLine(&quot;Elemento não encontrado!&quot;); } // Reduzindo a capacidade para o número de elementos al.TrimToSize(); // Removendo todos os elementos al.Clear(); }   // PROGRAMA USANDO LISTA GENÉRICA // using System; using System.Collections.Generic; class Aluno { [...] } // Procedimento de impressão dos elementos da ArrayList public static void Mostrar(List&lt;Aluno&gt; l) { foreach(Aluno a in l) { a.Mostrar(); } } public static void Main (string[] args) { List&lt;Aluno&gt; l = new List&lt;Aluno&gt;(); // Inserindo 5 alunos usando números aleatórios for(int i = 0; i &lt;5; i++) { int num = Math.Abs((new Random()).Next()) % 100; l.Add(new Aluno(&quot;Aluno &quot; + num, num, &quot;aluno&quot; + num + &quot;@a.com.br&quot;)); } // Inserindo um aluno manualmente Aluno a = new Aluno(&quot;Bruno&quot;, 101, &quot;bruno@gmail.com&quot;); al.Insert(2,a); // Mostrando o primeiro elemento l[0].Mostrar(); // Removendo o aluno inserido manualmente l.Remove(a); // Teste de Contains if (l.Contains(a) == true) { Console.WriteLine(&quot;Elemento encontrado!&quot;); } else { Console.WriteLine(&quot;Elemento não encontrado!&quot;); } // Reduzindo a capacidade para o número de elementos l.TrimExcess(); // Removendo todos os elementos l.Clear(); }   Comparando os dois programas, podemos ver que existem diferenças no modo como usamos elementos contidos nas duas estruturas de dados. Quando usamos um elemento de um ArrayList, o c# precisa converter o elemento de object para algum tipo primitivo. Chamamos esse processo de boxing. Esse é o motivo de termos que usar o TypeCasting.  Essa necessidade não existe na lista genérica porque ela nos obriga a declarar o tipo dos elementos no momento da criação do objeto. Por isso a recuperação dos elementos é mais simples de ser feita apenas com a passagem do index.  LinkedList&lt;T&gt;​  A documentação oficial está disponível nesse link.  A linkedlist é a aplicação em c# de uma lista flexível. Isso quer dizer que a memória é alocada somente quando existe a necessidade, uma célula por vez e não em &quot;blocos&quot; de 4 unidades como na lista genérica.  Outa diferença é que, do lado do hardware, a lista genérica salva os seus valores continuamente ao longo da memória. Por sua vez, a LinkedList salva em cada célula duas informações: o valor do item na posição e a referência para a próxima célula alocada na memória.  Ou seja, o nome linkedlist ou lista ligada é porque os nossos valores são &quot;ligados&quot; entre si por meio dessa fila de valores e referências de posições na memória5.  O final da fila sempre apontará para um endereço nulo. Essa é a indicação que ele é o último elemento da linkedlist.  Agora vamos ver alguns métodos úteis dessa classe:  AddAfter - Adiciona um valor novo como referência de um célula anterior ao novo valorAddBefore - Adiciona um valor novo como referência de um célula posterior ao novo valorAddFirst - Muda o item de posição 0AddLast - Muda item de posição n-1Remove - Libera o espaço na memória para uma nova alocação da primeira aparição do valorRemoveFirstRemoveLastClearContainsFind - Retorna a primeira ocorrênciaFindLast - Retorna a última ocorrência  Agora vamos ver um programa que utilize alguns desses métodos.  using System; using System.Collections.Generic; static void Main (string[] args) { LinkedList&lt;string&gt; meses = new LinkedList&lt;string&gt;(); meses.AddFirst(&quot;janeiro&quot;); meses.AddLast(&quot;Fevereiro&quot;); meses.AddLast(&quot;Março&quot;); meses.RemoveFirst(); LinkedListNode&lt;int&gt; i = meses.Find(&quot;Fevereiro&quot;); meses.AddBefore(i,&quot;Janeiro&quot;); foreach (string mes in meses) { Console.WriteLine(mes); } }   Queue&lt;T&gt; e Stack&lt;T&gt;  As documentações oficiais podem ser encontradas aqui e aqui.  Essas duas classes são muito parecidas com as versões padrões. A novidade aqui é que temos que definir os tipos nas coleções genéricas. De resto, são praticamente a mesma coisa.  Vamos ver um exemplo dessas classes.  using System; using System.Collections.Generic; static void Main (string[] args) { Queue&lt;int&gt; f = new Queue&lt;int&gt;(); f.Enqueue(1); f.Enqueue(2); f.Enqueue(3); // remove o primeiro f.Dequeue(); Stack&lt;int&gt; p = new Stack&lt;int&gt;(); p.Push(1); p.Push(2); p.Push(3); // remove o último p.Pop(); }   Dictionary&lt;TKey, TValue&gt;  A documentação oficial pode ser lida aqui.  Os métodos são bem parecidos com os da hashtable. Com a novidade do método TryGetValue(TKey,out TValue) onde, ao passarmos o valor da chave, caso ela exista no dicionário genérico, teremos como resposta um true junto do valor relacionado ao da chave pesquisada.  Dentre as propriedades podemos destacar as que retornam os valores do dicionário:  Item - Retorna a coleção do tipo KeyValuePair&lt;TKey,TValue&gt;Keys - Retorna uma coleção do tipo KeyCollectionValues - Retorna uma coleção do tipo ValueCollection  Agora vamos ver um programa usando alguns métodos dessa classe.  using System; using System.Collections.Generic; static void Main (string[] args) { Dictionary&lt;string, Dictionary&lt;string, int&gt;&gt; nota = new Dictionary&lt;string, Dictionary&lt;string, int&gt;&gt;(); nota.Add(&quot;AED&quot;, new Dictionary&lt;string, int&gt;() { {&quot;Maria&quot;, 60}, {&quot;Pedro&quot;, 10}, {&quot;João&quot;, 25} }); nota.Add(&quot;Calculo&quot;, new Dictionary&lt;string, int&gt;() { {&quot;Tatiano&quot;, 29}, {&quot;Ana Paula&quot;, 16}, {&quot;Kleber&quot;, 22} }); nota[&quot;AED&quot;].Add(&quot;Astrolabio&quot;,99); foreach (KeyValuePair&lt;string, Dictionary&lt;string,int&gt;&gt; disciplina in nota) { Console.WriteLine(disciplina.Key); Console.WriteLine(&quot;\tAlunos:&quot;); double media = 0; foreach (KeyValuePair&lt;string, int&gt; Aluno in disciplina.Value) { Console.WriteLine(Aluno.Key + &quot;Nota: &quot; + Aluno.Value); media += Aluno.Value; } media /= disciplina.Value.Count; Console.WriteLine(&quot;Média da Turma: &quot; + media); } }   Comentário Aqui o professor não teve pena. E eu também não vou ter. Não siga adiante se você não for capaz de entender o que esse programa faz. Analise o código até fazer sentido.  ","version":"Next","tagName":"h3"},{"title":"Tipos Abstratos de Dados​","type":1,"pageTitle":"Algoritmo e Estrutura de Dados","url":"/CC_site/docs/puc/segundo-periodo/algoritmo-estrutura-dados#tipos-abstratos-de-dados","content":" A partir de agora, vamos estudar o funcionamento básico de algumas estruturas muito comuns na resolução de problemas computáveis: listas, árvores binárias e tabelas hash.  Na seção anterior, nós aprendemos como usar algumas implementações desses conceitos em c#. Agora, vamos estudar um pouco da teoria por trás dessas classes.  Comentário A partir de agora, vamos ver muito código. Sério. Se prepare, pegue uma boa dose de café e vamos embarcar nessa tonelada de código c#.  ","version":"Next","tagName":"h2"},{"title":"Listas​","type":1,"pageTitle":"Algoritmo e Estrutura de Dados","url":"/CC_site/docs/puc/segundo-periodo/algoritmo-estrutura-dados#listas","content":" As listas podem ser divididas em 2 tipos: lineares e não lineares. Das collections que vimos, podemos dizer que ArrayList e List&lt;T&gt; são exemplos de listas lineares e que a LinkedList&lt;T&gt; é um exemplo de lista não linear.  Lista linear​  Uma lista linear, também chamada de sequencial, possui estruturas formadas por um array e um contador. Possuem método de inserção e remoção de elementos e, por ter tamanho definido, precisa ter alguma resolução para o caso onde uma inserção é solicitada mas o tamanho da lista já foi alcançado.  A primeira forma de se pensar na solução para o problema acima é simplesmente proibir que uma inserção ocorra quando o contador indicar que a lista alcançou o tamanho delimitado. Essa abordagem é mais simples e faremos uso dela logo mais a frente.  A segunda, é simplesmente permitir que esse limite seja expandido. Essa é justamente a abordagem usada nas collections ArrayList e List&lt;T&gt;. Ao se chegar no limite inicial, o processador cria um novo array de tamanho maior copiando todos os itens anteriores.  Nesta seção vamos construir uma lista linear &quot;na unha&quot;. Assim vamos aprender melhor como esses métodos são implementados nas classes que usaremos ao longo da nossa jornada como desenvolvedores .NET.  // Criação de uma lista linear class ListaLinear { private int[] array; private int n; // construtor vazio ListaLinear() { array = new int[6]; n = 6; } // construtor com definição do tamanho ListaLinear(int tamanho) { array = new int[tamanho]; n = 0; } // relação de procedimentos e métodos void InserirInicio() {...} void InserirFinal() {...} void Inserir() {...} int RemoverInicio() {...} int RemoverFinal() {...} int Remover() {...} void Mostrar() {...} }   Agora vamos passar para a criação dos métodos indicados na parte final do nosso código.  // InserirInicio void InserirInicio(int x) { // código encerra se tivermos mais ítens do que // a lista pode comportar if (n &gt;= array.Length) Environment.Exit(0); for(int i = n; i &gt; 0; i--) { array[i] = array[i-1]; } array[0] = x; n++; } // InserirFinal void InserirFinal(int x) { if (n &gt;= array.Length) Environment.Exit(0); array[n] = x; n++; }; // Inserir em qualquer posição void Inserir(int x, int pos) { if(n &gt;= array.Length || pos &lt; 0 || os &gt; n) { Environment.Exit(0); // leva os elementos para o final do array for (int i = n; i &gt; pos; i--){ array[i] = array[i-1]; } array[pos] = x; n++; } };   Esses 3 métodos de inserção são tranquilos de entendermos. No caso do primeiro, ele move todo mundo pra direita e acrescenta o valor novo no index 0. No caso do inserir no final, ele simplesmente olha o contador e insere um elemento no index dele. Por fim, no caso do inserir genérico, ele primeiro move todos os elementos para a direita do index da posição indicada para depois inserir o elemento nela.  Comentário Bem legal vermos como um simples método de adição pode dar uma dor de cabeça para se pensar em como implementar a melhor maneira. Nas próximas vezes que usar um simples insert em uma lista, podemos pensar o que tá acontecendo por trás das bibliotecas que usamos.  Agora vamos para os métodos de remoção. São análogos aos métodos de inserção só que no caminho reverso.  // Remover primeiro elemento int RemoverInicio() { if (n == 0) Environment.Exit(0); int resp = array[0]; n--; for (int i = 0; i &lt; n; i++) { array[i] = array[i+1]; } return resp; } // Remover o último elemento int RemoverFim() { if (n == 0) Environment.Exit(0); return array[--n]; } // Remove um elemento da posição // movendo o resto para a esquerda int Remover(int pos) { if (n == 0 || pos &lt; 0 || pos &gt;= n) Environment.Exit(0); int resp = array[pos]; n--; for (int i = pos; i &lt; n; n++) { array[i] = array[i+1]; } return resp; }   Comentário Novamente, se você está com dificuldade em entender esse código. Pare agora e revise o conteúdo. Não basta pegar o código e rodar no seu computador. Você é que deve ser capaz de ler e entender o código.  Agora só precisamos de um último método de mostrar os elementos da nossa lista linear.  // Mostra todos os elementos da lista void Mostrar() { Console.Write(&quot;[&quot;); for (int i = 0; i &lt; n; i++) { Console.Write(array[i] + &quot; &quot;); } Console.Write(&quot;]&quot;); }   Comentário Aqui vai um pequeno teste. Imagine que eu crie uma lista com essa classe instanciada. Qual será o output obtido caso a gente use o método Mostrar()?  O código integral desse programa pode ser encontrado no meu github gist.  Classe Autorreferencial​  Uma classe autorreferencial possui a peculiaridade de fazer referência para objetos do seu próprio tipo. A LinkedListNode&lt;T&gt; é um exemplo dessa classe.  Abaixo temos um exemplo de código que implementa essa característica.  class Celula { public int elemento; // referencia para a próxima célula public Celula prox; // construtor vazio public Celula() { this.elemento = 0; this.prox = null; } // construtor com a passagem do parâmetro public Celula(int x) { this.elemento = x; this.prox = null; } }   A vantagem dessa abordagem é que podemos criar elementos em cadeia. No exemplo acima, cada instanciação da classe pode ser relacionada a outra de maneira recursiva.  Comentário A gente viu um pouco sobre recursão lá no microfundamento de programação modular mas no contexto de uma função.  Lista flexível​  Uma lista flexível é justamente a construção feita pelas classes autorreferenciais que acabamos de ver. Cada elemento instanciado é salvo na memória de modo a ocupar uma sequência aleatória de armazenamento no hardware da memória.  O LinkedList&lt;T&gt; é a implementação em c# desse conceito.  Existem duas maneiras de se criar uma lista flexível. A primeira, contém um primeiro elemento cujo valor elemento é null (chamamos esse elemento de &quot;cabeça&quot;). A segunda maneira, é colocarmos o valor do primeiro elemento diretamente no primeiro nó da cadeia de elementos.  A vantagem da primeira abordagem (com cabeça) é que tratamos o método de inserir em uma lista vazia exatamente do mesmo modo de inserir em uma lista de elementos. A razão disso é que só precisaremos mudar o atributo prox da cabeça. No caso da abordagem sem cabeça, teríamos que primeiro verificar se existem elementos para, em caso negativo, alterarmos o atributo prox para null desse primeiro elemento.  Abaixo temos a implementação de uma lista flexível que usa a classe autorreferencial da seção anterior.  class ListaFlex { // instanciação das posições obrigatórias // de primeiro e último como objetos autorreferenciados private Celula primeiro, ultimo; // construtor vazio public ListaFlex() { ultimo = primeiro = new Celula(); } // obtendo o tamanho da lista public int Tamanho() { int tamamho = 0; for (Celula i = primeiro; i != ultimo; i = i.prox) tamanho++; return tamanho; } // lista dos métodos public void InserirFim(int x) { ultimo.prox = new Celula(x); ultimo = ultimo.prox; } public void InserirInicio(int x) { Celula tmp = new Celula(x); tmp.prox = primeiro.prox; primeiro.prox = tmp; if (primeiro == ultimo) { ultimo = tmp; } tmp = null; } public int RemoverFim() { if (primeiro == ultimo) Environment.Exit(0); // loop para se chegar no penúltimo elemento for (Celula i = primeiro; i.prox != ultimo; i = i.prox) int elemento = ultimo.elemento; ultimo = i; i = ultimo.prox = null; return elemento; } public int RemoverInicio() { // esse método mantém a cabeça da lista if (primeiro == ultimo) Environment.Exit(0); Celula tmp = primeiro.prox; // a cabeça agora vai apontar para // o segundo elemento &quot;pulando&quot; o primeiro primeiro.prox = primeiro.prox.prox; int elemento = tmp.elemento; tmp.prox = null; tmp = null; return elemento; } // atenção aqui: a posição 0 não é a da cabeça e sim // do primeiro elemento após ela, ou seja, primeiro.prox public void Inserir(int x, int pos) { int tamanho = Tamanho(); if (pos &lt; 0 || pos &gt; tamanho) { Environment.Exit(0); } else if (pos == 0) { InserirInicio(x); } else if (pos == tamanho) { InserirFim(x); } else { Celula i = primeiro; for (int j = 0; j &lt; pos; j++) i = i.prox; Celula tmp = new Celula(x); tmp.prox = i.prox; i.prox = tmp; tmp = i = null; } } public int Remover(int pos) { int tamanho = Tamanho(); if (primeiro == ultimo || pos &lt; 0) { Environment.Exit(0); } else if (pos == 0) { elemento = RemoverInicio(); } else if (pos == tamanho - 1) { elemento = RemoverFim(); } else { Celula i = primeiro; for (int j = 0; j &lt; pos; j++) i = i.prox; Celula tmp = i.prox; elemento = tmp.elemento; i.prox = tmp.prox; tmp.prox = null; i = tmp = null; } return elemento; } public void Mostrar() { Console.Write(&quot;[&quot;); for (Celula i = primeiro.prox; i != null; i = i.prox) { Console.Write(i.elemento + &quot; &quot;); } Console.Write(&quot;]&quot;); } }   O código dessa classe está disponível nesse github gist.  ","version":"Next","tagName":"h3"},{"title":"Árvore Binária e Tabela Hash​","type":1,"pageTitle":"Algoritmo e Estrutura de Dados","url":"/CC_site/docs/puc/segundo-periodo/algoritmo-estrutura-dados#árvore-binária-e-tabela-hash","content":" Árvore Binária​  Nas listas, o custo das atividades de inserção, remoção e pesquisa costuma ser de O(n)\\mathcal{O}(n)O(n) enquanto, nas árvores, o custo tende a ser de O(log(n))\\mathcal{O}(log(n))O(log(n)). O motivo disso nós veremos mais a frente.  Para entendermos melhor sobre essa estrutura de dados, é muito útil ter uma representação visual dessa estrutura.    Podemos ver que usamos dois elementos para representar essa estrutura. As bolas são chamados de nós (ou vértices) e as linhas (ou setas) são chamadas de arestas.  Comentário Se você ficou com algum feeling que a relação entre esses pontos lembrou um pouco a LinkedList&lt;T&gt;, você tá no caminho certo.  Agora nós vamos aprender alguns conceitos importantes sobre essa estrutura que são termos usados para comunicar ideias a respeito desse objeto:  Cada bola numerada é chamada de nóO nó mais alto é chamado de raizCada camada da árvore é chamada de nível6Os nós que vêm após outro nó são chamados de filhosTodo nó que tem filho é chamado de nó internoOs nós sem filhos são chamados de folhas ou nós externosPodemos subdividir uma árvore em sub-árvores onde a raiz é um nó filho da árvore originalChamamos de distância a contagem dos níveis entre 2 nósChamamos de altura da árvore a contagem dos níveis entre a raiz e a folha mais alta  Todos esses conceitos acima são relacionados a qualquer estrutura de árvore. Entretanto, uma Árvore Binária é uma árvore em que cada nó possui, no máximo, 2 filhos.  Um tipo especial de árvore binária é a Árvore Binária de Pesquisa (ABP) ou Árvore Binária de Busca (ABB). Ela é uma árvore binária com uma condição adicional: Os valores dos nós filhos à esquerda são sempre menores que o valor do nó pai e, ao contrário, os valores dos filhos à direta são sempre maiores. Compare a árvore que mostramos logo no começo com essa aqui abaixo.    Uma árvore é classificada como Árvore Balanceada se, para todos os nós, a diferença entre os níveis à esquerda e à direita seja ≤1\\leq 1≤1. Outra maneira de afirmar a mesma coisa é dizer que a altura da sub-árvore esquerda menos a altura da sub-árvore direita pertence ao conjunto {−1,0,1}\\{ -1, 0, 1 \\}{−1,0,1}  Agora que definimos a nossa estrutura de dados, temos que criar alguns métodos que serão usados para a manipulação das informações gravadas nela. Para efeitos didáticos, a partir de agora vamos considerar que todas as árvores binárias serão de pesquisa.  Podemos criar uma árvore em c# com o seguinte código:  // c sharp class No { public int elemento; public No esq, dir; // construtor do nó raiz public No(int elemento) { this.elemento = elemento; this.esq = null; this.dir = null; } // construtor do nó filho public No(int elemento, No esq, No dir) { this.elemento = elemento; this.esq = esq; this.dir = dir; } }   Mas não precisamos parar por aqui. Para ser uma estrutura de dados útil, precisamos maneiras de interagir com nossa árvore para realizar as operações de pesquisa, caminhamento, inserção e remoção.  // c sharp // função de busca de um nó a partir do valor do seu elemento public No Busca(int valor, No no) { if (no == null || no.elemento == valor) { return no; } if (valor &lt; no.elemento) { return Busca(valor, no.esq); } else { return Busca(valor, no.dir); } } // função que mostra os valores caminhando nos nós // da esquerda para a direita public void Caminhamento(No no) { if (no != null) { Caminhamento(no.esq); Console.Write(no.elemento + &quot; &quot;); Caminhamento(no.dir); } } // função de inserção de nós em uma árvore public No Insercao(int valor, No no) { // Nós raiz if (no == null) { return new No(valor); } // Essa iteração é muito inteligente porque // ela aplica a mesma lógica do caminhamento if (valor &lt; no.elemento) { no.esq = Insercao(valor, no.esq); } else { no.dir = Insercao(valor, no.dir); } return no; }   A operação mais complexa de ser implantada em uma ABP é a de remoção. A principal dificuldade vem do problema da existência de filhos. Como sabemos, um nó pode ter:  0 Filhos (nó folha)1 Filho2 Filhos  // Primeiro definimos uma função que vamos usar private No FindMin(No node) { while (node.left != null) { node = node.left; } return node; } public No Remove(int valor, No no) { // Se a árvore estiver vazia, retorne null. if (no == null) { return null; } // Se o valor a ser removido for menor que o valor do nó atual, vá para a subárvore esquerda. if (valor &lt; no.valor) { no.left = Remove(no.left, valor); } // Se o valor a ser removido for maior que o valor do nó atual, vá para a subárvore direita. else if (valor &gt; no.valor) { no.right = Remove(no.right, valor); } // Se o valor a ser removido for igual ao valor do nó atual, remova o nó. // Aqui vamos ter que levar olhar o problema dos nós filhos. else { // Se o nó não tiver filhos, basta removê-lo. if (no.left == null &amp;&amp; no.right == null) { no = null; } // Se o nó tiver apenas um filho, substitua o nó pelo seu filho. else if (no.left == null) { no = no.right; } else if (no.right == null) { no = no.left; } // Se o nó tiver dois filhos, encontre o sucessor do nó (o menor valor na subárvore direita) e substitua o nó pelo seu sucessor. else { No successor = FindMin(no.right); no.valor = successor.valor; no.right = Remove(no.right, successor.valor); } } return no; }   Na parte final, nós optamos por usar a substituição pelo sucessor. Entretanto, poderíamos fazer a escolha pelo predecessor.  Balanceamento de Árvores Binárias​  A vantagem da estrutura de árvore binária é que, como existe uma ordem de criação dos nós, podemos realizar pesquisas e, por consequência, remoções e inserções a um custo menor como vimos no começo dessa seção. Contudo, cabe destacar que essa vantagem só é verificada em casos onde a árvore está balanceada.  Para situações em que essa condição não é encontrada, podemos realizar o processo de balanceamento que verifica a árvore em busca de nós desbalanceado.  O processo de balanceamento usa uma técnica chamada rotacionamento dos nós. A ideia é que o nó desbalanceado &quot;gira&quot; em torno do seu nó filho em sentido horário ou anti-horário de modo a virar filho do seu filho. Calma, olhando a imagem fica mais fácil de entender.    Na imagem acima, podemos ver que o nó 5 está desbalanceado à esquerda porque possui uma altura 2 à esquerda e 0 à direita. Então é realizado um giro que transforma o nó 5 em filho do nó 3. Dando a essa árvore o balanceamento que desejamos.  Agora que temos uma ideia do que é o rotacionamento, podemos aprofundar um pouco mais nos seus tipos. Ao todo, existem 4 tipos de rotações que podemos usar:  Simples À esquerdaÀ direita Dupla Direita-EsquerdaEsquerda-Direita  Comentário Isso mesmo, a imagem anterior é uma rotação simples à direita.  A rotação dupla é, como o nome auto-explicativo indica, apenas a composição de rotações simples mas em sentidos contrários. Abaixo temos uma imagem explicativa para uma rotação dupla esquerda-direita.    Outro conceito importante é a da Árvore Binária Adelson-Velsky e Landis (AVL) que foi proposta lá em 1962. Esses dois soviéticos foram quem primeiro definiram as condições necessárias para a construção de uma árvore balanceada a partir da medida chamada fator de balanceamento que pode ser calculada pela equação:  fator(i)=altura_direira(i)−altura_esquerda(i)fator(i) = altura\\_{}direira(i) - altura\\_{}esquerda(i)fator(i)=altura_direira(i)−altura_esquerda(i)  Ao calcularmos o fator para todos os nós de uma árvore podemos verificar as rotações necessárias para o seu balanceamento. Abaixo temos um quadro com o resumo das regras.  Fator do nó\tFator do filho direito\tFator do filho esquerdo\tRotação2\t1 / 0 Simples esquerda 2\t-1 Dupla dir-esq -2 -1 / 0\tSimples direita -2 1\tDupla esq-dir  Tabela Hash​  Para finalizarmos nossa disciplina de Algoritmos e Estrutura de Dados, vamos ver as tabelas hash. Sim, o termo que vimos lá na primeira parte chamado hashtable é a aplicação em c# dessa estrutura.  A principal vantagem da tabela hash é que, como ela ordena o arquivo no momento da sua inserção usando a sua função de hash, o custo do acesso a essa informação é constante, ou seja O(1)\\mathcal{O}(1)O(1).  A desvantagem é que temos um custo elevado se quisermos recuperar os registros em ordem. Podendo chegar a O(n)\\mathcal{O}(n)O(n)  Quando queremos inserir elementos iguais na mesma tabela. Como a função de hash faz um mapeamento para algum subconjunto, se tentarmos inserir um elemento repetido (ou mesmo um outro elemento que gere um mesmo valor no mapeamento), teríamos uma colisão primária. Evitar esses problemas é o cerne de uma boa implementação dessa estrutura de dados.  Normalmente, temos 3 abordagens para evitar essas colisões:  Hash direto com área de reserva (overflow): Aqui, teremos uma área reservada em um array para tratar as colisões.Hash direto com rehash: Nessa abordagem temos duas funções de hash. Caso a primeira aponte para uma colisão, usaremos a segunda.Hash indireto com lista flexível simples: Assumimos que cada posição é uma lista flexível que pode apontar para outros elementos. Nesse caso, uma colisão entra como uma nova ligação na lista flexível.  As classes Hashtable e Dictionary&lt;TKey,TValue&gt; implementam a tabela hash em c#. Contudo, fica aqui um aviso. A teoria clássica assume que a as chaves são obrigatoriamente números inteiros7.  Eu pedi ao chatGPT que mostrasse um exemplo da implementação dessa estrutura em c#. Ele optou por usar a Collection de hashtable (o que tá valendo).  using System; using System.Collections; class Program { static void Main(string[] args) { // Criando uma nova tabela hash Hashtable hashtable = new Hashtable(); // Adicionando elementos à tabela hash hashtable.Add(&quot;chave1&quot;, &quot;valor1&quot;); hashtable.Add(&quot;chave2&quot;, &quot;valor2&quot;); hashtable.Add(&quot;chave3&quot;, &quot;valor3&quot;); // Acessando um elemento da tabela hash string valorChave2 = (string)hashtable[&quot;chave2&quot;]; Console.WriteLine(&quot;O valor da chave2 é: &quot; + valorChave2); // Alterando um elemento da tabela hash hashtable[&quot;chave1&quot;] = &quot;novoValor1&quot;; // Removendo um elemento da tabela hash hashtable.Remove(&quot;chave3&quot;); // Iterando sobre os elementos da tabela hash foreach (DictionaryEntry entry in hashtable) { Console.WriteLine(&quot;A chave é: &quot; + entry.Key + &quot; e o valor é: &quot; + entry.Value); } // Verificando se a tabela hash contém uma chave específica if (hashtable.ContainsKey(&quot;chave1&quot;)) { Console.WriteLine(&quot;A tabela hash contém a chave1.&quot;); } // Verificando se a tabela hash contém um valor específico if (hashtable.ContainsValue(&quot;valor2&quot;)) { Console.WriteLine(&quot;A tabela hash contém o valor2.&quot;); } } }   Mas aqui tá uma coisa interessante. Como será que essa collection lida com colisão primária? Bom, nenhum lugar é melhor que o próprio código da classe.  Podemos &quot;navegar&quot; pelo código de tudo que importamos no nosso programa simplesmente apertando ctrl e clicando no método. Por exemplo, podemos clicar no método Add do objeto hashtable para irmos exatamente no código que constrói esse método na classe Hashtable.  // Adds an entry with the given key and value to this hashtable. An // ArgumentException is thrown if the key is null or if the key is already // present in the hashtable. // public virtual void Add(object key, object? value) { Insert(key, value, true); }   Podemos ver que estamos usando a função Insert dentro desse método. Pois bem, vamos ver o que essa função faz?  // Inserts an entry into this hashtable. This method is called from the Set // and Add methods. If the add parameter is true and the given key already // exists in the hashtable, an exception is thrown. private void Insert(object key, object? nvalue, bool add) { if (key == null) { throw new ArgumentNullException(nameof(key), SR.ArgumentNull_Key); } if (_count &gt;= _loadsize) { expand(); } else if (_occupancy &gt; _loadsize &amp;&amp; _count &gt; 100) { rehash(); } // Assume we only have one thread writing concurrently. Modify // buckets to contain new data, as long as we insert in the right order. uint hashcode = InitHash(key, _buckets.Length, out uint seed, out uint incr); int ntry = 0; int emptySlotNumber = -1; // We use the empty slot number to cache the first empty slot. We chose to reuse slots // create by remove that have the collision bit set over using up new slots. int bucketNumber = (int)(seed % (uint)_buckets.Length); do { // Set emptySlot number to current bucket if it is the first available bucket that we have seen // that once contained an entry and also has had a collision. // We need to search this entire collision chain because we have to ensure that there are no // duplicate entries in the table. if (emptySlotNumber == -1 &amp;&amp; (_buckets[bucketNumber].key == _buckets) &amp;&amp; (_buckets[bucketNumber].hash_coll &lt; 0))// (((buckets[bucketNumber].hash_coll &amp; unchecked(0x80000000))!=0))) emptySlotNumber = bucketNumber; // Insert the key/value pair into this bucket if this bucket is empty and has never contained an entry // OR // This bucket once contained an entry but there has never been a collision if ((_buckets[bucketNumber].key == null) || (_buckets[bucketNumber].key == _buckets &amp;&amp; ((_buckets[bucketNumber].hash_coll &amp; unchecked(0x80000000)) == 0))) { // If we have found an available bucket that has never had a collision, but we've seen an available // bucket in the past that has the collision bit set, use the previous bucket instead if (emptySlotNumber != -1) // Reuse slot bucketNumber = emptySlotNumber; // We pretty much have to insert in this order. Don't set hash // code until the value &amp; key are set appropriately. _isWriterInProgress = true; _buckets[bucketNumber].val = nvalue; _buckets[bucketNumber].key = key; _buckets[bucketNumber].hash_coll |= (int)hashcode; _count++; UpdateVersion(); _isWriterInProgress = false; return; } // The current bucket is in use // OR // it is available, but has had the collision bit set and we have already found an available bucket if (((_buckets[bucketNumber].hash_coll &amp; 0x7FFFFFFF) == hashcode) &amp;&amp; KeyEquals(_buckets[bucketNumber].key, key)) { if (add) { throw new ArgumentException(SR.Format(SR.Argument_AddingDuplicate__, _buckets[bucketNumber].key, key)); } _isWriterInProgress = true; _buckets[bucketNumber].val = nvalue; UpdateVersion(); _isWriterInProgress = false; return; } // The current bucket is full, and we have therefore collided. We need to set the collision bit // unless we have remembered an available slot previously. if (emptySlotNumber == -1) {// We don't need to set the collision bit here since we already have an empty slot if (_buckets[bucketNumber].hash_coll &gt;= 0) { _buckets[bucketNumber].hash_coll |= unchecked((int)0x80000000); _occupancy++; } } bucketNumber = (int)(((long)bucketNumber + incr) % (uint)_buckets.Length); } while (++ntry &lt; _buckets.Length); // This code is here if and only if there were no buckets without a collision bit set in the entire table if (emptySlotNumber != -1) { // We pretty much have to insert in this order. Don't set hash // code until the value &amp; key are set appropriately. _isWriterInProgress = true; _buckets[emptySlotNumber].val = nvalue; _buckets[emptySlotNumber].key = key; _buckets[emptySlotNumber].hash_coll |= (int)hashcode; _count++; UpdateVersion(); _isWriterInProgress = false; return; } // If you see this assert, make sure load factor &amp; count are reasonable. // Then verify that our double hash function (h2, described at top of file) // meets the requirements described above. You should never see this assert. Debug.Fail(&quot;hash table insert failed! Load factor too high, or our double hashing function is incorrect.&quot;); throw new InvalidOperationException(SR.InvalidOperation_HashInsertFailed); }   Pois é. O negócio ficou sério. Isso ai é coisa de Senior. Entretanto, podemos focar em uma parte especial.  // The current bucket is full, and we have therefore collided. We need to set the collision bit // unless we have remembered an available slot previously. if (emptySlotNumber == -1) {// We don't need to set the collision bit here since we already have an empty slot if (_buckets[bucketNumber].hash_coll &gt;= 0) { _buckets[bucketNumber].hash_coll |= unchecked((int)0x80000000); _occupancy++; } }   Eu sei, ainda tá punk. Mas olha só. Nós conhecemos um condicional. E aqui em cima temos um dentro do outro.  Ignorando o primeiro, vamos prestar atenção no de dentro. Ele parece fazer um teste se o hash do nosso elemento que foi inserido possui alguma colisão .hash_coll &gt;= 0. Se isso é verdade, ele está usando o token composto |= do operador de atribuição = com o lógico ||. A gente viu algo parecido aqui e aqui.  Comentário a |= b é a mesma coisa que a = a | b. Ou seja, temos uma operação lógica entre _buckets[bucketNumber].hash_coll | unchecked((int)0x80000000). Sendo que esse treco 0x80000000 é o número hexadecimal para o número negativo mais baixo em um inteiro de 32 bits. Eu acho que ele usa esse fundo como indicativo de uso do slot no array de index.  Tudo bem se você não entender tudo que vimos até aqui. Principalmente nessa última parte. Com o tempo esse código vai ficar menos enigmático. O segredo é continuar estudando.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Algoritmo e Estrutura de Dados","url":"/CC_site/docs/puc/segundo-periodo/algoritmo-estrutura-dados#bibliografia","content":" DEITEL, Harvey M. C#: como programar. Editora Pearson.SHARP, John. Microsoft Visual C# 2008. Porto Alegre Bookman 2014.ZIVIANI, N. Projeto de Algoritmos com implementação em Java e C++.CORMEN, T. H., Algoritmos: Teoria e Prática. São Paulo GEN LTC 2012.SZWARCFITER, J. L.. Estruturas de dados e seus algoritmos LTC 2010.GOODRICH, M. T., Estruturas de dados e Algoritmos em Java. Porto Alegre: Bookman, 2013.DROZDEZ, A. Estrutura de dados e algoritmos em C++. São Paulo, Cengage Learning, 2018.    Footnotes​ Eu não vou mais explicar nos detalhes o que os códigos vão fazer porque você já deve ser capaz de analisar e entender sozinho. ↩ Ainda não vimos esse assunto mas aqui tem um link de um vídeo do youtube que explica muito bem o conceito (em inglês). ↩ Vamos usar esse tipo de sintaxe mais a frente nesse microfundamento. Preste atenção nele!. ↩ Que a gente definiu logo acima como funções que medem o tempo médio de acesso de leitura para qualquer elemento em uma lista de tamanho nnn. ↩ Pelo princípio do acesso aleatório, o fato de termos alocações ``espalhadas'' não deve ser um problema na hora de recuperar os valores da lista. ↩ A raiz está sempre no nível 0. ↩ Já essas implementações aceitam qualquer tipo como index. ↩ ","version":"Next","tagName":"h2"},{"title":"Desenvolvimento Web Frontend","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend","content":"","keywords":"","version":"Next"},{"title":"A web: Evolução, Padrões e Arquitetura​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#a-web-evolução-padrões-e-arquitetura","content":" ","version":"Next","tagName":"h2"},{"title":"Histórico e Evolução da Web​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#histórico-e-evolução-da-web","content":" A Web é um sistema da informação de hipertextos onde o acesso é feito por meio de navegadores (browsers).  Existem alguns protocolos comuns para transferência de alguns tipos de arquivos. Para mensagens (e-mail) usamos o SMTP, para transferência de arquivos usamos o FTP, aplicações de telefonia usam o VOIP e para páginas de conteúdo usamos o HTML.  A história da web eu ainda vou colocar aqui quando tiver mais tempo.  ","version":"Next","tagName":"h3"},{"title":"W3C e os Padrões da Web​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#w3c-e-os-padrões-da-web","content":" O WORLD WIDE WEB CONSORTIUM (W3C) é uma organização sem fins lucrativos cujo líder é o Tim Berners-Lee, justamente o inventor da Web. Existem várias organizações ao longo do planeta que fazem parte desse consórcio internacional. O W3C mantém a gestão de vários padrões usados todos os dias:  Design e Aplicações Web (HTML, CSS, SVG, Ajax, Acessibilidade);Arquitetura da Web (Protocolo HTTP, URI);Web Semântica (Linked Data - RDF, OWL, SPARQL);Web Services (SOAP, WSDL);Tecnologia XML (XML, XML Schema, XSLT);Navegadores e ferramentas de autoria.  A W3C possui um processo de publicação das normativas. Normalmente, o fluxo é:  Working Draft (WD)Candidate Release (CR)Proposed Recomendation (PR)Recomendation (REC)  ","version":"Next","tagName":"h3"},{"title":"Componentes da Arquitetura da Web​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#componentes-da-arquitetura-da-web","content":" A web pode ser entendida como uma coleção de componentes que permitem a comunicação entre o cliente e os servidores de aplicações. Os principais componentes dessa arquitetura são:  Ambiente Cliente (Client Web) Geralmente um Browser que envia as requisições usando o protocolo HTTP(S) para o servidor web através de uma rede de computadores. Ambiente Servidor O ambiente servidor possui vários componentes (banco de dados, aplicações, API e etc) mas o principal componente é o servidor web. Ele recebe a requisição HTTP(S) do client, interpreta a URL e envia os recursos solicitados (HTML, CSS, JS, JPEG, MP4 e etc) por meio da rede. Internet É a rede mundial baseada no protocolo TCP/IP onde todo computador conectado é denominado host (hospedeiro) e possui um identificador de endereço IP (internet protocol) que possui determinados padrões. URI (uniform resource locator) Como o nome indica, um URI é um localizado que pode ser classificado em duas maneiras. O URL é o tipo de URI que usa o endereço do conteúdo como método de localização, ele nos diz onde encontrar o recurso (por exemplo, o caminho c://home/desktop/test.txt). O URN é o tipo que usa o nome do recurso, ele nos diz a identidade do item procurado (por exemplo, o sistema ISBN). Requisição É o pacote de dados enviado pelo client através da internet para o web server onde está a instrução do que deve ser enviado como resposta. Resposta Como o nome já diz, é o retorno do web server ao client com os dados requisitados. Protocolo HTTP É o padrão como client e web server se comunicam pela rede.  ","version":"Next","tagName":"h3"},{"title":"URI, URL e URN​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#uri-url-e-urn","content":" Já vimos que o URI abarca dos conceitos de URL e URN. Agora vamos aprender um pouco mais sobre os padrões de endereços em ambos os protocolos.  URL​  O padrão URL serve para identificar o recurso pela sua localização e é composto da seguinte maneira:  ftp://example.com:8080/pasta/arquivo?name=book#nose  Cujas partes são  scheme://authority/path?query#fragment  Como podemos ver, a URL é composta por várias partes:  scheme - é a forma de interação (ftp, http, https, ...).user:pass - são as informações do user.host - endereço de ip do server.porta - qual a porta TCP/IP do server (o padrão http é 80 e pode ser omitida).path - local onde o recurso se encontra.query - detalhe da consulta na forma de pares nome-valor.fragmento - qual seção do recurso.  URN​  urn:example:animal:ferret:nose  Cujas partes são  scheme:path:authority  A URN apenas nos dá um recurso específico (NSS) contido em algum namespace (NID) sem qualquer informação sobre onde o arquivo está localizado.  ","version":"Next","tagName":"h3"},{"title":"Protocolo HTTP​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#protocolo-http","content":" O hypertext transfer protocol é mantido pela W3C e rege a camada de aplicação dos sistemas distribuídos de informação em hipertexto. Existem muitas versões mas a mais utilizada é a 2.0 de 2015.  Para entender melhor o http, consideremos o processo usual de navegação na web:  user informa a URLclient monta a requisição http e envia ao web serverserver recebe a requisição e envia a resposta ao clienta resposta é recebida e interpretada pelo browser com os dados exibidos ao userdependendo da página, pode ser que novas requisições sejam feitas para que todos os componentes sejam carregados propriamente.  Podemos ver que o http é o conjunto de regras que rege a comunicação client-server da web.  Partes da requisição HTTP​  Uma requisição é formada por 3 partes:  Linha de Requisição Método GET - Requisita dados.POST - Envia dados para o server.HEAD - Requisita dados mas o retorno deve ser um conjunto de cabeçalhos.PUT - Criação ou Atualização de dados.DELETE - Excluir algum dado.TRACE - Solicita uma cópia da requisição (serve pra testar integridade).PATCH - Alterações parciais em um recurso.OPTIONS - Lista de métodos e opções disponíveis para o server.CONNECT - Usado quando o client se conecta com o server via proxy. Recurso - É o caminho do dado requerido.Versão do Protocolo - Qual versão do http será usada. Linhas de Cabeçalho - Inclui informações complementares à requisição sendo formado por pares nome-valor.Corpo da Entidade - Dados adicionais como forms, arquivos para upload e etc.  Partes da resposta HTTP​  Linha de Resposta Versão HTTP.Código de Retorno.Mensagem explicativa do código de retorno. Linhas de Cabeçalho - Uma informação importante que consta no cabeçalho é o content-type. Ele diz o formato do conteúdo enviado como resposta1. Essa informação é apresentada conforme os MIME Types.Corpo da Entidade - É o recurso solicitado pelo client (html, css, js, jpeg, mp4, ...)  Um pouco mais sobre Cabeçalhos​  Os cabeçalhos possuem características parecidas tanto nas requests quanto nas responses. Podemos classifica-los como sendo dos tipos:  Request header - Informações sobre o client ou a requisição feita.Response header - Informações sobre a resposta ou sobre o web server.Entity header - Informações sobre o conteúdo da entidade trocada (tamanho e tipo).General header - Informações gerais usadas tanto em requests quanto em responses.  ","version":"Next","tagName":"h3"},{"title":"Servidores Web​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#servidores-web","content":" Você só consegue visualizar as informações de um site porque o servidor web foi capaz de interpretar a requisição feita pelo seu browser e responder com o conteúdo adequado. Agora vamos entender um pouco mais sobre o ambiente servidor.  O principal elemento do ambiente servidor é o web server. Ele é quem recebe, interpreta e responde as requisições dos clients ao longo da internet. Podemos também incluir outros elementos importantes no ambiente servidor como o servidor de banco de dados e os servidores de serviços (APIs).    Funções de um web service​  Um web server nada mais é que um software rodando em uma máquina. Ele desempenha várias funções que podemos elencar como:  Atender as requests http e responder a elas.Gerencias sites.Gerencias arquivos dos sites.Integrar mecanismos de scripts: php, perl, aspx, Ruby, Python e etc.Autenticar users (básica ou com servidores de autenticação).Implementar criptografia nas comunicações (https - tls/ssl).Cache de recursos.Auditoria das alterações e logs.  Software e Provedores​  Basicamente, existem 3 formas de tornar uma aplicação web acessível aos clients: Rodar um web server na máquina local; instalar e configurar um wer server em uma máquina dedicada para esse trabalho e, por fim, contratar um provedor que ofereça esse serviço.  A lista de softwares que se propõe a fazer o trabalho de um web server é enorme. O material do curso elenca dois:  Apache HTTP Server | Apache Web Server É um open source multi plataforma. Permite execução de multilinguagens como php, perl entre outras. Uma maneira simples de instalar é pelo XAMPP (que já integra o apache web server, banco de dados MariaDB e um ambiente PHP e Perl). Microsoft Internet Information Server (IIS) É a solução proprietária da Microsoft. Baseado na plataforma .NET, permite hospedar sites estáticos. O IIS já vem disponível junto dos SO Windows.  A lista de provedores também é extensa e possuem diferentes capacidades distintas mas podemos destacar algumas ferramentas úteis:  Servidores em Nuvem AzureAWS Editores e IDEs online ReplitCodeSandboxGlitchGitHub Pages2  ","version":"Next","tagName":"h3"},{"title":"Dinâmica de Aplicações Web​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#dinâmica-de-aplicações-web","content":" Quando você acessa um site, o arquivo que coordena o modo de exposição da informação e os conteúdos da mesma é um arquivo .html. Observe o exemplo abaixo de uma página simples.  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;script&gt; src='app.js'&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src='logo.jpg' alt=&quot;imagem_logo&quot;&gt; &lt;/body&gt; &lt;/html&gt;   As tags que contém as partes style.css, app.js e logo.jpg fazem menção à outros arquivos que farão parte da composição da página. Alguns são referentes à funcionalidades ou layout da aplicação enquanto outros podem ser referentes à conteúdos mostrados na página.  Uma vez que o servidor compreende a request feita pelo client, ele envia uma série de arquivos que serão lidos pelo browser do usuário e serão interpretados por ele. O html é justamente o primeiro arquivo lido porque ele diz ao navegador quais conteúdos mostrar e, a partir das referências contidas no html, como mostrar e quais funcionalidades a página terá.  O processamento de um site​  O client envia uma requisição via http (com o método GET) para o web serverO server envia o arquivo html da página requisitada para o browserAo processar o html, o browser percebe que ele faz menção de outros arquivos (como css, js, mp3, etc)O browser faz novas requisições ao server até ter todos os arquivos necessários para o carregamento da página  Como você pode ver, é muita coisa acontecendo. Só não nos damos conta disso porque o processo é muito rápido hoje em dia devida a velocidade das nossas conexões banda larga. Lembrando sempre que todas as requisições e respostas entre client e server são feitas usando-se o protocolo HTTP que a gente viu logo antes.  ","version":"Next","tagName":"h3"},{"title":"Desenvolvimento de Interfaces Web​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#desenvolvimento-de-interfaces-web","content":" ","version":"Next","tagName":"h2"},{"title":"A Linguagem HTML​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#a-linguagem-html","content":" A linguagem HTML foi criada por Tim Berners-Lee no ano de 1991 e foi baseada no padrão Standard Generalized Markup Language (SGML). Seu escopo original era para permitir a divulgação de pesquisas científicas.  Com o passar dos anos, novas tecnologias foram somadas ao ecossistema para facilitar o processo de construção das soluções web. O Cascading Style Sheet (CSS) foi criado para facilitar o desenvolvimento do conteúdo separando a parte de estilo e aparência do conteúdo em HTML. O JavaScript permitiu a manipulação de elementos além de dar mais dinâmica para as páginas web.  O W3C foi criado em 1993 e, a partir dessa data, o HTML foi mantido e padronizado por essa organização. Desde então a linguagem vem sendo alterada para permitir sua evolução.  Em 2004 foi criado o Web Hypertext Application Technology Working Group (WHATWG) por pessoas da Apple, Mozilla e Opera. Na época, o W3C estava trabalhando no padrão XHTML 2.0 (que iria substituir o HTML 4.01) mas o WHATWG conseguiu propor um monde que acabou sendo o HTML 5. O HTML 5 foi recebido e amplamente adotado no desenvolvimento de aplicações hoje em dia.  Panorama de uma Aplicação​  Nós já sabemos que um client faz uma requisição ao web server por HTTP e esse, por sua vez, responde a requisição com, normalmente, um arquivo HTML. De posse de arquivo, o browser consegue saber se precisará solicitar mais arquivos ao web server até que todas as referências do HTML sejam satisfeitas e a página carregada.  A grosso modo, podemos dizer que o HTML pode fazer menções a arquivos dos seguintes tipos:  CSSArquivos de MultimídiaJavaScriptRIA - Rich Internet Applications Applet JavaAdobe FlashAdobe AirAdobe FlexSilverLight  Se o site utiliza soluções dinâmicas como PHP, Java, Python, Ruby ou ASP.NET, quando a requisição é feita, o web server primeiro faz o processamento desses arquivos (normalmente por um outro servidor de APIs) e o resultado serão outros arquivos HTML, CSS, JS ou Multimídia. Após o processamento, o resultado é enviado para o client que será atualizado pelo browser.  Nas aplicações modernas, o seu browser está em processo praticamente contínuo de interação com o servidor e vice-versa.  A Sintaxe da Linguagem HTML​  Uma página HTML é uma coleção de elementos. Você consegue identificá-los facilmente porque estão entre os pares de símbolos &lt;&gt;. Cada elemento também tem uma tag de abertura e uma de fechamento. Por exemplo:  &lt;body&gt; Aqui vai o conteúdo do body &lt;/body&gt;   Também existem elementos que não precisam do par de tags de abertura e fechamento. Por exemplo:  &lt;input disable name='Nome' value='rommelcarneiro'&gt;   Atente para o fato que alguns elementos aceitam outros elementos internamente. Por exemplo, dentro do elemento &lt;body&gt;&lt;/body&gt; nós colocamos todos os outros elementos que comporão a nossa página web, como por exemplo, formulários, parágrafos, vídeos e etc. Então se acostume de termos elementos dentro de outros elementos.  Dentro de alguns elementos podem ser inseridas informações e configurações por meio de parâmetros que chamamos de atributos do elemento. Por exemplo, no elemento logo acima, temos os atributos name e value.  Agora que sabemos o que são elementos e como eles são construídos, podemos seguir para a organização de um documento HTML. Existe um padrão em todo arquivo HTML onde existem alguns elementos obrigatórios para o processamento da página pelo browser do client.  &lt;!DOCTYPE html&gt; -------------------------------&gt; Elemento da versão do HTML &lt;html lang=&quot;en&quot;&gt; ------------------------------&gt; Abertura do documento HTML &lt;head&gt; ------------------------------------&gt; Abertura do cabeçalho &lt;meta charset=&quot;UTF-8&quot;&gt; ----------------&gt; Atributo nome = &quot;valor&quot; &lt;title&gt;Document&lt;/title&gt; ---------------&gt; Elemento de Título &lt;/head&gt; -----------------------------------&gt; Fechamento do cabeçalho &lt;body&gt; ------------------------------------&gt; Abertura do corpo &lt;img src=&quot;logo.jpg&quot;&gt; ------------------&gt; Elemento de imagem &lt;/body&gt; -----------------------------------&gt; Abertura do corpo &lt;/html&gt; ---------------------------------------&gt; Fechamento do HTML   Preâmbulo​  Como podemos ver, primeiro temos o preâmbulo DOCTYPE, seguido do &lt;html&gt; &lt;/html&gt; onde temos outros dois elementos maiores, o cabeçalho (&lt;head&gt; &lt;/head&gt;) e o corpo (&lt;body&gt; &lt;/body&gt;).  O preâmbulo diz ao navegador qual versão da HTML será usada. Se ele não for indicado, o navegador vai tentar ``adivinhar'' qual a melhor maneira de interpretar a sua página (chamamos isso de quirks mode). Caso você informe qual a versão, o browser usará o processamento adequado (chamamos de strict mode). Os formatos do preâmbulo mudam de acordo com a versão do HTML:  HTML 5 &lt;!DOCTYPE html&gt; HTML 4.01 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML 1.0 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;  Cabeçalho​  É a primeira parte dentro da tag de html. Nele estão as informações sobre o documento de modo a organizar as referências de funcionalidade que serão usadas para o processamento da página web. Podemos resumir os elementos no cabeçalho como:  title - &lt;title&gt; &lt;/title&gt; Define o título do documento. Que também afeta a aba do navegador. link - &lt;link rel=&quot;relacao&quot; href=&quot;link_do_arquivo.extensao&quot;&gt; Define as ligações externas como arquivos, scripts, CSS e etc. style - &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; É um tipo de link. Nele é que vamos indicar qual o arquivo que regerá o layout da nossa aplicação. meta - meta name=&quot;nome&quot; content=&quot;conteudo&quot;&gt; Aqui teremos as informações adicionais sobre a página: codificação de caracteres, descrição, palavras-chaves, autor e etc.  Corpo​  A segunda parte do html é o corpo. Nele é onde colocamos o conteúdo que fará parte da página. Como é muito comum de se encontrar nos sites, esse conteúdo pode vir mesclado em várias mídias como texto, imagens, vídeos, mapas e etc. Veremos com calma um pouco mais a frente.  Elementos de Texto e Multimídia​  Como esse material tem o objetivo de ser para futuras consultas. Eu vou colocar as tags com um pequeno resumo mas não vou comentar muito sobre elas.  Parágrafos e Títulos​  Elemento\tTagsTítulos\t&lt;h1&gt;&lt;/h1&gt;,...,&lt;h6&gt;&lt;/h6&gt; Parágrafo\t&lt;p&gt;&lt;/p&gt; Quebra de Linha\t&lt;br&gt; Itálico\t&lt;i&gt;&lt;/i&gt; Negrito\t&lt;b&gt;&lt;/b&gt; Importância\t&lt;strong&gt;&lt;/strong&gt; Código-fonte\t&lt;code&gt;&lt;/code&gt; Texto pre-formatado\t&lt;pre&gt;&lt;/pre&gt; Citações\t&lt;blockquote&gt;&lt;/blockquote&gt;  Enquanto estamos montando a nossa página html, devemos evitar usar os elementos dela para a formatação de layout da nossa solução. É altamente recomendado deixar toda essa responsabilidade para a nossa Cascading Style Sheets (CSS) e focar apenas no conteúdo textual da página web.  Listas​  Existem 3 tipos de listas em HTML.  Listas ordenadas:  &lt;ol&gt; &lt;li&gt; Primeiro item &lt;/li&gt; --------&gt; 1. Primeiro item &lt;li&gt; Segundo item &lt;/li&gt; ---------&gt; 2. Segundo item &lt;li&gt; Terceiro item &lt;/li&gt; --------&gt; 3. Terceiro item &lt;/ol&gt;   Lista não ordenada:  &lt;ul&gt; &lt;li&gt; Primeiro item &lt;/li&gt; --------&gt; o Primeiro item &lt;li&gt; Segundo item &lt;/li&gt; ---------&gt; o Segundo item &lt;li&gt; Terceiro item &lt;/li&gt; --------&gt; o Terceiro item &lt;/ul&gt;   Lista de definições:  &lt;dl&gt; &lt;dt&gt; Termo 01 &lt;/li&gt; -------------&gt; Termo 01 &lt;dd&gt; Definição 01 &lt;/li&gt; ---------&gt; Definição 01 &lt;dt&gt; Termo 02 &lt;/li&gt; -------------&gt; Termo 02 &lt;dd&gt; Definição 02 &lt;/li&gt; ---------&gt; Definição 02 &lt;/dl&gt;   Imagens​  &lt;img width=&quot;200&quot; height=&quot;180&quot; src=&quot;img.png&quot; alt=&quot;Peixe&quot;&gt;   Links​  &lt;a href=&quot;link.com&quot; target=&quot;_blank&quot;&gt; Texto &lt;/a&gt; ------&gt; Nova tab &lt;a href=&quot;link.com&quot; target=&quot;_self&quot;&gt; Texto &lt;/a&gt; -------&gt; Mesma tab &lt;a href=&quot;link.com&quot; target=&quot;_parent&quot;&gt; Texto &lt;/a&gt; -----&gt; Frame pai &lt;a href=&quot;link.com&quot; target=&quot;_top&quot;&gt; Texto &lt;/a&gt; --------&gt; Janela atual &lt;a href=&quot;link.com&quot; target=&quot;nome_frame&quot;&gt; Texto &lt;/a&gt; --&gt; Frame nominado   Elementos Estruturais​  A partir da versão 4.0 o principal elemento usado para segmentar as partes de uma página html passou a ser o &lt;div&gt; que é um um elemento de divisão genérico para agrupar qualquer conjunto de elementos necessários. Por exemplo:  &lt;div&gt; &lt;h1&gt; Titulo &lt;/h1&gt; &lt;p&gt; Parágrafo pequeno &lt;/p&gt; &lt;ol&gt; &lt;li&gt;Item&lt;/li&gt; &lt;li&gt;Item&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;   Na versão 5 do HTML passamos a ter vários tipos de elementos com a mesma função dos &lt;div&gt; mas agora com nomes mais fáceis de usar. As vezes nos referimos a eles como elementos semânticos. O novos elementos semânticos apresentados na versão 5 do html são:  Elementos\tDescrição&lt;article&gt;\tDefine um artigo &lt;aside&gt;\tConteúdo ao lado da página &lt;details&gt;\tDetalhes adicionais &lt;figcaption&gt;\tTítulo para &lt;figure&gt; &lt;figure&gt;\tElemento autocontido &lt;footer&gt;\tRodapé para seção &lt;header&gt;\tCabeçalho para seção &lt;main&gt;\tConteúdo principal &lt;mark&gt;\tTexto destacado &lt;nav&gt;\tConteúdo de navegação &lt;section&gt;\tSeção do documento &lt;summary&gt;\tResumo &lt;time&gt;\tDefine data/hora  Quando construímos a estrutura do nosso site apenas com elementos &lt;div&gt; genéricos, nós não estamos indicando nenhuma relação entre essas seções. Quando usamos a divisão via elementos semânticos, permitimos um processamento por algoritmos de modo a abrir todo um leque de possibilidades de interações a partir disso. Esse é um dos motivos que justificam o nome da web 3.0 como sendo web semântica.  Abaixo temos duas maneiras de representar uma estrutura de um site. A primeira em estrutura genérica de div e a outra em elementos semânticos. Veja como a segunda abordagem é mais simples de ler.    Não é difícil perceber que o uso de elementos semânticos é fortemente indicado para o desenvolvimento de aplicações web modernas.  Elementos de Tabelas​  Não é nada incomum ter que demonstrar dados usando uma tabela. Pensando nisso, a linguagem HTML também possui um elemento especificamente criado para criação de tabelas. Uma tabela pode ser criada com o uso das seguintes tags:  &lt;table border=&quot;1&quot;&gt; --------------&gt; Cria a Tabela &lt;caption&gt; Título &lt;/caption&gt; -&gt; Coloca um Título &lt;tr&gt; ------------------------&gt; Table Row (tr) &lt;td&gt;L1C1&lt;/td&gt; -----------&gt; Table Data Column 1 &lt;td&gt;L1C2&lt;/td&gt; -----------&gt; Table Data Column 2 &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;L2C1&lt;/td&gt; -----------&gt; Table Data Column 1 &lt;td&gt;L2C2&lt;/td&gt; -----------&gt; Table Data Column 2 &lt;/tr&gt; &lt;/table&gt;   Existem vários elementos que podem ser usados dentro de uma tabela. São os principais:  Elementos\tDescrição&lt;table&gt;\tElemento que cria a tabela &lt;caption&gt;\tTítulo da tabela &lt;thead&gt;\tLinhas do cabeçalho &lt;tbody&gt;\tLinhas do body &lt;tfoot&gt;\tLinhas do rodapé &lt;tr&gt;\tLinha da tabela &lt;th&gt;\tCabeçalho dentro de uma linha &lt;td&gt;\tTable data  Comentário Não podemos cair na tentação de usar tabelas como ferramenta de layout da página. Pode até parecer mais simples no começo mas tabelas não são boas para criação de aplicações fluidas e dinâmicas.  Elementos de Formulários​  Uma das interações mais básicas que precisamos de um usuário é a inserção de dados na aplicação. Dentre as várias maneiras de conseguirmos um dado inserido pelo usuário, o formulário é a mais simples.  O HTML fornece vários atributos dentro do elemento &lt;form&gt;&lt;/form&gt; que nos permite a criar campos de texto, botões clicáveis, campos de senha e etc. A sintaxe mais básica de um formulário é dada por:  &lt;form name=&quot;form_name&quot; action=&quot;login.html&quot; method=&quot;POST&quot;&gt; Usuário: &lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot;&gt; &lt;br&gt; Senha: &lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;psw&quot; value=&quot;&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;OK&quot;&gt; &lt;/form&gt;   Podemos usar o atributo name ou id para identificar o nosso formulário3. O atributo action indica qual URL vai ser disparada uma vez processado o form (no nosso exemplo seria algo como http://server.com/login.html). O atributo method indica o método HTTP de submissão dos dados do formulário no nosso bando de dados (pode ser POST ou GET).  Quando o método usado for o GET, o browser faz uma requisição da URL indicada para o servidor passando os parâmetros de input como querystring na URL. No nosso exemplo, ficaria como http://server.com/login.html/ login.html?user=texto&amp;psw=123.  Quando o método escolhido é o POST, os dados são enviados ao servidor no corpo da requisição HTTP e não aparecem na URL. A essa altura você já deve ser capaz de entender as diferenças entre esses dois métodos.  Elemento &lt;input&gt;​  Esse elemento é bastante utilizado na composição dos formulários (na verdade, eu nem consigo pensar em um formulário sem pelo menos um input). Ele define os campos ou entradas de informação e possui os seguintes atributos:  type - Cada tipo de input possui uma visualização diferente quando a página é carregada. Isso é feito para permitir uma melhor interação do usuário de acordo com a natureza da informação requerida. As opções são: text - Campo de texto aberto. A quantidade de caracteres pode ser controlada pelo atributo maxlength.number - Só aceita número como input e permite a seleção por umas setinhas que aparecem ao lado do campo.password - Igual ao campo texto mas com os caracteres anonimizados.email - Confere se o texto inserido possui um @ antes de salvar o formulário.date - Coloca uma máscara no formato de data e cria uma opção de input por calendário.radio button - Uma opção clicável com um valor associado e um nome. O navegador só permite que um único radio button esteja selecionado se existir mais de uma opção com o mesmo nome no atributo name.checkbox - Mesma lógica do radio button mas com permissão de vários selecionados simultaneamente.submit - É um botão clicável que normalmente dispara a informação do formulário ao servidor web ou a um script JS local.reset - É igual um submit mas a única função dele é apagar tudo que foi preenchido no formulário. name - Nome de identificação do campo.value - Valor contudo no campo.placeholder - Valor que aparece quando o campo estiver vazio.required - Validação automática para evitar o não preenchimento do campo antes da submissão do form.disabled - Inativa o campo e não permite interação mas o user ainda poderá ver.  Na imagem abaixo podemos ver como cada tipo do elemento &lt;input&gt; aparece para um usuário:    Elemento &lt;textarea&gt;​  Esse é tranquilo de entender. Sempre que precisarmos de um input de texto maior do que uma linha, podemos usar o elemento &lt;textarea name=&quot;&quot; rows=&quot;10&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; para isso. É possível alterar a quantidade de linhas e a número de colunas para apresentação da nossa caixa de texto apenas mudando os parâmetros dos atributos.  Elemento &lt;select&gt;​  Podemos permitir que o usuário selecione uma lista pré-selecionada de opções através de uma lista em caixa (também chamada de dropdown menu). Um exemplo de código contendo esse elemento por ser visto abaixo.  &lt;label for=&quot;lista&quot;&gt; Dropdown Menu &lt;/label&gt; &lt;select name=&quot;lista&quot;&gt; &lt;option value=&quot;&quot;&gt;Selecione uma opção&lt;/option&gt; &lt;option value=&quot;01&quot;&gt;Opção 01&lt;/option&gt; &lt;option value=&quot;02&quot;&gt;Opção 02&lt;/option&gt; &lt;option value=&quot;03&quot;&gt;Opção 03&lt;/option&gt; &lt;option value=&quot;04&quot;&gt;Opção 04&lt;/option&gt; &lt;option value=&quot;05&quot;&gt;Opção 05&lt;/option&gt; &lt;/select&gt;   É possível transformar a lista suspensa em uma lista fixa que permite mais de uma seleção. Para fazer isso é só adicionar o atributo multiple e também o atributo size= no elemento select.  Perceba que além do elemento de lista nós trouxemos um novo elemento chamado label que adiciona um texto associado a algum elemento. No nosso exemplo, veja como foi indicado no atributo for o mesmo nome que o atributo name recebe dentro do elemento select.  O resultado pode ser visto abaixo:    ","version":"Next","tagName":"h3"},{"title":"A Linguagem CSS​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#a-linguagem-css","content":" Nós falamos na parte inicial do nosso estudo sobre HTML, mas especificamente na parte do cabeçalho, que uma das referências que normalmente fazemos é a de uma Cascading Style Sheet (CSS). A ideia por trás disso é que a manutenção e o desenvolvimento da aplicação web fica mais simples quando trabalhamos todo o aspecto de estilo visual em um arquivo separado (.css) do arquivo que trata da estrutura da aplicação (.html).  Contudo, na realidade, existem outras formas de trabalhar o visual da aplicação além do arquivo .css em separado. No geral, podemos dizer que existem 3 formas de gerenciamento de estilo de um aplicação web:  CSS externo - Melhor forma. Nosso material estará focado nesse tipo de arquitetura.Bloco interno - As regras ficam no próprio arquivo html. Pode ter aplicações para questões muito específicas. Mas as atualizações vão precisar ser feitas em cada página, sempre que necessário.Atributo inline - Pior forma. Aqui, as regras de estilo são definidas diretamente no elemento html. Qualquer mínima alteração terá de ser feita diretamente no elemento e em todas as páginas.  Aqui podemos ver um exemplo de cada aplicação do estilo visual que elencamos acima:  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;Exemplo CSS&lt;/title&gt; ###Esse é um exemplo de arquivo externo### &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; type=&quot;text/css&quot;&gt; ###Exemplo de bloco interno#### &lt;style type=&quot;text/css&quot;&gt; p { font-size: 10pt; font-family: &quot;Verdana&quot;; color: blue; } h1 { font-size: 16pt; font-family: &quot;Impact&quot;; color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; ####Exemplo de inline##### &lt;p style=&quot;margin-left: 0.5in; font-size: 8pt;&quot;&gt; Texto do parágrafo &lt;/p&gt; &lt;/body&gt; &lt;/html&gt;   A prioridade de leitura das regras de estilo que o browser vai usar é 1) inline, 2) Bloco interno, 3) CSS externo e 4) Default do navegador.  Sintaxe da linguagem CSS​  A leitura de um arquivo CSS é bem simples. A primeira coisa que precisamos saber é quais elementos estão presentes no html que será trabalhado e quais desses elementos possuem atribuição de id específico.  Por exemplo, se tivermos no nosso html dois elementos &lt;p&gt;, só que um deles possui o atributo id &lt;p id=&quot;teste&quot;&gt;. Para criarmos uma regra de estilo no nosso CSS basta escrevermos a tag do elemento (sem os símbolos &lt;&gt;) do seguinte modo.  p { color: red; }   Essa regra diz que todos os textos contidos nos elementos &lt;p&gt; terão a cor vermelha. Contudo, se quisermos adotar uma regra específica para apenas um elemento em questão, podemos definir a regra no css diretamente para o elemento com o seu id.  #teste { color: black; }   Isso nos dará uma página onde todos os textos dos parágrafos serão vermelhos à exceção do parágrafo identificado pelo id=&quot;teste&quot;.  Podemos resumir a sintaxe do CSS como sendo:  seletor { propriedade_1 : valor_da_propriedade_1; propriedade_2 : valor_da_propriedade_2; ... propriedade_n : valor_da_propriedade_n; }   Ou seja, para aprender bem CSS, vamos precisar aprender as várias maneiras de selecionar os elementos da página html e as propriedades de estilo que o CSS nos permite manipular na construção das nossas aplicações web.  Seletores de Elementos​  Eu já adianto, existem muitos tipos de seletores. Nós precisamos decorar todos os tipos? Evidente que não. O importante é saber que o estilo de uma aplicação pode ser desenvolvido de várias maneiras e que, quanto melhor for o método de organização do CSS, mais fácil será o desenvolvimento e a manutenção da aplicação no futuro. A tabela a seguir é uma referência para os vários tipos de seletores em CSS.  Tipo\tLink com HTML\tExemplo de SintaxeElemento\tNome da tag HTML\tp {color:blue;} Identificador\tid dos elementos\t#ident {color:blue;} Classe\tClasse dos elementos\t.classe {color:blue;} Atributo\tAtributos dos elementos\t[atrib] {color:blue;}, [id=&quot;p01&quot;] {color:blue;}, [class~=&quot;marked&quot;] {color:blue;} Pseudo-Classe\tSituações dos elementos\tp:first-of-type {color:blue;}, p:nth-child(3) {color:blue;}, :hover {color:blue;} Pseudo-Elemento\tPartes de elementos\tp::first-letter {color:blue;}, p::first-line {color:blue;}, p::after {color:blue;} Universal\tTodos os elementos\t* {color:blue;}  Podemos ver que existem vários modelos de seletores para os elementos html de um página. Alguns deles são dependente de contexto de interação do elemento. Especialmente, as situações de pseudo-classe são muito úteis para criação de aplicações fluidas e avançadas.  Link para lista de todos os pseudo-elementos e pseudo-classes suportados pelo CSS atualmente: link.  Combinação de Seletores​  Podemos usar combinações de seletores para definir as regras de estilo das nossas aplicações web. Essas combinações obedecem a determinadas regras que devem ser seguidas para se obter o resultado esperado. Abaixo segue uma tabela de referência.  Regra\tInterpretaçãoA,B {...}\tAplica a mesma regra em A e B A.B {...}\tclasses e ids associados à A e B ao mesmo tempo A B {...}\tElementos em B que também pertençam a A A &gt; B {...}\tElementos em B filhos de elementos de A A + B {...}\tElemento em B próximo irmão de elementos de A A ~ B {...}\tElementos em B próximos irmãos de elementos de A  Prioridade de Seletores​  O processamento das declarações CSS obedecem a ordem em 3 regras:  O processamento é de cima para baixo. A última declaração é a que prevalecerá.Regras específicas são prioridade em relação à regras gerais.As declarações marcadas como importantes p {color: red !important;} são prioritárias.  Valores e Unidades​  Atenção aqui. Entender bem quais unidades podem ser usadas e os tipos de unidades ajuda muito o desenvolvimento de interfaces bem planejadas e responsivas.  Aqui tem um link com um material de referência sobre esse assunto.  Cores em CSS​  Existem infinitas combinações de cores para a paleta que será usada em qualquer aplicação web. Existem diferentes maneiras de definir quais cores serão usadas em CSS:  RGB hexadecimal - #RRGGBBRGB abreviado - #RGBRGB decimal - rgb(rrr,ggg,bbb)Palavras-Chaves  Podemos usar qualquer uma dessas codificações para definir as cores que vamos usar no estilo das nossas aplicações web.  Display e Box Model​  Um dos aspectos mais importantes na construção de uma aplicação web é a disposição dos elementos. Agora que aprendemos como a linguagem CSS nos fornece uma maneira mais simples de controlar as informações de estilo da nossa página HTML, vamos aprender como controlamos os locais onde os elementos são dispostos.  A propriedade display é que determina como um elemento e seus filhos são dispostos na página. Alguns valores dessa propriedade se referem a maneira como o elemento é organizado em relação aos elementos irmãos e alguns valores se referem a maneira como seus elementos filhos são dispostos dentro do elemento pai.  Caso não coloquemos nenhuma informação de display nos elementos, eles possuem uma categoria default própria que pode ser do tipo inline ou block.  Os elementos inline são colocados automaticamente um ao lado do outro na mesma linha enquanto existir espaço na tela.  &lt;a&gt;&lt;span&gt;&lt;img&gt;&lt;button&gt;&lt;input&gt;etc  Os elementos block sempre ocupam uma linha inteira da página.  &lt;div&gt;&lt;h1&gt; ... &lt;h6&gt;&lt;p&gt;&lt;form&gt;&lt;canvas&gt;&lt;table&gt;etc  Mais ou menos como nessa imagem abaixo    Podemos modificar o comportamento padrão de um elemento através do parâmetro display: no CSS. Por exemplo, para transformar os &lt;input&gt; em um elemento sozinho na página, podemos colocar no CSS a seguinte linha  input { display: block; margin: 0 auto; }   No caso de elementos inside4, o atributo display pode receber os valores display=&quot;table&quot;,display=&quot;grid&quot; e display=&quot;flex&quot;. Quando colocamos esses atributos nos elementos inside, o elemento que o contém, que chamamos de elemento pai (outside), automaticamente vira um elemento do tipo display=&quot;block&quot;.  A propriedade display=&quot;table&quot; em um elemento outside permite que os elementos inside recebam variações desse atributo para a construção de layout em formato de tabela. Desse modo, se nosso elemento outside é do tipo display=&quot;table&quot;, então, os elementos inside podem ser &quot;table-row&quot;, &quot;table-cell&quot;, &quot;table-column&quot;, &quot;table-caption&quot;, &quot;table-row-group&quot;, &quot;table-header-group&quot; e &quot;table-footer-group&quot;.  A propriedade display=&quot;flex&quot; permite que os elementos inside sejam controlados de maneira fluida para se ajustar à largura da janela do navegador.  A propriedade display=&quot;grid&quot; permite um controle das regiões onde os elementos inside serão dispostos. Isso dá mais controle ao desenvolver.  Veremos com mais calma os atributos display:flex e display:grid porque eles são usados na construção de aplicações mais fluidas e dinâmicas.  Box Model​  Existe um conjunto de atributos CSS que compõe o que podemos chamar de box model. A ideia aqui é que podemos trabalhar os elementos como pertencentes a uma ``caixa'' imaginária. Isso torna o design da aplicação mais simples de compreender e também facilita o posicionamento dos elementos ao longo da nossa página.  Os atributos CSS que compõe o modelo de caixa são:  marginborderpaddingwidthheightbackground-color  As propriedades de margin, border e padding aceitam atributos de orientação como top-right-bottom-left. Caso queira aplicar o mesmo valor para todos é só informar um único valor no atributo. Se quiser discriminar, é só apontar os valores na ordem descrita no sentido horário ou usar a propriedade inteira para cada lado. A imagem abaixo deixa mais fácil a compreensão do atributos do modelo de caixa.    Durante a elaboração da interface não é nada incomum usar as bordas como método de visualização. O comando que cria a borda é  border: solid 20px black  Fundo de Elementos (Background)​  Todo elementos html possui um atributo de background que pode ser acessado pelos seguintes comandos:  background-color - Cor de fundobackground-image - Imagem ou gradiente5background-repeat - Comando caso a img não seja do tamanho do elemento. Pode ser do tipo repeat, repeat-x, repeat-y, space, roundbackground-position - Define a posição inicial da imagem. Pode ser do tipo top, left, right, center, bottom  Propriedades de Texto​  Existem várias propriedades quando o assunto é texto em CSS. Abaixo podemos ver uma tabela para referência.  Aqui tem um material bem completo fornecido pelo Mozilla  Fontes de Texto na Web​  O CSS nos dá as seguintes opções de letras: serif, sans-serif,monospace, cursive e fantasy. Contudo, nós nunca teremos certeza se o navegados do user terá a capacidade de carregar a fonte que desejamos. Para evitar esse problema, podemos definir opções de fontes do seguinte modo:  p { font-family: &quot;Trebuchet MS&quot;, Verdana, sans-serif; }   O navegador do user vai tenter renderizar a página usando a primeira opção, caso ele não consiga, ele vai para as outras opções.  Além das opções padrão CSS, podemos usar fontes proprietárias de outras fontes (Google Fonts, DaFont, Adobe e etc). A maneira de fazer isso é definir uma propriedade de importação como no exemplo abaixo  @import url('https://fonts.googleapis.com/css?family=Baloo'); div { font-family: 'Baloo', cursive; }   Layouts Responsivos​  Não é nada incomum acharmos sites que respondem dinamicamente ao tamanho da tela. Agora vamos aprender um pouco sobre esse método de desenvolvimento de aplicações web.  O Responsive Web Design (RWD) é a ferramenta que define o layout de um site de modo dinâmico ao tamanho da tela ou janela do dispositivo. Para poder usar esse método, nós precisamos planejar nosso código HTML e CSS de maneira compatível com essa metodologia.  Os principais padrões de layout responsivos são. Por enquanto eu vou deixar esse seção mais enxuta:  Mostly FluidColumn DropLayout ShifterOff CanvasTiny Tweaks  Media Queries​  As media queries são os parâmetros usados na aplicação que usam alguma característica do dispositivo onde a página está sendo exibida. Abaixo nós podemos ver um exemplo de elemento HTML com media query.  &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; media='screen and (min-width: 900px)' href=&quot;tela_g.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; media='screen and (max-width: 600px)' href=&quot;tela_p.css&quot;&gt; &lt;/head&gt;   Nesse exemplo HTML, podemos ver como, de acordo com o tamanho da tela, o arquivo de estilo CSS carregado vai ser o &quot;tela_g.css&quot; ou o &quot;tela_p.css&quot;.  Do lado do CSS, a sintaxe das media queries são usadas da seguinte maneira:  body { background-color: red; } @media screen and (min-width: 600px) { body {background-color: orange;} } @media screen and (min-width: 800px) { body {background-color: yellow;} }   Podemos ver que, de acordo com a largura da tela, o CSS envia para o navegador uma cor de fundo do body diferente. Agora estamos começando a ver a lógica por trás dos designs responsivos.  As opções de media types são:  all - Qualquer tipo de mídiahandheld - Para telas responsivas ao toqueprint - Impressorasscreen - Telas de computadores, smartphones e tabletsoutras  As opções de media features são as características dos dispositivos tais como:  color - Profundidade de cores em bitscolor-index - Número de cores indexadaswidth e height - Largura e altura do viewportdevice-width e device-height - Largura e altura do dispositivoorientation - Proporção do viewport (portrait ou landscape)resolution - Resolução de saída em dpi  Resolução e Viewport​  Quando as tela mudam de tamanho, o valor do pixel também é alterado. Para resolver esse problema, o CSS utiliza um método de cálculo que padroniza as medidas independentemente do tamanho da tela.  Se nossa aplicação for desenvolvida para uma tela com 1920 pixels (full HD), podemos converter cada pixel em uma nova unidade que permita a aplicação recalcular os tamanhos dos componentes em pixels de modo a se adequar melhor ao display. No exemplo a abaixo, nós estamos &quot;mudando&quot; o valor padrão do pixel para caber em uma tela com 1/3 de 1920 (640 pixels):  Viewport=Resoluc¸a˜oPixel-Ratio=19203=640 pixelsViewport = \\dfrac{ \\textrm{Resolução}}{ \\textrm{Pixel-Ratio}} = \\dfrac{1920}{3} = 640 \\ pixelsViewport=Pixel-RatioResoluc¸​a˜o​=31920​=640 pixels  Para habilitar esse método de ajuste, o HTML precisa ter a seguinte linha no head:  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;   A Vantagem dessa abordagem é que ela permite a manutenção da leitura quando nossa página é carregada por telas menores. Também podemos controlar a capacidade de rolagem e zoom do usuário por meio dessa meta tag.  Layout Flex​  Já aprendemos como reduzir a escala da nossa aplicação com o viewport. Mas, em telas de smartphones ou monitores pequenos, simplesmente reduzir a aplicação para caber no dispositivo pode não ser suficiente para uma boa experiência.  No Layout Flex (flexbox) nós podemos definir o comportamento dos elementos html filhos dentro de um bloco maior. Nesse modelo, nós conseguimos mudar o posicionamento relativo dos elementos filhos sempre que a tela se comportar de determinada maneira prevista (como o caso do nosso site ser aberto em uma tela de smartphone ao invés de um monitor).  Para usar esse recurso, usaremos no elemento pai6 o parâmetro display: flex; flex-wrap: wrap;. Além de definirmos o tipo de display no elemento pai, usaremos a media query para ajustar o tamanho ideal dos elementos na tela. Podemos ver melhor no exemplo de código abaixo:  &lt;!DOCTYPE html&gt; &lt;body&gt; &lt;main class='container'&gt; &lt;div id=&quot;orange&quot;&gt;&lt;/div&gt; &lt;div id=&quot;green&quot;&gt;&lt;/div&gt; &lt;div id=&quot;yellow&quot;&gt;&lt;/div&gt; &lt;/main&gt; &lt;/body&gt; &lt;/html&gt;   .container { display: flex; flex-wrap: wrap; } div { height: 80px; width: 100%; } /* tela pequena */ #orange { background-color: orange; order: 1; } #green { background-color: green; order: 2; } #yellow { background-color: yellow; order: 3; } /* tela media */ @media screen and (min-width: 600px) { #orange { width : 100% } #green { width : 70% } #yellow { width : 30% } } /* tela grande */ @media screen and (min-width: 1000px) { #orange { width : 40% } #green { width : 40% } #yellow { width : 20% } }   O resultado desses códigos acima produzem o seguinte resultado:    Layout Grid​  Para além das medias queries e layout flex, podemos construir o front end de uma aplicação usando o Sistema Grid que o CSS possui. A ideia é pensar no front end da aplicação em termos de dois elementos visuais: O Container e os Itens.  Comentário Depois eu vou revisitar essa seção com base no material disponível nesse link.  O sistema Grid possui alguns conceitos que nos ajudam a criar e manter a interface de uma aplicação que use essa metodologia:  Line - Separa as cellsCell - É uma unidade encapsulada em uma linha e uma colunaArea - Conjunto de cellsTrack - Um conjunto linear de cells (uma linha ou uma coluna do grid)  Abaixo temos o código de uma aplicação simples usando esse sistema de construção de front end:  &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;header&gt;Header &lt;/header&gt; &lt;main&gt;Main&lt;/main&gt; &lt;nav&gt;Sidebar&lt;/nav&gt; &lt;footer&gt;Footer&lt;/footer&gt; &lt;/div&gt; &lt;/body&gt;   body { background-color: rgb(255, 255, 255); } .container { height: 700px; display: grid; grid-template-columns: 20% 30% 30% 19%; grid-template-rows: auto; grid-template-areas: &quot;header header header header&quot; &quot;main main main sidebar&quot; &quot;footer footer footer footer&quot;; column-gap: 5px; row-gap: 5px; } header { grid-area: header; background-color: orange; height: 100px; } main { grid-area: main; background-color: blue; height: 500px; } nav { grid-area: sidebar; background-color: red; height: 500px; } footer { grid-area: footer; background-color: green; margin: solid black 5px; height: 100px; }     Com base nessa lógica, podemos posicionar elementos usando o sistemas de coordenadas do CSS Grid. Vamos refazer a interface que acabamos de ver usando apenas esse conceito de &quot;items&quot; dentro de um &quot;container&quot;.  Ao invés de definir a separação da tela como parâmetro da classe container no CSS, nós vamos criar o container e orientar, dentro de cada item, como ele se comportará no grid.  &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item-a&quot;&gt;Header&lt;/div&gt; &lt;div class=&quot;item-b&quot;&gt;Main&lt;/div&gt; &lt;div class=&quot;item-c&quot;&gt;Nav&lt;/div&gt; &lt;div class=&quot;item-d&quot;&gt;Footer&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;   body { background-color: rgb(255, 255, 255); } .container { height: 700px; display: grid; grid-template-columns: 24% 25% 25% 25%; grid-template-rows: 10% 80% 10%; grid-column-gap: 5px; grid-row-gap: 5px; } .item-a { background-color: orange; grid-column-start: 1; grid-column-end: span 4; grid-row-start: 1; grid-row-end: 1; } .item-b { background-color: blue; grid-column-start: 1; grid-column-end: span 3; grid-row-start: 2; grid-row-end: 2; } .item-c { background-color: red; grid-column-start: 4; grid-column-end: 4; grid-row-start: 2; grid-row-end: 2; } .item-d { background-color: green; grid-column-start: 1; grid-column-end: span 4; grid-row-start: 3; grid-row-end: 3; }   Nem vale a pena mostrar uma imagem do resultado porque ele é exatamente igual à imagem anterior.  Com isso, podemos ver que é o desenvolvimento de uma interface de aplicação web pode ser feito de diferentes maneiras, mas o que realmente importa é uma boa documentação e um planejamento bem feito para que o cliente termine com o que ele realmente precisa e o time de desenvolvimento não precise perder preciosas horas no bem conhecido ciclo de ``vai-e-volta'' até que o cliente aceite algum layout.  Exemplo de Aplicação Web Responsiva​  Para finalizar nosso estudo de desenvolvimento web com CSS vamos fazer uma aplicação simples. O protótipo no MarvelApp pode ser visto nesse link.    Acredite, com os conceitos aprendidos até agora nós já conseguimos fazer aplicações simples com páginas estáticas com relativa facilidade. A prova disso é que enquanto escrevo esse parágrafo acabamos de criar a primeira página da aplicação web front end que meu grupo precisa entregar como projeto do primeiro semestre da graduação. Eu usei, basicamente, apenas o que aprendemos aqui e alguma pesquisa no google para coisas mais simples.    Frameworks front-end - Bootstrap​  Como era de se esperar, os programadores perceberam que era possível combinar várias práticas do mercado em &quot;pacotes&quot;,&quot;bibliotecas&quot; ou &quot;frameworks&quot; que, no fundo, são códigos escritos em HTML, CSS e JavaScript. Essas ferramentas facilitam demais o processo de desenvolvimento mas, como tudo na vida, precisam ser usadas com moderação e habilidade. Não podemos correr o risco de virarmos &quot;escravos&quot; de nenhum framework.  Com o devido aviso dado, podemos iniciar nosso estudo de Frameworks famosos com o Boostrap. A culpa de várias sites que acessamos terem um &quot;jeitão&quot; parecido é, em boa parte, desse framework que até hoje é o mais famoso. Foi desenvolvido em 2011 por Mark Otto e Jacob Thornton no Twitter e disponibilizado no GitHub.  O Bootstrap se ajusta automaticamente a diferentes modelos de tela porque tem, dentro dele, tamanhos pré-determinados de telas que se ajustam ao dispositivo. A &quot;fronteira&quot; entre os tamanhos de tela são os chamados Breakpoints. A tabela abaixo resume as relações entre tamanho da tela e ajuste do container da aplicação. O site oficial pode ser acessado nesselink.  \tExtra Small\tSmall\tMedium\tLarge\tExtra Large\t&lt;57px\t≥ 576px\t≥ 768px\t≥ 992px\t≥ 1200px Max container size\t(auto)\t540px\t720px\t960px\t1140px Nome da Classe\t.col-\t.col-sm-\t.col-md-\t.col-lg-\t.col-xl-  Download do Bootstrap​  Existem duas opções de download desse Framework:  CSS e JS compilados - Já vem pronto pra uso mas é um pouco limitado.Código Fonte - Permite customização e vem com as fontes do Bootstrap mas precisa de compilação.  Para saber como fazer basta uma pesquisa rápida no youtube.  Conteúdo do Boostrap​  A melhor fonte sobre qualquer tecnologia geralmente é a própria documentação oficial. Mas podemos dividir as partes do Bootstrap em:  Reboot - Para uniformização da aparência em diferentes navegadoresTipografia - Textos e fontesCode - Linhas de códigoImages - Relacionado aos recursos de imagensTables - Relacionado aos recursos de tabelasFigures - Imagens com textos associados  Componentes do Boostrap​  Nós já sabemos que o HTML possui uma lógica de estruturação da página. Contudo, quando estamos usando o Bootstrap temos que ``reaprender'' como pensar nossa estrutura da página a partir dos conceitos e modelos do framework.  Para o Bootstrap, a página é criada usando-se componentes. A lista é bem grande mas podemos destacar alguns:  Breadcrumb - Trilha com o caminho do site até uma páginaNavbar - Barra de menu e pesquisaCarousel - Conjunto rotativo de imagens em destaque no siteCards - Cartões para uso diverso. Podem ser imagens ou textoModal - Caixas de diálogo (tipo um popup só que dentro da página)  Sistema Grid no Bootstrap​  Como nós já sabemos, o sistema grid é uma maneira conveniente de controlarmos a estrutura visual da nossa aplicação. Diante disso, não é surpreendente que esse framework também use uma versão dessa lógica.  Para o Bootstrap, todas as páginas serão sempre divididas em 12 colunas. Quando um elemento está dentro de outro, o padrão de 12 colunas se mantém. A lógica de divisão é como na imagem abaixo:    O código HTML usando o Bootstrap é fortemente baseado em &lt;div&gt;. A novidade está no uso de classes específicas que dão a lógica contida nos arquivos usados pelo framework.  A hierarquia é similar ao grid system porque a aplicação existira dentro de um container. O Container terá pelo menos uma linha (row). Cada linha terá pelo menos uma coluna. Internalize essa hierarquia de Container, Linhas e Colunas.  &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot; id=&quot;cel1&quot;&gt;.col-md-6&lt;/div&gt; &lt;div class=&quot;col-md-6&quot; id=&quot;cel2&quot;&gt;.col-md-6&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-2&quot; id=&quot;cel1&quot;&gt;.col-md-2&lt;/div&gt; &lt;div class=&quot;col-md-10&quot; id=&quot;cel2&quot;&gt;.col-md-10&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-9&quot; id=&quot;cel1&quot;&gt;.col-md-9&lt;/div&gt; &lt;div class=&quot;col-md-3&quot; id=&quot;cel2&quot;&gt;.col-md-3&lt;/div&gt; &lt;/div&gt;   #cel1 { color: white; background-color: red; height: 100px; border: solid black 3px; } #cel2 { color: white; background-color: blue; height: 100px; border: solid black 3px; }   Na próxima imagem podemos ver o resultado desse código. O sistema de 12 colunas md-1 torna bem simples a disposição dos conteúdos na tela.    ","version":"Next","tagName":"h3"},{"title":"A Linguagem JavaScript​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#a-linguagem-javascript","content":" Já aprendemos que a Web utiliza a linguagem HTML para estrutura do conteúdo, a linguagem CSS para formato e apresentação. Contudo, nós sabemos que hoje em dia as aplicações possuem funções bem complexas com sistemas inteiros baseados todo no navegador do client. A linguagem JavaScript é justamente o mecanismo que trás essa capacidade de interatividade e processamento para à web.  Hoje em dia, a linguagem JavaScript (também chamada de JS) é mantida pela ECMA International. Uma organização suíça criada em 1961 cujas atividades são separadas em vários campos de atuação. Um desses campos é a padronização de linguagens de programação. Atualmente, ela elabora os padrões para as linguagens ECMAScript (TC39), C# (TC49) e outras.  Sim, é isso mesmo. Nada de JavaScript. O JS foi criado em 1995 por Brendan Eich mas em 1996 foi transferido para a ECMA para padronização. O primeiro padrão JS dentro do ECMAScript foi feito em 1997.  Como consta na edição 2020 do padrão &quot;O ECMAScript é baseado em várias tecnologias cujas mais conhecidas são o JavaScript (Netscape) e JScript (Microsoft)&quot;. O ECMAScript foi adotado na maioria dos navegadores desde o final dos anos 90. Hoje em dia, praticamente todos os navegadores adotam o padrão ECMAScript e, consequentemente, o JavaScript dentro deles.  A ECMA International cria os padrões e especificações que permitam a execução de uma determinada linguagem. O JS é a implementação dessas padronizações dentro dos navegadores do mercado. Tanto é assim, que diferentemente do que acontece com as outras linguagens como Python, R e etc, você não precisa instalar um interpretador ou um compilador para rodar códigos em JS. Os navegadores possuem, dentro deles, um motor próprio que executa o padrão ECMAScript.  Para citar alguns desses motores:  Navegador\tMotor Web\tMotor ECMAScriptFirefox\tGecko\tSpider Monkey Chrome\tBlink\tGoogle V8 Safari\tWebKit\tJavaScriptCore IE\tTrident\tChakra Core Edge\tEDGE\tChakra Core Opera\tBlink\t  Comentário Não confunda a linguagem de programação Java com JavaScript. São linguagens totalmente diferentes.  Aplicação da Linguagem JavaScript​  Da mesma maneira que vimos com o CSS, podemos trazer o JS para nossa aplicação web de diferentes maneiras:  Por arquivo externo - Código é mantido em um arquivo separado  &lt;script type=&quot;text/javascript&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;   Em Bloco interno - Código fica em um bloco dentro do HTML  &lt;script type=&quot;text/javascript&quot;&gt; /* Código JS */ alert(&quot;Olá mundo!&quot;); &lt;/script&gt;   Inline - Código fica dentro de um atributo do elemento HTML  &lt;p onClick=&quot;alert('Click feito!');&quot;&gt;&lt;/p&gt;   Agora que sabemos que podemos &quot;turbinar&quot; nossas páginas web com o uso de JS, podemos nos perguntar o que pode ser feito com essa ferramenta. A resposta é praticamente qualquer coisa! Podemos elencar como principais aplicações:  Manipulação de objetos e tratamento de eventos relacionados aos elementos HTML a partir do uso de uma API chamada DOM (Documento Object Model).Comunicação com servidores e utilização de APIs via AJAX usando o XMLHttpRequest ou na API FetchArmazenamento de dados no client com o uso das APIs Indexed DB e LocalStorage/SessionStorageUsar as APIs do HTML5: Canvas, Media, File, Drag and Drop, Geolocation, Web Workers, History  JavaScript além do Browser​  As pessoas gostaram tanto de JS que foram capazes de construir uma aplicação que implementa o v8 do chrome fora do browser. Isso mesmo, podemos rodar aplicações em JS direto no terminal do seu computador. Basta usar a aplicação Node.js. Hoje em dia, dá pra fazer uma aplicação inteira, backend e frontend com JS.  Com JS podemos também construir aplicações desktop usando uma biblioteca chamada Electron.  Esse aqui é apenas o começo da nossa caminhada!  Variáveis e Tipos de Dados​  A linguagem JS é de tipagem dinâmica. Então o tipo de variável é definido pela própria linguagem na hora da atribuição do valor. Temos dois tokens de atribuição em JS var ou let.  var variavel01; // Aqui eu declarei sem atribuir nada var x = 10; // x agora é um numérico de valor 10 let y = &quot;Olá mundo&quot; // y é uma string   Agora temos que entender o motivo de termos dois tokens de atribuição. Mas, para poder explicar isso, precisamos entender que existem diferentes escopos de variáveis quando um programa em JS é executado. Os escopos das variáveis em JS são:  Escopo Global - Variáveis sempre disponíveis para consulta e ediçãoEscopo Local - Variáveis existem apenas dentro de um bloco de código (um loop ou uma condicional, por exemplo)  As variáveis declaradas com var são de escopo global se forem declaradas fora de funções (Nesse caso são de escopo local). Já a atribuição feita com let é de escopo local.  Abaixo temos um exemplo bem bacana mostrando essas diferenças.  var a = 5; var b = 10; if (a === 5) { let a = 4; var b = 1; console.log(a); console.log(b); } &gt; Mostra 4 e 1 no console console.log(a); console.log(b); &gt; Mostra 5 e 1 no console   Comentário Uma boa prática em JS (e em praticamente todas as linguagens) é sempre declarar as variáveis na parte de cima de cada bloco ou no começo do código.  Também é possível usar o token const para atribuição. Esse token funciona igual ao let e é definido para constantes. Uma boa prática da comunidade é usar letra maiúsculas para definir suas constantes.  Tipos e Estruturas de Dados​  Todas as variáveis que são números, textos (strings) ou valores booleanos (true ou false) são o que chamamos de tipo Primitivo. As variáveis especiais do tipo nulo (null) ou indefinido (undefined) são possuem características de tipo primitivo mas podem ser entendidas como sendo de um tipo único especial. No ECMAScript 6 foi inserida uma nova categoria de variáveis chamadas de tipo Simbólico ou Symbol (Não vamos nos aprofundar nisso agora. Depois eu atualizo esse material com o ECMAScript 6.). O que não for de tipo primitivo, null, undefined ou symbol, será do tipo Objeto que possui uma lista de propriedades, que por sua vez, possuem um nome e valores associados.  Podemos resumir o que acabamos de ver como:    Tipo Numérico​  JS não faz diferença entre números inteiros ou fracionados. Para essa linguagem, tudo é considerado o que chamamos de ponto flutuante de 64 bits. O valor máximo possível é acessado pela propriedade do objeto Number por meio das propriedades Number.POSITIVE_INFINITY e Number.NEGATIVE_INFINITY&quot;.  Quando tentamos fazer uma operação matemática não possível (como raiz de -1) recebemos o resultado NaN que significa Not-a-Number.  Não é incomum termos que converter caracteres do tipo texto mas que representam números. Para isso, podemos usar a função nativa parseInt ou parseFloat.  Tipo Boolean​  Os operadores booleanos são operadores que apenas admitem duas entradas: true ou false. Podemos chamar essas entradas diretamente ou através de operações lógicas usando operadores lógicos ou matemáticos. Abaixo temos uma tabela que podemos usar de referência.  Operador\tExemplo\tObservaçãoMesmo valor\tx == y\ttrue se mesmo valor Mesmo valor e tipo\tx === y\ttrue se mesmo valor e tipo Diferente valor\tx !== y\ttrue se diferente valor Maior que\tx &gt; y\ttrue se x maior que y Menor que\tx &lt; y\ttrue se x menor que y Maior igual\tx &gt;= y\ttrue se maior igual Menor igual\tx &lt;= y\ttrue se menor igual Negação\t!x\ttrue se x for false And\tx &amp;&amp; y\ttrue se x e y forem true Or\t`x\t  Tipo String​  Qualquer aplicação precisa ser capaz de lidar com textos. Uma string é exatamente uma cadeia de caracteres não numéricos (mas caracteres numéricos também podem compor uma string) que pode ser declarada por meio de aspas simples &quot;abc&quot; ou compostas 'abc'.  Também é comum precisarmos juntar diferentes strings. No javascript, podemos fazer isso simplesmente usando o operador de soma:  str = 'abc' + 'def' console.log(str) &gt; abcdef   Alguns caracteres das nossas strings podem ser os mesmos usados na própria linguagem. Isso nos obriga a termos que aprender como fazer um &quot;bypass&quot; desses caracteres. Abaixo temos uma tabela para referência.  Código\tSignificado\\\\backslash\\0\tNull \\\\backslash\\'\tAspas simples \\\\backslash\\&quot;\tAspas compostas \\\\\\backslash \\backslash\\\\\tBarra invertida \\\\backslash\\n\tNova linha \\\\backslash\\r\tRetorno \\\\backslash\\v\tTabulação Vertical \\\\backslash\\t\tTabulação \\\\backslash\\b\tBackspace \\\\backslash\\f\tform feed \\\\backslash\\uXXXX\tUnicode \\\\backslash\\xXX\tLatin-1  A partir do ECMAScript6 existe outra maneira de compor strings: por meio do uso da crase isso é uma string. A vantagem desse método, chamado de TemplateString é que esse tipo de string é especial que pode receber expressões interpretáveis como no exemplo abaixo:  nome = &quot;bruno&quot; console.log(nome) &gt; bruno linha = `meu nome é ${nome}` console.log(linha) &gt; meu nome é bruno   Podemos ver que na última linha o resultado faz uso do valor da variável nome. Provavelmente, sempre que a gente entra em um site que possui aquela mensagem amigável de &quot;Seja bem vindo, Fulano&quot;, o programador usou essa função para produzir aquele texto.  Tipo Objeto​  Objetos são uma boa parte do que faz o JS ser tão poderoso. Cada objeto é simplesmente uma coleção de pares nome-valor. Os nomes são as propriedades do objeto e os valores podem ser qualquer tipo de variável que vimos logo antes (incluindo outros objetos e funções). Quando a propriedade for uma função, dizemos que essa função é um método do objeto.  var objeto1 = new Object(); // Criando o objeto &quot;objeto1&quot; objeto1.name = &quot;bruno&quot;; // modo 1 de criar uma propriedade objeto1[&quot;age&quot;] = 28; // modo 2 de criar uma propriedade console.log(objeto1) &gt; { age:28 , name:bruno } var objeto2 = { // modo de criar o objeto nome: &quot;bruno&quot;, // junto das propriedades idade: 28 } console.log(objeto2) &gt; { nome:bruno, idade: 28 }   Para acessar o valor de uma propriedade em um objeto basta escrever algo como: objeto.propriedade (Python é assim também).  Datas e Horas​  Na elaboração de uma aplicação é comum ter que lidar com varáveis do relacionadas ao tempo. Para isso o JS possui um tipo de objeto especialmente projetado para facilitar essa tratativa. O objeto Date(). Podemos usa-lo como:  var a = new Date() // Atribui a data atual ao objeto var c = new Date(string) // Atribui a data por uma string var d = new Date(Ano,Mes,Dia,Hora,Segundo,Milisegundos)   Geralmente estamos preocupados apenas com o dia, mês e ano. Para criar um objeto com esses valores basta ir colocando na mesma ordem do último elemento do exemplo acima.  Perigo Quando você for indicar o mês, saiba que para o JS, janeiro é 0 e dezembro é 11. Então quando quisermos salvar a data 01/01/2022 usaremos Date(2022,0,1).  Como todo objeto, a variável criada com o Date() possui várias propriedades e métodos. Uma boa referência é o material do MDN que pode ser visto aqui. Mas podemos elencar alguns métodos importantes como:  var z = new Date() z.getFullYear() z.getMonth() z.getDate() z.getDay() z.getHours() z.getMinutes() z.getSeconds() z.getMillisecondes() z.getTimes()   Acho que não é necessário explicar cada método desse porque o nome é bem alto explicativo.  Arrays, Vetores ou Matrizes​  Um array é uma estrutura de dados semelhante a uma lista. Em JS temos algumas maneiras de criar arrays:  /* Modo 01 */ var a = new Array() a[0] = 'valor01' a[1] = 'valor02' /* Modo 02 */ var b = new Array('valor01','valor02') /* Modo 03 */ var c = ['valor01','valor02']   Todos os 3 modos produzem o mesmo resultado e podem ser usados alternadamente.  Como qualquer objeto, existem vários métodos muito úteis dentro de um Array().  concat() // Junta dois ou mais vetores fill() // Preencher os elementos em um vetor com um valor estático find() // Retorna o valor do primeiro elemento em um vetor que atender ao filtro findIndex() // Retorna o índice do primeiro elemento em um vetor forEach() // Chama uma função para cada elemento do vetor indexOf() // Busca um elemento no vetor e retorna a sua posição isArray() // Verifica se um objeto é um vetor join() // Junta todos os elementos de um vetor em uma string lastIndexOf() // Pesquisar o vetor por um elemento, começando no final pop() // Remove o último elemento de um vetor e retorna o elemento push() // Adiciona novos elementos para o final de um vetor reverse() // Inverte a ordem dos elementos em um vetor slice() // Seleciona uma parte de um vetor e retorna o novo vetor sort() // Classifica os elementos de um vetor splice() // Adiciona/remove elementos de um vetor toString() // Converte um vetor em uma string e retorna o resultado valueOf() // Retorna o valor primitivo de um vetor   Comentário Eu achei estranho que o material não falou nada sobre vetor e matriz. Então uma hora eu volto para expandir essa parte com esses outros dois tipos de dados.  Controle de Fluxo​  Em qualquer linguagem de programação7 existem maneiras de organizar blocos de código para o compilador/interpretador saber o que priorizar na hora do processamento do código. Em JS isso é feito com o uso das chaves { }.  Declarações de Seleção​  Quando estamos fazendo um script de código, é muito comum termos que nos adaptar as situações onde determinados eventos podem ou não acontecer. Para isso, usamos algumas estruturas lógicas que permitem o processamento de blocos de texto apenas se alguma condição predeterminada seja satisfeita. Ou seja, usamos um condicionante do tipo &quot;Se-Então&quot;.  if (expressao) { bloco de codigo caso true } else { outro bloco de codigo caso false }   Existem situações onde existem múltiplas possibilidades. Pensando nisso, o JS possui um operador de switch que permite vários condicionantes de maneiras mais simples do que vários ifs sucessivos.  // c# switch (expressao) { case valor01: bloco_se_01 break case valor02: bloco_se_02 break default: bloco_se_nao_01_ou_02 break }   Veja que usamos o token break para indicar que vamos para outra condicional. Não podemos esquecer disso.  Abaixo temos um exemplo de uma aplicação simples usando esse método de gestão de fluxo. Não se preocupe em entender o código inteiro, foque apenas no que estamos estudando.  // Função que recebe um input no terminal const readLine = require('readline').createInterface({ input: process.stdin, output: process.stdout }) readLine.question('Qual seu nome? ', name =&gt; { switch (name) { case 'bruno': console.log(`OI, BRUNO!`) break case 'mario': console.log('Salve, Mario!') break default: console.log(`Olá, ${name}. Seja bem-vindo(a)!`) } readLine.close() }) &gt; Qual seu nome? bruno &gt; OI, BRUNO! &gt; Qual seu nome? mario &gt; Salve, Mario! &gt; Qual seu nome? pedro &gt; Olá, pedro. Seja bem-vindo(a)!   Declarações de Repetição​  Além de termos tokens que nos permitem executar apenas alguns blocos de código. Existem outros que nos permitem usarmos um mesmo bloco de código repetidamente. Chamamos essas estruturas lógicas de laços de repetição.  A primeira maneira de criarmos um laço de repetição em JS é por meio do token while do seguinte modo:  // Exemplo de loop com while var i = 0 while (i &lt;= 5) { console.log(`Contagem: ${i}`) i++ // soma + 1 ao valor de i } &gt; Contagem: 0 &gt; Contagem: 1 &gt; Contagem: 2 &gt; Contagem: 3 &gt; Contagem: 4 &gt; Contagem: 5   Primeiro criamos a variável i e usamos a estrutura de loop while para a seguinte regra &quot;Se i for menor igual a 5 então mostre a mensagem 'Contagem: Número i'&quot;. Quando o valor da variável i é 6, a expressão do loop retorna um false e saímos do loop.  O operador que aprendemos anteriormente faz um loop enquanto a condição expressa entre os parênteses não for false. Mas existem situações onde queremos executar o bloco de código um número definido de vezes. Para isso o JS possui o token for.  // Exemplo de loop com for let frutas = ['pera','uva','maca','banana'] for (let index = 0; index &lt; frutas.length; index++) { console.log(frutas[index]) } &gt; pera &gt; uva &gt; maca &gt; banana   Nesse exemplo acima vemos que o parênteses da expressão do for possui 3 linhas de códigos separadas por ponto e vírgula. Na primeira, criamos uma variável index. Na segunda, temos a nossa expressão que avalia se o index é menor que o tamanho do array frutas. E na terceira, temos a regra de incremento + 1 para cada iteração do loop.  Dentro do loop, nós mandamos ele lançar no terminal o valor do elemento do array correspondente ao index.  Funções​  Nós aprendemos anteriormente que funções são umas das varáveis do tipo objeto no JS. Sempre que pudermos generalizar um tratamento de dados por meio da criação de uma função, devemos optar por esse caminho porque assim tornamos a manutenção dos nossos programas melhor e evitamos ter que repetir linhas de código muito parecidas.  Mesmo sendo um objeto, o JS possui um token específico para a criação de funções. Abaixo temos dois exemplos adaptados do material do curso.  // Criacao de uma funcao de soma function soma(x,y) { var total = x + y return total } soma(2,3) &gt; 5   Para o segundo exemplo, nós queremos construir uma função que retorna a média dos valores apresentados entre os parênteses. Para isso, precisaremos de um dos tokens que vimos na seção passada. Sabemos muito bem que a média é calculada pela soma dos nnn valores dividida pela quantidade nnn. Para isso, teremos que usar o token de laço de repetição.  function media() { var soma = 0 n = arguments.length for (var i = 0; i &lt; n; i++ ) { soma = arguments[i] + soma } return soma / n } media(2,3,4,5) &gt; 3.5   Calma, eu sei que em uma primeira vista é estranho esse objeto arguments ter sido chamado do nada. Acontece que no JS (e em muitas linguagens) alguns objetos, a exemplo das funções, possuem métodos que podem ser usados mesmo no momento da sua criação. Nesse caso, é o exemplo desse objeto que nos diz a quantidade de argumentos que foram inseridos na nossa função media().  Também podemos usar as funções para criação de estruturas padronizadas de objetos que são conhecidas como classes. Abaixo vamos criar uma estrutura para objetos do tipo Pessoa.  function Pessoa (primeiro,ultimo) { this.primeiro = primeiro this.ultimo = ultimo this.nomeCompleto = function() { return this.primeiro + ' ' + this.ultimo } this.nomeCompletoInvertido = function() { return this.ultimo + ' ' + this.primeiro } } var chefe = new Pessoa ('Bruno','Ruas') console.log(chefe.nomeCompleto) console.log(chefe.nomeCompletoInvertido) &gt; Bruno Ruas &gt; Ruas Bruno   Novamente, temos um termo sendo usado sem que antes ele tenha sido criado. Nesse caso é o termo this. Ele é usado para fazer referência ao objeto criado (ou classe) como podemos ver no chamamento dos valores do console.log.  Outra novidade é que criamos uma ``cópia'' do objeto Pessoa só que com um outro nome: chefe.  Arrow Functions​  Agora vamos entrar num ponto que, para mim, foi bem difícil de entender no começo. O JS permite que a construção de funções anônimas, ou seja, funções que não precisam de nomes definidos. Mas antes de aprendermos mais sobre isso, precisamos saber que existem diferentes modos de se criar uma função em JS. Abaixo temos 3 maneiras de se criar a função soma.  // forma tradicional soma = function(a,b) { return a + b } //forma com arrow function soma = (a,b) =&gt; {return a + b} //arrow function com chaves omitidas soma = (a,b) =&gt; a + b   Agora que entendemos um pouco melhor a construção de funções em JS, podemos ir mais fundo nas arrow functions. Esse método de definição de funções foi criado para facilitar a criação de funções dentro de contextos, ou seja, se você está criando uma função em uma linha de código normal (sem estrar em um bloco de código) é melhor usar a forma tradicional. Agora, se você estiver em um contexto diferente (como em um parâmetro de um objeto ou mesmo uma função) é melhor usar a arrow function.  Assim como os outros objetos, existem propriedades e métodos das arrow functions que podemos usar. Um exemplo disso é o operador this que faz referência ao bloco em que nossa arrow functions está contida. Em uma função normal, nós aprendemos que esse operador faz referência à própria função. Abaixo temos um exemplo adaptado do material.  // usando 'this' em uma arrow function var Pessoa2 = { nome:'Bruno', amigos: ['Ana','Clarck','Bruce'], exibeAmigos() { this.amigos.forEach(f =&gt; console.log(this.nome + ' é amigo de ' + f)) } } Pessoa2.exibeAmigos() &gt; Bruno é amigo de Ana &gt; Bruno é amigo de Clarck &gt; Bruno é amigo de Bruce   Vamos ver o que esse código acima nos ensina. Primeiro nós criamos uma variável de objeto chamado Pessoa2 e atribuímos duas propriedades a ela: nome e amigos. Sendo que a propriedade `amigos' é um array com 3 elementos. Como Pessoa2 é um objeto, nós podemos criar métodos dentro dele (que nada mais são do que funções em um objeto), e é exatamente o que fizemos com a função exibeAmigos().  Quando criamos o método exibeAmigos, nós usamos o operador this em um contexto onde ele faz referência ao bloco que contém a função, nesse caso, é a variável Pessoa2. Na primeira linha da nossa função exibeAmigos nós usamos um método  Dentro de função exibeAmigos nós chamamos a propriedade amigos do nosso objeto Pessoa2 por meio do 'this'. Como já vimos, um array é um objeto em JS, portanto, ele possui várias propriedades e métodos dentro dele. O forEach que está ali é precisamente uma desses métodos desse objeto que faz um loop para cada elemento do array.  Dentro do loop criado pelo método forEach do nosso array amigos nós criamos uma arrow function que usa a variável f (que nada mais é do que o elemento do array no loop). Então nós fizemos o seguinte, para cada elemento do array que agora chamamos de f, vamos fazer um console.log que nos dá o nome da Pessoa2, a string &quot;conhece&quot; e o nome do amigo que é a variável f.  Com isso temos o resultado apresentado no final desse bloco de código. Com o tempo as coisas vão ficar menos confusas, mas já podemos ver que o JS possui bastante metodologias de processamento de informação que teremos que dominar para tirar o máximo das nossas aplicações web.  Documento Object Model (DOM)​  Como o contexto de aplicação do JS sempre foi o web, essa linguagem possui algumas integrações ao ambiente do navegador que são muito úteis para a construção de aplicações verdadeiramente inteligentes. Uma das capacidades mais relevantes é a de alterar estruturas HTML e CSS por meio de códigos escritos em JS. Isso é feito por intermédio da API Document Object Model (DOM) que é um padrão da W3C para os navegadores. Abaixo temos os principais elementos que a compõe.  Todos esses objetos estão vinculados ao objeto maior window que é a janela do navegador.  historynavigatorlocationscreendocumentlinkanchorform buttoncheck boxradiopasswordresetsubmit  Cada um desses elementos possui informações e podem ser manipulados para conseguirmos construir as aplicações da maneira como quisermos.  Comentário No material do curso nós só aprofundamos em dois desses vários elementos. Depois eu volto aqui a medida que for aprendendo mais sobre os outros.  Objeto Window​  O objeto window é o representante da da janela do browser. Ele contém toda a hierarquia que mostramos nessa lista de elementos acima. Além de conter todos esses elementos dentro dele, esse objeto (Como o próprio nome diz, tudo no DOM são, em algum grau, objetos. Mantenha isso em mente!) possui métodos e propriedades que são úteis para o gerenciamento das nossas aplicações.  Na parte de armazenamento de dados o window nos dá duas maneiras: localStorage e sessionStorage. No primeiro os dados são mantidos mesmo se o navegador seja fechado. Já o sessionStorage mantém os arquivos apenas enquanto o navegador é mantido aberto. Abaixo temos um exemplo de como usar esses repositórios.  // guardando dados no repositório de sessão sessionStorage.setItem('login','Bruno Ruas') alert('O usuário logado é: ' + sessionStorage.getItem('login')) &gt; Aparece um popup com a mensagem &quot;O Usuário logado é: Bruno Ruas&quot;   Veja que para salvar o dado, temos o uso do par 'nome'-'valor' e do método setItem. Para obter o dado, basta usar o método getItem e passar o nome do valor salvo anteriormente.  Também podemos atrelar algumas funcionalidades ao tempo. É bem comum vermos depois de x minutos a seção de um site ser encerrada, por exemplo. O objeto window possui algumas maneiras de lidarmos com o tempo:  setInterval(funcao, intervalo) - Browser executa uma função continuamente a cada x milisegundosclearInterval() - Cancela a repetição da funçãosetTimeout(funcao,intervalo) - Agenda a execução de uma função com um delay de x milissegundosclearTimeout() - Cancela o agendamento  Object Document​  Logo após o navegador processar os arquivos da página web, o objeto document passa a existir e pode ser manipulado pelo nosso código JS. No material temos uma lista das principais propriedades que esse objeto possui (A descrição eu só vou colocar se for algo não óbvio).  Propriedade\tDescriçãoaddEventListener\tUma função dispara se um evento ocorre baseURI\tRetorna a URI body\tRetorna ou modifica o body cookie\tRetorna todos os cookies characterSet\tCharset da página documentElement\tTodo o html documentoURI\tURI do document forms\tUm array com os forms do html getElementsById getElementsByClassName getElementsByName getElementsByTagName images lastModified\tData de modificação do documento links\tArray com todos os links querySelector\tPrimeiro elemento por um seletor CSS querySelectorAll\tArray com todos os de um seletor CSS removeEventListener scripts\tArray com os scripts do documento title URL\t  Não tem muito pra onde correr. Só vamos aprender bem usando, mas por agora, basta termos em mente que essas funcinalidades existem e poderão ser úteis em algum momento.  Abaixo tempos um exemplo usando uma função JS para alterar um elemento do body através do DOM.  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;PUC-MG&lt;/title&gt; &lt;!-- JavaScript--&gt; &lt;script type='text/javascript'&gt; function Executar() { document.getElementById('saida').innerHTML = Date() } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=&quot;button&quot; onclick=&quot;Executar()&quot;&gt; Aperte! &lt;/button&gt; &lt;h1&gt;Saída&lt;/h1&gt; &lt;div id=&quot;saida&quot;&gt;Condição Inicial&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;   No código acima temos o script em JS dentro do próprio arquivo HTML usando a tag &lt;script&gt;. Nesse script nós criamos a função Executar() que nada mais faz do que procurar o elemento HTML cujo id é igual a 'saída' e substitui o HTML desse elemento pela data atual vinda da função nativa Date(). Abaixo podemos ver a diferença entre a situação inicial e a final após apertar o botão.    Objeto Navigator​  Como o próprio deixa claro, o objeto navigator representa o software do navegador usado pelo user. Esse objeto nos dá algumas informações úteis sobre o navegador usado. Abaixo temos uma tabela com alguns dos métodos contidos nesse objeto.  Propriedade\tDescriçãoappCodeName\tCodigo do navegador appName\tNome do navegador appVersion\tVersão do navegador cookieEnabled\tCookies habilitados geolocation\tGeolocation language onLine\tSe o browser está online platform\tQual sistema operacional product\tEngine do navegador userAgent\tUser-agent que o browser envia ao navegador  Abaixo temos um exemplo de página web adaptado do material do curso que faz uso o objeto navegador e retorna a geolocalização do navegador.  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;PUC-MG&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // função que recebe as coord e retorna um string function showPosition(position) { lat = position.coords.latitude long = position.coords.longitude texto = `Lat: ${lat} e Long ${long}` document.getElementById('saida').innerHTML = texto } // função que muda o HTML do elemento saida function getPosition() { if (window.navigator.geolocation) { window.navigator.geolocation.getCurrentPosition(showPosition) } else { x.innerHTML = 'Não tivemos acesso a' + 'sua localização!' } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=&quot;button&quot; onclick=&quot;getPosition()&quot;&gt; Geolocation &lt;/button&gt; &lt;h1&gt;Mensagem&lt;/h1&gt; &lt;div id=&quot;saida&quot;&gt;Sua localização vai aparecer aqui!&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;   Nesse código acima temos uma página simples com um botão que, ao ser ativado, dispara a função getPosition(). Essa função dispara uma outra função chamada showPosition. O resultado pode ser visto na imagem abaixo.    Eventos​  Outra funcionalidade interessante do DOM é a capacidade de usarmos não apenas os elementos da página mas também o contexto (ou eventos) em que esses elementos se encontram. Por exemplo, é comum vermos uma imagem aumentar de tamanho quando colocamos o mouse sobre ela. Com essa funcionalidade, conseguimos explorar vários cenários de interação do usuário com a página.  No exemplo abaixo, temos o uso de dois contextos do mouse sobre um elemento de texto. Quando o mouse está sobre o elemento, nós mudamos a cor dele para vermelho. Quando o mouse não está sobre o elemento, a cor dele se torna preto.  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;PUC-MG&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p onmouseover=&quot;this.style.color='red'&quot; onmouseout=&quot;this.style.color='black'&quot;&gt; Texto &lt;/p&gt; &lt;/body&gt; &lt;/html&gt;   Podemos ver mais um exemplo do uso do token this mas dessa vez fora de um bloco de código de uma função. Nesse contexto, esse operador faz referência ao elemento HTML e altera o seu valor do parâmetro de estilo que indicamos (a cor do texto).  Mesmo sendo possível fazer uso do atributo de evento direto no HTML, como fizemos no exemplo anterior, a boa prática é manter essas features em um arquivo JS à parte (igual nós fizemos com o CSS) pois isso torna o arquivo de estrutura mais fácil de ler. Abaixo temos exatamente a mesma funcionalidade mas usando o campo de script do meta mas que poderia ser hospedado em um arquivo .js em separado.  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;PUC-MG&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;texto&quot;&gt; Texto &lt;/p&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var elem = window.document.getElementById('texto') elem.addEventListener('mouseout', function () { window.document.getElementById('texto').style.color = '' window.document.getElementById('texto').style.fontSize = '' }, false) elem.addEventListener('mouseover', function () { window.document.getElementById('texto').style.color = 'red' window.document.getElementById('texto').style.fontSize = '20px' }, false) &lt;/script&gt; &lt;/html&gt;   Veja que primeiro nós criamos uma variável elem utilizando o getElementById. Como essa variável é um objeto, podemos usar um de seus métodos chamado addEventListener que recebe 3 parâmetros: o primeiro é o gatilho de disparo, o segundo é a função que será executada e o terceiro é, para todos os efeitos, sempre falso.  No exemplo acima temos dois gatilhos de eventos cadastrados. O primeiro é o mouseout que nada mais é que o padrão. O segundo é mouseover que dispara sempre que o mouse estiver sobre o elemento selecionado.  Mesmo que a primeira vista pareça mais simples usar os atributos de contexto direto no HTML, nós precisamos pensar em situações onde a aplicação se torna demasiada grande. Nesses casos, é muito melhor, para controlar a evolução da nossa aplicação web e garantir uma boa manutenção, mantermos em arquivos separados tanto o estilo quanto a funcionalidade.  Outra coisa importante a ser notada é que o script deve estar abaixo da variável que será manipulada. Primeiro o elemento precisa existir para usarmos o nosso código. Esse é o motivo da tag script estar na parte de baixo da página e não no head como nos outros exemplos.  Na tabela a baixo temos os principais tipos de gatilhos que podem ser usados pelo DOM. Para usar algum desses no direto no HTML é necessário colocar a palavra on' na frente. Por exemplo, click' vira `onclick'.  Propriedade\tDescriçãoclick\tClick em link ou elemento change\tDefault alterado em input texto focus\tFoco em um elemento blur\tAo tirar o foco mouseover\tMouse em cima mouseout\tMouse em outro lugar select\tSelect em um form submit\tSubmit em um form resize\tMudança na janela do broser load\tAlgum elemento é carregado unload\tAo sair da página  Comentário Aqui o professor da disciplina faz o desafio de criarmos uma calculadora simples com o uso dos elementos estudados nessa seção. Um dia eu volto aqui e faço esse desafio.  A Notação de Objetos (JSON)​  O JavaScript Object Notation (JSON) é um formato de descrição de dados que se baseia em texto e pode ser lido diretamente sem muita dificuldade. Existem vários outros tipos de escrita de dados onde, geralmente, temos um trade-off entre eficiência versus simplicidade. Quanto mais próximo da linguagem de máquina, melhor é pro computador processar mas mais difícil é para os humanos entender.  Como o JSON se popularizou muito, diversas outras linguagens já possuem a capacidade de processar dados nesse formato. O que aumenta ainda mais a aceitabilidade dele como veículo de envio e codificação de informação tanto no frontend quanto no backend.  Falando em backend, com a popularização de programas como nodejs, é cada vez mais comuns a construção de comunicação entre a camada de aplicação web e servidor através de APIs cuja atividade é, simplificadamente, receber JSON e enviar JSON.  Como dito anteriormente, o JSON não é o único formato existente no mercado. Para destacar alguns outros, temos o XML, RDF, Planilhas, CSV, Documentos TXT, JPEG-2000, TIFF e vários outros formatos proprietários. Mas, sem dúvida, a competição mais árdua é entre JSON e XML.  Sintaxe do JSON​  Um arquivo JSON é muito parecido com um bloco de código JS. Começa e termina com chaves {} e cada elemento é formado por um par de nome-valor e são separados por vírgula. O JSON permite diferentes tipos de valores que podem ser dos mesmo tipos de dados que estudamos anteriormente para o JS. Abaixo temos um exemplo de um arquivo JS.  { &quot;idade&quot;: 28, &quot;nome&quot;: &quot;Bruno Ruas&quot;, &quot;materias&quot;: [ { &quot;materia&quot;: &quot;Econometria&quot;, &quot;professor&quot;: &quot;Bill Gates&quot; }, { &quot;materia&quot;: &quot;Microeconomia&quot;, &quot;professor&quot;: &quot;Steve Jobs&quot; } ], &quot;nerd&quot;:true }   Nesse exemplo, podemos ver que o valor para Idade é do tipo number. Nome é uma string. Matérias é um array, veja que ele está entre colchetes [], exatamente como aprendemos antes. Cada elemento do nosso array de matérias é um objeto, que começam e terminam com chaves, com duas propriedades: matéria e professor. Por fim, temos um booliano para a pegunta &quot;É nerd?&quot;.  Os outros tipos de dados como datas, geolocalização e outros, são passados em JSON como uma string. Temos que lembrar disso se um dia precisamos lidar com esse tipo de informação.  Comentário Quando estamos criando um JSON dentro de um código JS nós não precisamos colocar as aspas no nome dos elementos. Mas é padrão que essas aspas sejam usadas em objetos JSON. Então temos que ficar atentos a isso também.  Objeto JSON no JavaScript​  Agora que sabemos um pouco sobre esse tipo de estrutura de dados, vamos aprender como manipular esse objeto dentro de um script JS. A maneira que o JS tem que trabalhar com JSON é por meio de um objeto nativo da linguagem chamado, nem um pouco sem querer, de JSON. Esse objeto possui dois métodos úteis: Um parse() que recebe uma string e retorna um objeto na notação JSON e um stringfy() que pega um objeto análogo JSON e transforma em string.  var TextoJSON = '{ &quot;Revistas&quot;: [ { &quot;titulo&quot;:&quot;V de Vingança&quot;, &quot;autor&quot;:&quot;Frank Miller&quot; }, { &quot;titulo&quot;:&quot;Batman - The Dark Knight&quot;, &quot;autor&quot;:&quot;Frank Miller&quot; }, { &quot;titulo&quot;:&quot;One Piece Nº 29&quot;, &quot;autor&quot;:&quot;Eichiro Oda&quot; } ] }'   // Usando o método de parse do JSON var banca = JSON.parse(TextoJSON) function listaTitulos() { lista = '' for (let i = 0; i &lt; banca.Revistas.length; i++) { lista += banca.Revistas[i].titulo + ' - ' + banca.Revistas[i].autor + ' ' } console.log(lista) } listaTitulos() &gt; V de Vingança - Frank Miller &gt; Batman - The Dark Knight - Frank Miller &gt; One Piece Nº 29 - Eichiro Oda   Primeiro nós criamos uma string no formato de um JSON. Depois passamos essa string pelo objeto JSON com o método parse. Após isso, nós temos um objeto chamado banca com a mesma estrutura do nosso JSON desejado. Depois nós criamos uma função de loop que retorna uma string com o título, o autor e o carácter especial de quebra de linha.  Para converter nosso objeto novamente para string basta usarmos o seguinte comando:  JSON.stringify(banca,null,2)   O primeiro parâmetro é o objeto a ser convertido. O segundo nós podemos colocar como null (Existe uma explicação para isso mas não precisamos dela agora). Por fim, o terceiro diz o tamanho do espaço para melhorar a identação.  Saber como lidar com objetos JSON dentro de um script JS nos permite construir aplicações inteiras apenas com JS. Um framework muito famoso hoje em dia chamado MEAN (MongoDb, Express, Angular e NodeJS) utiliza o JS como principal linguagem para construção de toda a aplicação web.  Programação Ajax​  Diferente do que vimos até agora, o Asynchronous Javascript and XML ou AJAX, não é uma tecnologia propriamente dito mas sim uma técnica de programação que utiliza diferentes tecnologias. A ideia geral é construir ferramentas que possuam as seguintes características:  Paginas com padrão XHTML e CSSDinâmica através do DOMTroca de informações por JSON, XML ou outroRecuperação assíncrona de dados com o objeto XMLHTTPRequest ou APT fetchJavaScript como linguagem  Algumas aplicações muito famosas foram construída usando, em algum grau, essa abordagem. Podemos citar o Youtube, Gmail, Google Earth e mais um monte de outras aplicações do Google.  Para entendermos como o AJAX é diferente da abordagem tradicional, vamos comparar as duas maneiras. No modelo tradicional, o browser faz requisições ao web server que, por sua vez, devolve a página solicitada com as devidas alterações previamente programadas. Contudo, nessa abordagem, toda a inteligência de negócio é mantida no ambiente do servidor. O esquema abaixo nos permite relembrar como é feita a comunicação entre essas duas entidades.    O problema dessa abordagem tradicional é que os dados enviados entre servidor e browser são páginas inteiras. O método AJAX trouxe a possibilidade de quebramos esses dados em &quot;pacotes&quot; menores de informações. Nesse caso, ao invés de requisições de páginas inteiras, podemos pedir ao servidor apenas &quot;pedaços&quot; menores de informação.  A metodologia AJAX trás para o lado do cliente (client side) parte da tarefa de processar os dados. Parte do processamento fica no server side e a outra parte é feita no client. Durante a sessão, várias requisições são feitas do browser (que contém o código JS) para o server por meio do uso do XMLHTTPRequest ou API Fetch. A atualização da página acontece via DOM e não pelo recebimento de um HTML novo.  Essa comunicação acontece geralmente por meio de arquivos XML ou JSON (mas pode ser qualquer outro formato de dados).    Ao abrirmos a aplicação pela primeira vez, o servidor nos envia a maior parte dos dados que serão usados na visualização (a base de toda a aplicação). Depois disso, todas as mudanças na tela serão baseadas em DOM e arquivos de dados JSON ou XML.  Podemos elencar algumas vantagens desse modelo de construção de solução web:  Redução do tráfego na redeRedução de carga no web serverFlexibilidade no desenolvimento do lado do server (foco em APIs)  Mas como tudo na vida, o AJAX possui algumas desvantagens:  Maior complexidade de desenvolvimentoAplicação mais pesada no clientSó funciona em navegadores mais modernosPode precisar de ajustes dependendo do navegador do clientO usuário perde a opção de avançar e voltar no seu histórico  Objeto XMLHTTPRequest​  Agora que entendemos melhor o que é o AJAX e como podemos construir aplicações com ele, precisamos entender bem uma das suas principais ferramentas: o objeto XMLHTTPRequest. Inicialmente criado pelo Microsoft e adaptado pelo Mozilla, o XMLHTTPRequest é um objeto (mas também pode ser interpretado como uma API) que é fornecido pelo próprio navegador e que permite que nosso código JS troque dados com um servidor web.  O objeto XMLHTTPRequest é a base do AJAX. Mas cuidado. Apesar do nome, ele aceita a troca de informações em diferentes formatos além do XML: JSON, HTML, TXT, XML. Além disso por ele podemos nos conectar à serviços por outros métodos além do HTTP.  Para aprender como usar essa ferramenta, vamos por partes. Podemos começar o nosso script com a criação de um objeto que será do tipo XMLHTTPRequest.  // função caso a conexão funcione function success() { window.document.getElementById('texto').innerHTML = this.responseText } // função caso a conexão de erro function error(err) {console.log('Erro:',err)} // criação do objeto XmlHttpRequest var xhr = new XMLHttpRequest() // executa a função success se a requisição funcionar xhr.onload = success // executa um função erro se a conexão nao funcionar xhr.onerror = error // defindo a requisicao xhr.open('GET','https://api.github.com/users/brunoruas2') xhr.send()   Esse script acima executa uma consulta a uma url do github que retorna um JSON com informações a respeito da conta de algum usuário. Essa requisição é feita no método send(). Em caso de sucesso, o xhr dispara a função success que, por sua vez, altera usa o DOM para printar na tela o JSON coletado. Em caso de erro, ele mostra, no console (Para acessar basta apertar f12 em qualquer navegador moderno) com uma mensagem de texto que contém o erro.  Como podemos perceber (e como quase tudo em JS) existem vários métodos úteis no objeto XMLHttpRequest que devemos aprender. Abaixo temos uma tabela de referência com esses métodos.  Propriedade\tDescriçãostatus\tCodigo HTTP da resposta statusText\tTexto da resposta readyState\tStatus do pedido responseTexte\tTxt bruto da resposta responseXML\tResposta em um objeto no DOM. Mas só funciona Se o tipo for text onreadystatechange\tDispara uma função quando o readState muda onerror\tExecuta função se erro onprogress\tDispara uma função em caso de demora na resposta onload\tFunção se o send funcionar  Para cada requisição, o método readyState retorna um estágio diferente. Podemos pensar que cada requisição possui uma série de passos a serem feitos até a sua conclusão. Esses passos são lidos pelo método onreadystatechange e possuem características que podemos ver na lista abaixo.  Os estágios de uma requisição são:  Uninitialized (0) - Objeto criado mas não iniciadoLoading (1) - Objeto criado mas não usou o método send()Loaded (2) - Send() executado mas os cabeçalhos não estão disponíveisInteractive (3) - Alguns dados recebidos mas não completamenteCompleted (4) - Todos os dados foram recebidos e podem ser lidos  Abaixo temos um exemplo de uso do readyState para verificação do status da chamada.  function requisicaoAJAX() { var xmlhttp = new HMLHttpResquest() } xmlhttp.onreadystatechange = function() { if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) { divElement = document.getElementById('texto') divElement.innerHTML = xmlhttp.responseText } } xmlhttp.open(&quot;GET&quot;,&quot;www.google.com/api.php&quot;) xmlhttp.send()   Podemos ver que nós criamos uma função disparada apenas quando o status muda e, como colocamos uma condição dentro, só teremos a realm modificação caso o status da comunicação seja 200 (que é o padrão para sucesso) e o status da comunicação seja o de completo.  API Fetch​  Os navegadores atuais nos permitem uma alternativa ao XMLHttpRequest chamada API Fetch. A vantagem é que essa nova tecnologia nos permite fazer uso das promises que simplifica a escrita da programação assíncrona. Podemos ver um exemplo abaixo.  &lt;script&gt; fetch('https:api.github.com/users/brunoruas2') .then(res =&gt; res.json()) .then(data =&gt; console.log(data)) .catch(err =&gt; console.log('Erro: ', err)) &lt;/script&gt;   Comentário O material não se aprofunda no tema, então eu volto aqui para aprofundar no futuro. Aqui tem um link com um material de referência da MDN.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Desenvolvimento Web Frontend","url":"/CC_site/docs/puc/primeiro-periodo/desenvolvimento-frontend#bibliografia","content":" SIKOS, L. Web Standards. Mastering HTML5, CSS3, and XML.DACONTA, M. C.; SMITH, K. T.; OBRST, L. J. The semantic Web: a guide to the future of XML, Web services, and knowledge management. [s. l.]: Wiley, [s. d.]. ISBN 0471432571SILVA, Maurício Samy. HTML 5: a linguagem de marcação quer revolucionar a web. 2. ed. rev. e ampl. [s. l.]: Novatec, 2014. ISBN 9788575224038SANDERS, William B. Smashing HTML5: técnicas para a nova geração da web. Porto Alegre: Bookman, 2012. xiv, 354 p. ISBN 9788577809608DEITEL, Paul J., Deitel, Harvey M. Ajax, Rich. Internet Applications e Desenvolvimento Web para Programadores. Pearson 776. ISBN 9788576051619SILVA, Maurício Samy. CSS3: desenvolva aplicações web profissionais com uso dos poderosos recursos de estilização das CSS3. São Paulo: Novatec, 2011. 494 p. ISBN 9788575222898BERTAGNOLLI, S. de C.; MILETTO, E. M. Desenvolvimento de software II: introdução ao desenvolvimento web com HTML, CSS, JavaScript e PHP. [s. l.]: Bookman, 2014. ISBN 9788582601952    Footnotes​ Isso pode ser a causa de alguns bugs na sua aplicação. ↩ Esse eu to usando para hospedar esse site. ↩ Isso é muito importante porque vamos usar essa informação para fazer alguma coisa. ↩ também chamados de elementos filhos. ↩ Você pode pesquisar para saber a lista dos gradientes disponíveis. ↩ Que no exemplo abaixo será um elemento da classe &quot;container&quot;. ↩ Sempre vai existir alguma exceção, eu sei. ↩ ","version":"Next","tagName":"h2"},{"title":"Programação Modular","type":0,"sectionRef":"#","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular","content":"","keywords":"","version":"Next"},{"title":"Programação Orientada à Objetos​","type":1,"pageTitle":"Programação Modular","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular#programação-orientada-à-objetos","content":" A essa altura já estamos cientes que podemos pensar em um algoritmo como uma sucessão de passos que finda na execução de um objetivo em tempo de processamento útil para um usuário. Antigamente, acreditava-se que todos os problemas poderiam ser expressos com o uso de apenas 3 estruturas de controle: comandos sequências, comandos de seleção (condicionais) e comandos de repetição (iterativos).  Nessa era, o foco estava apenas da completude do desafio proposto. A missão era resolver o problema por meio de um software.  Mas não demorou muito para as organizações perceberem que várias tarefas estavam presentes em diferentes problemas com apenas algumas alterações. Além disso, o custo e a complexidade dos problemas evolui e coisas como eficiência e padronização começaram a ficar mais relevantes no meio empresarial que já passava a se cristalizar em grandes corporações.  Para sanar essas necessidades, as linguagens de programação evoluíram e passaram a suportar abstrações como funções e procedimentos.  Podemos entender uma função como uma abstração de expressão que representam o mapeamento1 de entradas em um conjunto de resultado. O professor usa o exemplo da função fatorial:n!=n∗(n−1)!n! = n * (n-1)!n!=n∗(n−1)!  Que pode ser escrito como uma função em c#  using System; class Calculo { public int fatorial(int n) { int res = 1; if (n == 0 || n == 1) { return res; } else if (n &gt; 0) { return n * fatorial(n - 1); } else { return -1; } } static void Main(string[] args) { int valor = 4; int resultado; Calculo calc = new Calculo(); resultado = calc.fatorial(valor); Console.WriteLine(&quot;{0}! = {1}&quot;, valor, resultado); } }   Comentário Tudo que usamos nesse programa acima foi aprendido na parte 1 desse material com apenas 1 exceção. Pode ser que para algumas pessoas seja estranho que na definição da função fatorial se faça uso da própria função que está sendo criada. Chamamos esse recurso de recursão e é usado bastante como ferramenta de solução de problemas matemáticos formais. Aqui tem um link sobre essa técnica em linguagem de programação.  Além do conceito de função, as linguagens também evoluíram para o uso de procedimentos que podem ser entendidos como a abstração de comandos. É a representação de um conjunto de passos que resolve um tarefa. Diferente das funções que possuem um retorno, um procedimento pode ou não ter um resultado visível.  using System; class MainClass { private static void Tarefa1() { Console.Clear(); Console.WriteLine(&quot;Executando tarefa 1&quot;); Console.ReadLine(); } private static void Tarefa2() { Console.Clear(); Console.WriteLine(&quot;Executando tarefa 2&quot;); Console.ReadLine(); } private static bool MenuPrincipal() { Console.Clear(); Console.WriteLine(&quot;Escolha uma opção:&quot;); Console.WriteLine(&quot;1. Tarefa 1\\n2. Tarefa 2\\n3. Sair&quot;); Console.Write(&quot;Opção: &quot;); switch (Console.ReadLine()) { case &quot;1&quot;: Tarefa1(); case &quot;2&quot;: Tarefa2(); case &quot;3&quot;: return false; default: return true; } } public static void Main (string[] args) { while (MenuPrincipal()) ; } }   Nós aprendemos na parte 1 do material que um tipo abstrato de dado é a construção de uma classe que possui dentro de si a lógica de estruturas e métodos necessários para a construção de uma solução otimizada de software.  Desse modo, podemos pensar em um Módulo2 como um tipo abstrato de dados que consegue internalizar a lógica de implementação dos seus elementos de modo a permitir que apenas alguns dos seus elementos sejam manipulados.  A vantagem de se encapsular a lógica é permitir que os arquivos de código se tornem mais legíveis porque toda a lógica das funções usadas está guardada nos arquivos de referência de cada módulo que foi carregado no começo do script, além disso, podemos desejar que certas partes do nosso código não estejam disponíveis para manipulação por parte do usuário.  Comentário Já vimos um pouco sobre escopo quando trabalhos tipos abstratos de dados.  using System; using System.Collections.Generic; public class Conta { private DateTime _criacao; private double _saldo = 0; public Conta(double saldoInicial, DateTime criacao) { _saldo = saldoInicial; _criacao = criacao; } public DateTime DataCriacao { get { return _criacao; } } public double Sacar(double quantia) { if (_saldo &lt; quantia) throw new ArgumentException(&quot;Saque maior que saldo.&quot;,&quot;quantia&quot;); _saldo -= quantia; return quantia; } public void Depositar(double quantia) { if (quantia &lt;= 0) throw new ArgumentException(&quot;Depósito deve ser positivo.&quot;,&quot;quantia&quot;); _saldo += quantia; } public double GetSaldo() { return _saldo; } } public class MainClass { public static void Main (string[] args) { Conta contaDoZe = new Conta(1200, Datetime.Now); Console.WriteLine(&quot;Saldo da Conta: {0:C2}&quot;, contaDoZe.GetSaldo()); double quantia = 212; Console.WriteLine(&quot;Sacar {0:C2} da conta.&quot;,quantia); contaDoZe.Sacar(quantia); Console.WriteLine(&quot;Saldo na conta: {0:C2}&quot;,contaDoZe.GetSaldo()); } }   Comentário Se alguns de vocês tiveram dúvidas na linha onde o objeto ContaDoZe é criado pela passagem de dois parâmetros Conta(1200,DateTime.Now) é porque vocês se esqueceram do que aprendemos sobre construtores.  Programação Orientada à Objetos  Criado em 1967 por Alan Kay, o paradigma da programação orientada à objetos propõe uma mudança no modo de entendermos como um software é construído. A novidade foi a proposição de módulos independentes que não compartilham dados mas são capazes de se comunicarem (como se fossem células). O que permite o reaproveitamento de soluções e o acoplamento de diferentes objetos para a criação de ferramentas complexas e, ainda assim, cuja manutenção era mais fácil.    Claro que existem novos riscos associados à mudança do paradigma. Por exemplo, chamamos de alto acoplamento a situação onde os módulos de um sistema são muito interdependentes e podem, com a falha crítica em algum deles, desencadear uma quebra generalizada na aplicação. Temos que focar sempre em soluções de baixo acoplamento.  Podemos ver como os conceitos vão evoluindo gradualmente. Primeiro aprendemos sobre estruturas de dados nativas. Depois aprendemos como criar nossas próprias estruras de dados. Em seguida, aprendemos sobre tipos abstratos de dados com classes e estruturas. Finalmente, agora vemos como esses conceitos foram usados para a construção de um paradigma novo de desenvolvimento denominado programação orientada à objetos.  ","version":"Next","tagName":"h2"},{"title":"Fatores de Qualidade de Software​","type":1,"pageTitle":"Programação Modular","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular#fatores-de-qualidade-de-software","content":" Várias vezes ao longo do material nós usamos termos como &quot;software de qualidade&quot; ou &quot;programas bem construídos&quot; ou alguma ideia similar. Agora, vamos definir mais claramente quais características uma solução de software precisa ter para ser digna de tal chancela.  A norma que rege esse consenso aplicado no mercado atualmente é a ISO/IEC 25010. Essa norma divide os fatores de qualidade de um produto em 8 fatores de qualidade:  FuncionalidadeDesempenhoCompatibilidadeUsabilidadeConfiabilidadeSegurançaManutenibilidadePortabilidade  Como podemos ver, são vários critérios que são usados no trabalho de avaliação de uma solução. Além dessa classificação, podemos elencar os fatores em 2 grupos: fatores externos (relacionados com a dinâmica de interação dos usuários) e fatores internos (relacionados a dinâmica dos programadores com a aplicação).  Mesmo sabendo que todos os fatores são importantes, como estamos estudando esse conteúdo sob a perspectiva da programação modular, vamos nos ater apenas aos fatores que são impactados pela decisão de um projeto modular de aplicação.  Fatores Externos​  No que tange à experiência do usuário, podemos destacar algumas características que toda solução deve apresentar para ser considerada de qualidade.  Correção: O sistema deve executar a atividade que foi previamente definida como objetivo para sua construção. Isso garante que ele funcionará como o previsto.  Robustez: O sistema deve funcionar mesmo em condições anormais. Essa características está bastante relacionada à capacidade de lidar com erros e situações não previstas anteriormente pelo desenvolvimento.  Quando um sistema é bem construído, mesmo em situações de impossibilidade de funcionamento (como a ausência de internet em um sistema web) existem diferentes modos de lidar com essa limitação imposta ao funcionamento da aplicação. Um conceito que vale a pena aprendermos é o graceful degradation.  Adaptação a Novas Situações  O desenvolvimento ágil trouxe várias mudanças de postura no planejamento e execução de um projeto de tecnologia. Como agora não é necessário saber todas as características do produto final, existe a possibilidade de novas funções e ferramentas surgirem ao longo do processo de criação inicialmente planejado.  Para se atender as demandas geradas por esse paradigma, os produtos gerados a cada etapa deve ter as seguintes propriedades:  Extensabilidade: O sistema deve se adaptar a mudanças na sua especificação.  Reusabiliadde: O sistema de ter módulos que podem ser aproveitadas em outras soluções. Permitindo uma maior produtividade e celeridade do processe de desenvolvimento.  Compatibilidade: O sistema deve ter partes que são capazes de se comunicar entre si e com outros sistemas. Nesse contexto que os padrões de desenvolvimento e protocolos são tão relevantes.  Desempenho  Uma características muitíssimo relevante, principalmente em projetos escaláveis é a eficiência. Fazer bom uso do hardware economiza custos para o cliente e é uma das qualidades mais desejadas para empresas de grande monta.  Sempre devemos ter em mente que haverá um trade-off entre a capacidade de resolução dos problemas propostos e o consumo de poder de processamento disponível no momento. Um sistema deve fazer o que é desejado da melhor maneira possível.  No escopo da programação modular, como os módulos são autocontidos, no contexto de sistema muito complexos haverá, muito provavelmente, uma preferência pela correção e robustez (que garantem o resultado esperado) em detrimento da eficiência (que garante a otimização do uso dos recursos).  Fatores Internos​  Os fatores internos de qualidade de um software são aqueles relacionados às características percebidas pelos desenvolvedores e profissionais que farão a manutenção do programa.  Os principais fatores internos de qualidade de software são:  LegibilidadeManutenibilidadeModularidade  A Legibilidade pode ser entendia em dois componentes: inteligibilidade que é a facilidade de se entender a lógica implementada naquele código e a legibilidade que é a construção de códigos de maneira a facilitar a identificação dos tokens e operadores usados.  Pensando na necessidade de se padronizar o uso de estilo das linguagens de programação é que surgem os Coding Standards que padronizam várias práticas para tornar a legibilidade das linguagens mais eficiente no seu meio de uso. Um bom programador sempre está com os padrões das linguagens que utiliza em dia.  A Manutenibilidade é a facilidade de se modificar e corrigir problemas encontrados na solução. Em uma estrutura modular é comum ter que identificar qual módulo está apresentando problemas e prosseguir com a correção da lógica que está gerando o problema.  A Modularidade é relacionada a divisão do sistema. Um módulo encapsula a lógica de uma determinada ação do sistema e torna o gerenciamento da solução mais eficiente porque divide em vários arquivos menores o que antigamente ficaria em um único arquivo texto de difícil entendimento. Esse fator é regido por dois pressupostos essenciais: princípio da unidade funcional (uma função por módulo) e coesão (cada módulo tem tudo que precisa para implementar a sua função).  ","version":"Next","tagName":"h3"},{"title":"Classes e Objetos​","type":1,"pageTitle":"Programação Modular","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular#classes-e-objetos","content":" Atributos e Métodos​  Finalmente temos todos os conceitos necessários para aprendermos como programar usando o paradigma orientado à objetos. A principal postura que devemos ter é a de procurar abstrair o mundo real em objetos que são entidades autocontidas que possuem 3 características:  EstadoComportamentoIdentidade  Chamamos de Classe a coleção de objetos que compartilham as mesmas propriedades e comportamentos.  Agora vamos relembrar o que já aprendemos lá em Algoritmos e Abstração de dados.  Podemos definir uma classe em c# para um tipo de produto qualquer do seguinte modo:  class Produto { public string descricao; public float preco; public int quantidade; public bool emEstoque() { return (quantidade &gt; 0); } }   A diferença agora é que sabemos o que é uma classe do ponto de vista dos conceitos de programação orientada à objetos.  Semântica de Referência  Um objeto é uma instância3 de uma classe que possui um nome e uma posição na memória.  Uma classe pode ter várias instâncias de objetos4.  Em c# primeiro fazemos uma referência ao objeto para, depois, criarmos ele efetivamente usando o token new. Isso ocorre na mesma linha de código.  class MainClass { public static void Main(string[] args) { Produto produto = new Produto(); produto.descricao = &quot;Cafe&quot;; produto.preco = 1.99; produto.quantidade = 100; Console.WriteLine(&quot;Em estoque: {0}&quot;, produto.emEstoque() ? &quot;sim&quot; : &quot;não&quot;) }; }   Na parte Produto produto estamos fazendo apenas a referência à classe mas o objeto ainda não foi alocado na memória. Inicialmente o objeto produto é null.  Logo após a referência usamos o token new para, ai sim, criar um endereço na memória que onde o objeto será criado.  Comentário Se você ainda está com dúvidas sobre o que esse objeto criado fará, recomendamos fortemente os fundamentos da etapa 1.  Construtores​  Começamos a ver esse assunto no período 1 do curso. Vale a pena relembrar antes de continuar essa seção.  Como vimos antes, o comando Produto produto = new Produto(); faz a referência ao objeto e logo após cria um endereço na memória para ele.  Algumas linguagens possuem uma ferramenta automática de gestão de memória chamada Coletor de lixo ou Garbage Collector que é responsável pela exclusão de itens não usados durante a execução de um programa. Para nossa alegria, o c# possui essa ferramenta. Mais sobre esse conceito pode ser encontrado nesse link.  Por causa dessa característica da linguagem, no caso do objeto produto que criamos anteriormente, recebe alguns valores padrões no momento da sua criação. Se a variável for numérica, recebe o valor 0 e para as strings é passado o valor null. Desse modo, nosso objeto foi salvo no momento da sua criação com os seguintes valores:  Descrição: null Preço: 0.0 Quantidade: 0  Para garantir a correta utilização de um objeto criado, devemos nos valer da capacidade de definir valores no mesmo momento em que estamos criando um novo objeto. Já sabemos que esse conceito recebe o nome de construtor. Também sabemos que, em c#, um construtor é criado do mesmo modo de um método, a única diferença é que ele deve receber o mesmo nome do objeto e que não possuem valores de retorno. O número de construtores que um objeto pode receber é ilimitado.  Como vimos antes, um objeto sempre terá um construtor. Se não o declararmos, então o próprio c# se encarrega de definir quais serão os valores recebidos. De outro modo, se nós definirmos explicitamente um construtor no objeto, o compilador do c# sempre respeitará os valores que definimos no construtor.  Razões Para se Utilizar Construtores Especializados  Alguns objetos possuem regras de estado válido que não comportam os dois tipos de valores do construtor default do c# (que só atribui 0 ou null);Alguns objetos usam a data corrente como carimbo de tempo (timestamp) que pode ser definida por meio do construtor que recebe a hora do sistema;Em objetos muito complexos, o volume de atributos pode ser muito elevado e, se não amarrados corretamente, pode haver algum equívoco por parte do usuário na hora de definir todos os valores corretos. Um construtor garante que, pelo menos na sua criação, o objeto terá um estado inicial válido para ser preenchido.  Construtores na Classe de Produto  Voltaremos à nossa classe de objeto chamada de Produto para definirmos os seus construtores.  class Produto { public string descricao; public float preco; public int quantidade; // construtor que recebe parametros public Produto(string descricao, float preco, int quantidade) { if (descricao.Length &gt;= 3) this.descricao = descricao; if (preco &gt; 0) this.preco = preco; if (quantidade &gt;=0) this.quantidade = quantidade; } // novo construtor default public Produto() { this.descricao = &quot;Novo Produto&quot;; this.preco = 0.01F; this.quantidade = 0; } public bool emEstoque() { return (quantidade &gt; 0); } }   Comentário O objeto this é um token que faz referência ao escopo onde se encontra. No caso em tela, ele se refere ao objeto sendo criado e não ao método onde está sendo usado. Essa parte de tokens de referência de escopo é um pouco confusa a primeira vista mas com o tempo é possível entender melhor.  Dessa maneira, nossa nova classe melhorada de objeto chamado Produto recebe dois tipos de construção. Podemos criar um objeto de produto com ou sem parâmetros.  // Caso sem passagem de parâmetros Produto produto1 = new Produto(); // Caso com passagem de parâmetros Produto produto2 = new Produto(&quot;café&quot;, 1.50F, 12);   Atributos Estáticos e Propriedades​  Membros Estáticos  Antes de definirmos o que seria um membro estático, temos que formalizar o conceito de escopo. Podemos definir escopo como a região do código onde a variável pode ser acessada. Outra maneira de pensarmos esse conceito é a região do código onde a variável é visível pelo programa.  Podemos criar métodos e atributos que serão comuns a todos os objetos que tenham referência a eles na sua construção. Até agora, todos os métodos e atributos que tivemos nos nossos objetos foram criados dentro dos próprios objetos e, portanto, são salvos em diferentes endereços de memória a medida que novos objetos são criados ao longo do programa.  Pois bem, um membro estático é exatamente esse método ou atributo que são criados em escopo global e &quot;inseridos&quot; dentro dos nossos objetos por meio da referência a esse membro na classe que criará os objetos. Eles são muito úteis para implementação de contadores ou identificadores de auto-incremento. O termo &quot;estático&quot; é uma alusão ao fato que esses construtos são alocados no momento que a classe é carregada na memória e não variam o seu endereço ao longo de todo o programa, ou seja, eles existem antes mesmo de declararmos o primeiro objeto da classe criada.  Em c# usamos o token static para a declaração de um membro estático.  Exemplo de Contador Auto-incremento  Como agora temos um endereço na memória que todos os objetos podem fazer referência, podemos criar um contador que adiciona o valor 1 sempre que um novo objeto (ou instância) da classe for criada.  class Produto { public int id; // novo atributo de identificação public string descricao; public float preco; public int quantidade; // referencia ao membro estático public static int contador; // construtor que recebe parâmetros public Produto(string descricao, float preco, int quantidade) { this.id = ++Produto.contador; if (descricao.Length &gt;= 3) this.descricao = descricao; if (preco &gt; 0) this.preco = preco; if (quantidade &gt;=0) this.quantidade = quantidade; } // novo construtor default public Produto() { this.id = ++Produto.contador; this.descricao = &quot;Novo Produto&quot;; this.preco = 0.01F; this.quantidade = 0; } public bool emEstoque() { return (quantidade &gt; 0); } }   Podemos ver que, como o contador é um membro estático da classe, para acessar o seu valor temos que fazer referência à classe e não ao objeto.  A essa altura, alguns de vocês já devem ter percebido que toda aplicação c# está dentro de uma classe chamada MainClass. Com o nosso novo conhecimento de membro estático, podemos ver que o termo public static void Main possui 4 elementos dos quais nós já conhecemos o significado de 3:  O termo public faz referência ao escopo de acesso;O termo static faz referência ào conceito que acabamos de aprender de membro estático;Main é apenas um nome dado ao método da classe Mainclass.  Basta aprendermos o significado do termo void e entenderemos como e porquê os programas em c# usam essa estrutura para funcionar corretamente.  Outra coisa que podemos perceber é que, pelo fato do método Main estar dentro de uma classe, se ele não fosse um membro estático, ele só seria executado na instanciação de um objeto. O problema é que esse objeto é justamente a aplicação. Ou seja, para o objeto Main ser instanciado precisaríamos de uma aplicação mas é justamente o objeto Main que contém a nossa aplicação. Por isso temos que usar o conceito de membro estático e que é disparado no momento em que a classe é carregada no nosso código.  Destrutores​  Já começamos a entender o que são destrutores lá no microfundamento de algoritmo de lógica. Recapitulando o que já sabemos, um destrutor é parecido com o construtor mas é ativado no momento em que a instância da classe é destruída pelo garbage collector no momento em que o objeto não é mais acessível a nenhuma parte do programa.  O coletor de lixo é executado em paralelo ao programa em uma thread separada do processador. Ele é executado esporadicamente e tem como missão liberar os espaços em memória sempre que identificar informações em memória que não são usadas ao longo da execução do programa por meio da busca de referência das mesmas. Mesmo não sendo o ideal, é possível forçar o .NET (que é o framework mais famoso de c#) a executar o garbage collector por meio do comando GC.Collect();.  Por padrão, todo objeto em c# tem um destrutor nativo que tem como única atividade a liberação do espaço alocado em memória. Mas assim como acontece com os construtores, podemos definir alguma rotina a ser executada no momento da sua exclusão por meio da definição explícita. A regra de definição é parecida com a do construtor com a única diferença de colocarmos um til como primeiro caractere. No nosso exemplo, o destrutor será ~Produto().  class Produto { public int id; // novo atributo de identificacao public string descricao; public float preco; public int quantidade; // referencia aos membros estaticos public static int contador; public static int instancias = 0; // construtor que recebe parametros public Produto(string descricao, float preco, int quantidade) { this.id = ++Produto.contador; this.instancias = ++Produto.instancias; if (descricao.Length &gt;= 3) this.descricao = descricao; if (preco &gt; 0) this.preco = preco; if (quantidade &gt;=0) this.quantidade = quantidade; } // novo construtor default public Produto() { this.id = ++Produto.contador; this.instancias = ++Produto.instancias; this.descricao = &quot;Novo Produto&quot;; this.preco = 0.01F; this.quantidade = 0; } public bool emEstoque() { return (quantidade &gt; 0); } // destrutor ~Produto() { Console.WriteLine(&quot;Adeus, mundo cruel!&quot;); this.instancias = Produto.instancias--; } }   Comentário Reflita sobre esse código acima. Não devemos ter nenhuma dúvida sobre todos os elementos da construção dessa classe chamada Produto. Sempre retorne e revise os tópicos anteriores até que tudo tenha sentido.  ","version":"Next","tagName":"h3"},{"title":"Encapsulamento​","type":1,"pageTitle":"Programação Modular","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular#encapsulamento","content":" Alguns assuntos podem parecer repetidos. Mas aprofundaremos mais a discussão em relação ao que já aprendemos na primeira parte desse material.  Princípio da Ocultação da Informação​  Podemos definir o princípio da ocultação como sendo:  &quot;Toda informação a respeito de um módulo deve ser privativa do módulo, exceto se for explicitamente declarada como pública.&quot;  David Parnas introduziu esse conceito em meados de 1972. No seu paper temos a seguinte citação em tradução livre:&quot;[...] A documentação dos sistema que torna todas as informações acessíveis a todos os trabalhadores do projeto é discutida. A tese que essa informações deve ser 'pública' é temerária porque, na maioria dos casos, é útil que a informação sobre o sistema esteja escondida da maioria dos programadores [...]&quot;.  Interface  Podemos definir a interface de uma aplicação de software como:  &quot;Tudo aquilo que o usuário do objeto vê e acessa.&quot;  Podemos ver que esse conceito de &quot;usuário&quot; serve tanto para o usuário da aplicação quanto para outros programadores que usarão algum objeto de uma classe que criamos anteriormente nos nossos módulos.  No contexto do princípio da ocultação da informação, temos que pensar em interfaces que demonstrem apenas os aspectos estáveis da solução. Tudo que for dinâmico são do escopo da implementação.  Um módulo pode ocultar informações como, por exemplo, Algoritmos e Representação de Dados.  A interface pode ser divida em duas partes:  Assinatura - Nomes e Tipos de informações sobre as funções do móduloEspecificação - Descrição sobre o significado e funcionamento dessas funções  Comentário Essa seção será expandida em tempo oportuno porque esse assunto é muito vasto para pararmos apenas nesses conceitos básicos.  Encapsulamento  Um módulo deve ter um conjunto de comandos e a especificação desses comandos, já vimos que essa parte pode ser chamada de interface do módulo. O conceito de encapsulamento é derivado do princípio da ocultação da informação no sentido que todo módulo pode receber (e normalmente recebe) atualizações na sua parte de implementação sem que haja mudanças visíveis na camada de interface.  Dizemos que os atributos dos módulos são protegidos pelo encapsulamento porque ficam restritos apenas à camada interna não acessível a todos. Quando queremos um input de dados do usuário damos sempre preferência aos métodos do nosso objeto porque dessa maneira podemos validar os dados inseridos.  Além dessa capacidade de manutenção na camada de implementação, o encapsulamento permite a proteção da lógica da regra de negócio para a construção das classes. No exemplo do produto, podemos encapsular a variável quantidade por meio do acesso mediante apenas a um método pre-definido. Isso nos dá a certeza que um usuário não poderá inserir valores da maneira inadvertida que possam gerar resultados imprevistos no nosso sistema.  Um conceito relevante que podemos destacar é chamado de encapsulamento e princípio da caixa preta. Que pode ser resumido como:  &quot;Um módulo deve consistir de um conjunto de comandos com uma função bem definida e o mais independente possível em relação ao resto do sistema.&quot;  Existem outras características relevantes na construção dos módulos que devemos observar:  Independência Funcional - Cada módulo é responsável por uma função específica e bem definida;Coesão - Todas as partes de um módulo devem estar logicamente ligadas às outras. Assim como um sistema deve ter módulos logicamente relacionados;Acoplamento - Relação de dependência entre os módulos de um sistema. O ideal é um baixo nível de acoplamento    Na imagem acima, cada caixa é uma módulo que possui relações internas (que devem ser coesas). Um alto acoplamento é aquele que permite muitas conexões entre os módulos de modo a, em caso de falha em um dos nós da rede, existir um risco de efeito cascata em caso de falha.  Modificadores de Acesso​  O princípio da ocultação da informação é aplicado por meio do encapsulamento. O c# e outras linguagens modernas permitem que controlemos o nível de visibilidade dos membros de uma classe de forma a ocultarmos todos os dados e métodos que precisarmos para garantir o cumprimento da tarefa com todos aqueles requisitos de qualidade de software alcançados.  Em c# existem 3 níveis de acesso aos atributos e métodos que podemos usar na criação de um módulo5:  private - Acesso apenas na própria classe;protected - Acesso permitido na própria classe e em suas subclasses (ou classes filhas);public - Acesso em qualquer parte do programa  Comentário Por default, o c# atribui o nível privado quando nenhum modificador de acesso é atribuído explicitamente. Mas é sempre uma boa prática tornar os acessos sempre explicitamente visíveis no código, mesmo quando eles são privados.  Voltando à nossa classe Produto. O ideal seria manter todos os atributos privados com apenas os construtores e o método de checagem de estoque acessíveis ao usuário.  class Produto { private int id; // novo atributo de identificacao private string descricao; private float preco; private int quantidade; // referencia aos membros estaticos private static int contador; private static int instancias = 0; // construtor que recebe parametros public Produto(string descricao, float preco, int quantidade) { this.id = ++Produto.contador; this.instancias = ++Produto.instancias; if (descricao.Length &gt;= 3) this.descricao = descricao; if (preco &gt; 0) this.preco = preco; if (quantidade &gt;=0) this.quantidade = quantidade; } // novo construtor default public Produto() { this.id = ++Produto.contador; this.instancias = ++Produto.instancias; this.descricao = &quot;Novo Produto&quot;; this.preco = 0.01F; this.quantidade = 0; } public bool emEstoque() { return (quantidade &gt; 0); } // destrutor ~Produto() { Console.WriteLine(&quot;Adeus, mundo cruel!&quot;); this.instancias = Produto.instancias--; } }   Regras de Encapsulamento  Para facilitar a internalização do princípio da ocultação da informação. Podemos elencar algumas regras de bolso para serem usadas sempre que uma dúvida a respeito desse tema aparecer:  Sempre opte pelo nível de acesso mais restrito que faça sentido para cada membro6 da classe;Use private a menos que haja uma boa razão para o contrário;Use public apenas para constantes  Comentário Os pontos 1 e 2 são praticamente a mesma coisa na minha visão. A lógica do ponto 3 é que quanto mais membros de classe públicos, maior é a chance que outros módulos façam uso deles, desse modo, o risco de um alto acoplamento se torna cada vez maior.  Métodos de Acesso e Propriedades​  O princípio da ocultação da informação não nos impede de ter acesso aos atributos. Nós apenas nos certificamos que eles serão seguramente acessados por meios dos métodos que deixaremos disponíveis para interação.  Chamamos de métodos de acesso os meios criados para permitir que os usuários tenham capacidade de acessar da maneira desejada as informações contidas nos atributos dos nossos objetos. Desse modo, temos a confiança que os valores atribuídos aos atributos dos nossos objetos sempre obedecerão às regras definidas nos seus métodos públicos.  Comentário Já iniciamos esse assunto anteriormente no nosso material.  Métodos get (leitura): É capaz de acessar um valor de atributo privado.  Métodos set (escrita): É capaz de atribuir valor a um atributo privado.  Até o momento, a nossa classe (que também chamamos de módulo) está criada de maneira que ainda não podemos ter acesso a seus atributos propriamente.  Uma maneira de criar um método de acesso get para o nosso atributo de preço pode ser:   [...] private float preco; [...] // método de acesso get para atributo preco public float GetPreco() { return preco; } [...]   Podemos ir um pouco além de criar um método de acesso set da seguinte maneira:   [...] private float preco; [...] // método de acesso set para o atributo preco public void SetPreco(float preco) { if (preco &gt; 0) { this.preco = preco; } } [...]   Desse modo, criamos a leitura e a escrita do atributo intermediados pelos métodos que nos permitem controlar as características do input realizado e, assim, nos dar segurança que nossa aplicação se comportará da maneira desejada.  Propriedades  Podemos melhorar ainda mais a legibilidade do nosso código por meio do uso das propriedades nativas dos atributos de um módulo. Podemos definir uma propriedade como um tipo especial de atributo que possui métodos associados a ele.  Temos 3 métodos que podem nos conferir mais clareza no código e alcançar o mesmo resultado que nossos códigos anteriores:  init - Atribui o valor inicial ao atributo da classe;set - Atualiza o valor de um atributo;get - Retorna o valor atual de um atributo  Reescrevendo nossos métodos de acesso à propriedade de preço, temos que:   [...] private float preco; [...] // criando a propriedade Preco public float Preco { get { return preco; } // outra maneira de sintaxe para o get: // get =&gt; this.preco set { if (value &gt; 0) preco = value; } } // criando a propriedade Preco2 sem nenhum verificador public float Preco { get; set; }   O parâmetro value é passado junto ao método set para atualização dos valores dos atributos.  Mais informações sobre as propriedades podem ser encontradas nesse link.  Namespaces e Partial Classes​  Namespaces​  Já entendemos que um módulo deve ser autocontido e com um propósito bem definido. Entretanto, isso não quer dizer que teremos, na construção de um sistema complexo, apenas 1 módulo que englobe toda a solução. Para tanto, quebramos as relações e tarefas em vários módulos diferentes sempre respeitando os princípios que aprendemos anteriormente sobre código de qualidade.  Agora que temos vários módulos, precisaremos de uma maneira de agrupa-los de maneira que faça sentido. É exatamente para isso que existe o conceito de namespaces. Com esse conceito, podemos criar uma lógica mais geral que englobe vários módulos.  Os namespaces são usados para a criação de bibliotecas de código e podem ser entendidos como um conjunto de classes.  Por convenção e organização lógica, sempre que tivermos a necessidade de criarmos um namespace, devemos salvar todas as classes contidas nele em arquivos separados e um arquivo de código por classe. Por exemplo, se nossa solução possui dois namespaces com uma classe em cada, criaremos duas pastas na raiz do nosso programa, sendo cada uma delas nomeada pelo seu respectivo namespace. Abaixo temos um exemplo de organização de arquivos.   |- code/ |- bin/ |- namespace1/ |------------ class1.cs |------------ class2.cs |-namespace2/ |------------ class1.cs |------------ class2.cs |------------ class3.cs |- obj/ |- Program.cs   Podemos ver que nosso programa tem como diretório raiz a pasta &quot;code&quot;. Dentro dela temos o nosso arquivo de código principal Program.cs. Também podemos ver diversas classes separadas em cada pasta namespace. Isso nos permite uma manutenção mais simples a medida que nosso programa se torne cada vez mais complexo e refinado.  Do ponto de vista do código. Em c# o namespace é declarado dentro das classes que estão dentro dele:  namespace Contabil { public class Juros { public float Valor { get; set; } } }   Também podemos importar namespaces em outros módulos por meio do token using:  using Contabil; class MainClass { public static void Main(string[] args) { Contabil.Juros jurosAReceber = new Contabil.Juros(); jurosAReceber.Valor = 12345.23F; Console.WriteLine($&quot;Juros a Receber: {jurosAReceber.Valor:C2}&quot;); } }   Mesmo não sendo o ideal, outro problema que o namespace resolve é o de conflito de nomes de métodos ou classes. Nos exemplos acima, só usamos um namespace Contabil com uma classe chamada Juros. Entretanto, poderíamos, sem nenhum problema, termos criado outro namespace, Financeiro por exemplo, com uma classe chamada juros. Não teríamos problema de conflito de nomes porque na hora de instanciarmos as classes nós sempre fazemos referência ao namespace em que a classe se encontra.  Partial Classes  O recomendado hoje em dia é que uma classe deve ser implementada em um único arquivo7. Mas, como tudo na vida, as vezes precisamos fazer concessões.  É possível definirmos uma classe em mais de um arquivo. Chamamos esse tipo de classe de partial class. A ideia é facilitar a organização de classes muito grandes de maneis mais fácil para manutenção. Esse tipo de abordagem é especialmente relevante para programação frontend de interfaces gráficas porque a quantidade de código gerado pelo compilador é enorme.  Podemos atualizar nossa estrutura de pastas com uma partial class agora.  |- code/ |- bin/ |- namespace1/ |------------ class1.cs |------------ class2.cs |-namespace2/ |------------ class1.cs |------------ class2.cs |------------ class3.cs |- partialClass1.cs |- partialClass2.cs |- obj/ |- Program.cs  Desse modo podemos criar um &quot;pedaço&quot; da classe em cada arquivo separado. O código ficará assim:  // parte 1 public partial class ClasseParcial { public string tarefa { get; set; } } // parte 2 using System; public partial class ClasseParcial { public void ExibeTarefa() { Console.WriteLine(&quot;Esu estou &quot; + this.tarefa); } }   No arquivo Program.cs teremos:  using System; class MainClass { public static void Main(string[] args) { ClasseParcial classeParcial = new ClasseParcial(); classeParcial.tarefa = &quot;escrevendo&quot;; classeParcial.ExibeTarefa(); } }   A documentação oficial pode ser encontrada nesse link.  ","version":"Next","tagName":"h3"},{"title":"Herança​","type":1,"pageTitle":"Programação Modular","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular#herança","content":" Generalização e Especificação​  Em todo processo de desenvolvimento é normal que a solução evolua com o passar do tempo e estruturas criadas anteriormente (como módulos) acabam evoluindo junto.  Nesse contexto é que surgem dois conceitos importantes para o nosso aprendizado: Generalização e Especificação.  Podemos entender como processo de Generalização a construção de uma classe genérica a partir da abstração de várias classes mais definidas. Como, por exemplo, ao desenvolvermos uma solução que tenha vários objetos relacionados à cada tipo de produto que um supermercado venda. Podemos procurar os elementos comuns em todas as classes de diferentes produtos e construir uma classe maior denominada ``produto&quot;. Chamamos esse caminho (de baixo pra cima) de bottom-up.  No caminho oposto, temos o processo de Especificação. Nessa lógica, podemos partir de uma classe maior e, pela necessidade, criamos subclasses que compartilham elementos comuns com essa classe mais geral. Como exemplo, podemos citar um sistema de gerenciamento de condomínio que pode ter a classe &quot;bloco&quot; onde vai receber todas as informações e métodos de cada bloco e, por demanda de informações mais detalhadas, passemos a criar classes menores chamadas &quot;andar&quot; ou &quot;apartamento&quot; que contém informações adicionais ao nosso objeto anterior. Esse caminho (de cima pra baixo) é chamado de top-down.  Herança  Na criação de uma classe através da generalização ou da especificação é que o conceito de herança é nascido. Como estamos criando classes em termos de outras pré-existentes, devemos descrever a relação entre essas diferentes classes.  No momento da definição da relação de herança podemos usar os vínculos do tipo &quot;é um tipo de&quot; ou &quot;é um&quot;.  Quando criamos uma herança, o objeto mais geral é chamado de supertipo. Todos os subtipos desse objeto compartilham as características dele e recebem novas que não são atribuídas ao supertipo.  Podemos chamar os subtipos de classes derivadas, classes filhas, subclasses e etc. Por outro lado, as classes mais gerais podem ser chamadas de classes base, superclasses classes pai e etc.  Existem linguagens que permite que uma subclasse receba harança de diferentes superclasses. Chamamos isso de herança múltipla e, ao contrário do que pode parecer, não é uma ideia muito boa porque aumenta o risco de auto acoplamento. Para tanto, o c# não permite herança múltipla.  Exemplo de Herança em c#  Agora que aprendemos os conceitos, podemos aprender como criar essas relações usando a linguagem c#. Partindo de uma superclasse chamada Pessoa, podemos criar as subclasses do seguinte modo:  // superclasse class Pessoa { [...] } // subclasses class Professor : Pessoa { [...] } class Aluno : Pessoa { [...] }   Retomando nosso exemplo para o módulo Produto, podemos criar uma subclasse chamada BemDeConsumo:  using System; class BemDeConsumo : Produto { private DateTime validade; public DateTime Validade { get =&gt; this.validade; set =&gt; this.validade = (value &gt; DateTime.Now) ? value : DateTime.Now; } } class BemDuravel : Produto { private in garantia; public int Validade { get =&gt; this.garantia; set =&gt; this.garantia = (value &gt; 0) ? value : 6; } }   Comentário Não se assustem pela mudança na maneira de escrever as propriedades get e set. Esse token =&gt; é interpretado do mesmo jeito que o par de chaves vistos anteriormente.  Ao usarmos essas subclasses no nosso programa, elas terão os mesmo atributos e métodos que a superclasse Produto que elaboramos durante todo esse capítulo.  Comentário Existe um princípio da programação orientada à objetos que prioria composição ao invés da herança. A ideia é que é melhor fazer as conexões entre classes de mesma hierarquia do que criar uma vasta linha entre superclasses e subclasses. Em tempo oportuno retomaremos essa discussão. Por enquanto segue esse link com esse assunto.  Construtores em Classes Filhas​  Quando instaciamos um objeto a partir de uma classe filha, primeiro disparamos os construtores da classe pai para, depois, executarmos os construtores da subclasse.  Se a classe filha não indicar um construtor diferente, o c# usa o construtor default da classe pai. Entretanto, é possível definir quais serão os atributos usados tanto no processo de construção herdados quanto nos nativos da subclasse. Para usarmos essa configuração de construção, passamos os parâmetros através do token : base(atributos).  Exemplo de Construtores em Classes Estendidas (Subclasses ou Classes Filhas)  Para exemplo, usaremos as subclasses BemDeConsumo que já vimos nos exemplos passados.  using System; class BemDeConsumo : Produto { private DateTime validade; public DateTime Validade { get =&gt; this.validade; set =&gt; this.validade = (validade &gt; DateTime.Now) ? value : DateTime.Now; } public BemDeConsumo(string descricao, float preco, int quantidade, DateTime validade) : base(descricao, preco, quantidade) { this.validade = validade; } }   No exemplo acima, o nosso construtor da classe filha receberá 4 parâmetros dos quais 3 (descrição, preço e quantidade) serão usados no processo do construtor da classe pai.  Construtores e encapsulamento são o primeiro passo para a garantia da correção e robustez de um sistema. Sempre que usarmos a herança, temos que nos valer dessas técnicas para melhorar a qualidade dos nossos programas.  ","version":"Next","tagName":"h3"},{"title":"Polimorfismo e Princípios do Projeto Modular​","type":1,"pageTitle":"Programação Modular","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular#polimorfismo-e-princípios-do-projeto-modular","content":" ","version":"Next","tagName":"h2"},{"title":"Polimorfismo de Inclusão​","type":1,"pageTitle":"Programação Modular","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular#polimorfismo-de-inclusão","content":" Nessa seção vamos aprender como reutilizar soluções de código por meio do uso de hierarquia entre classes. Esse tipo de &quot;transformação&quot; entre classes filhas e superclasses é chamado depolimorfismo de inclusão.  Sobreposição de Métodos (virtual e override)​  Podemos conceder certas liberdades aos nossos objetos derivados de superclasses. Uma dessas liberdades é a capacidade de sobreposição ou override que é dada, quando queremos permitir que um atributo ou método tenha seu funcionamento modificado nas classes filhas mantendo-se o mesmo nome que o seu referente na classe pai. Usamos o token virtual na classe pai no momento da sua construção para permitir as sobreposições futuras.  Da mesma maneira que temos um token na classe pai, temos que usar o token override na classe filha para indicar a sobreposição de atributo ou método. Além de sobrescrever, podemos fazer uso do método original da superclasse por meio do token de referência base8.  Outra requisição obrigatória no processo de sobreposição é o uso do token new na hora da criação de um método ou atributo de mesmo nome na classe original. Abaixo temos um exemplo de como podemos expandir um método criado na classe origina por meio da sobreposição.  Comentário Até agora usamos várias vezes o token void e ainda não tivemos a satisfação de uma definição do que ele faz. O token void é usado na construção de métodos sem retorno, ou seja, funções que não possuem uma linha com o comando return.  using System; class superClasse { public string str = &quot;string original&quot;; // permitindo a sobrescrita por meio do token 'virtual' public virtual void mostra() { Console.WriteLine(&quot;Mostra original&quot;); } } class subClasse : superClasse { // criando uma variável 'str' na classe filha public new string str = &quot;String nova&quot;; // override do método original public override void mostra() { Console.WriteLine(&quot;-------&quot;); base.mostra(); // função original Console.WriteLine(&quot;-------&quot;); Console.WriteLine(&quot;Mostra Estendida&quot;); Console.WriteLine(&quot;-------&quot;) } }   Polimorfismo Universão de Inclusão  Os três princípios básicos da programação orientada à objetos são:  EncapsulamentoHerançaPolimorfismo  Já sabemos o que são os dois primeiros. Sabemos que a herança nos permite reaproveitar códigos anteriores em novos contextos. Entretanto, é raro termos aplicações exatamente iguais às do momento em que as classes originais foram criadas. É precisamente nesse contexto que surge o nosso terceiro princípio da OOP.  O Polimorfismo nos permite &quot;adaptar&quot; ou sobrepor algumas característica originais trazidas pela herança nos objetos derivados de classes anteriormente cridas. Ele nos permite criar sobreposições de métodos derivados para o melhor aproveitamento e adaptação aos problemas novos.  Para a existência do polimorfismos são necessários três requisitos:  HerançaSobreposição de MétodosReferência de uma superclasse que aponte para um objeto de uma subclasse (referência polimórfica)  Vamos a um exemplo de polimorfismo mas com o devido contexto. É natural pensar que um objeto contenha um método cuja saída seja uma string com as informações a respeito dele. Em c# existem métodos nativos, ou seja, que existe por padrão em todos os objetos, cujo um deles é chamado toString() que retorna uma string com informações sobre o objeto.  Comentário Mais sobre esse assunto pode ser encontrado nessa documentação oficial.  Mas como esse método é nativo, normalmente ele só trás algumas poucas informações sobre os objetos. Pensando nos atributos de qualidade de software que aprendemos até agora, não faz sentido (ou não é indicado) criarmos um método novo que retorne uma string com informações das nossas classes instanciadas porque já temos um por default. Como podemos resolver o fato desse método nativo não ser suficientemente detalhado? Polimorfismo é a solução!  Agora vamos fazer uma mudança no comportamento do método nativo das classes em c# toString().  class Produto { private int id; private string descricao; private float preco; private int quantidade; private DateTime fabricacao; private static int contador = 0; private static int instancia = 0; [...] public override string ToString() { return $&quot;Produto {id}: {descricao}\\n Preço : {preco:C2}\\n Quant : {quantidade}\\n Fabric: {fabricacao}&quot;; } }   Comentário Mas espere um segundo. Temos um override em uma classe pai?! É isso mesmo! A razão disso é que todas as classes em c# são, de certa maneira, classes filhas de uma classe mestre que contém todos os métodos padrões. Mesmo as classes pai.  using System; class BemDeConsumo : Produto { private DateTime validade; public DateTime Validade { get =&gt; this.validade; set =&gt; this.validade = (value &gt; DateTime.Now) ? value : DateTime.Now; } // construtor public BemDeConsumo(string descricao, float preco, int quantidade, DateTime fabricacao, DateTime validade) : base(descricao, preco, quantidade, fabricacao) { this.valiade = validade; } public override string ToString() { return base.ToString() + $&quot; validade : {validade}&quot;; } }   Comentário Essa seção é bem densa e importante. Pare e reflita sobre os códigos que foram vistos aqui. Revise sempre que necessário.  Classes Abstratas​  Em c# podemos definir métodos sem declarar as suas implementações, ou seja, reservamos os nomes mas não dizemos o que eles farão. Não é de se estranhar que esses métodos recebam a nomenclatura de métodos abstratos. Se uma classe possui um ou mais desses métodos ela é chamada de classe abstrata porque não contém tudo que é necessário para a construção de uma classe normal.  Como as classes abstratas são &quot;incompletas&quot;, não podemos instanciar objetos com elas. Entretanto, podemos usar o que aprendemos de polimorfismo para &quot;preencher&quot; essas lacunas por meio das classes derivadas. Uma classe herdeira também herda os métodos da classe abstrata, sejam eles abstratos ou não.  Abaixo temos a criação de uma classe abstrata com um método abstrato. Percebam o uso do token abstract para esses casos.  // criacao da classe abstrata abstract class Pai { // criacao do metodo abstrato public abstract string fazNadaAinda(); } // classe filha class Filha : Pai { public override string fazNadaAinda() { Console.WriteLine($&quot;{Agora eu faço algo!}&quot;); } }   Perceba que o método fazNadaAinda é apenas declarado sem qualquer construção da funcionalidade do mesmo. Se tentarmos instanciar essa classe, teremos um erro porque classes abstratas não podem ser instanciadas em objetos concretos. Mas podemos criar uma classe filha que dará o restante da lógica necessária a sua instanciação.  Abaixo temos um exemplo de um programa simples que conta até 10 com o uso de uma classe abstrata pai.  namespace Program { // classe abstrata public abstract class Pai { // método abstrato public abstract int fazNadaAinda(); } // classe filha public class Filha : Pai { private int contador; public int Contador { get =&gt; this.contador; set =&gt; this.contador = value; } // método abstrato herdado public override int fazNadaAinda() { return contador = ++contador; } } // programa class MainClass { public static void Main(string[] args) { // instanciação da classe filha Filha objFilha = new Filha(); // loop usando o método abstrato que agora possui definição while (objFilha.Contador &lt; 10) Console.WriteLine($&quot;{objFilha.fazNadaAinda()}&quot;); } } }   Comparando Virtual e Abstract​  Referente às classes:  Classes não podem ser virtualClases com algum elemeto declarado como abstract devem ser abstract tambémClasses abstratas não podem ser instanciadas  Referente aos membros das classes:  Membros de classes criados com virtual podem ser criados na classe e sobrepostos pelas classes filhasMembros de classes criados com abstract devem ser implementados nas classes filhas por meio do token override  Polimorfismo  Volte nos 3 requisitos de existência do polimorfismo. Agora podemos ver que para a existência desse conceito, deve existir pelo menos duas classes de hierarquias diferentes em que exista algum grau de criação genérica na classe original que será definida na classe derivada.  Para a melhor fixação desse conteúdo, o professor nos dá um exemplo de lista de figuras: Considere que queremos implementar uma lista de figuras genérica capaz de armazenar diversos tipos de objetos geométricos. Cada objeto terá informações sobre coordenadas x e y; lado; cor e se possui ou não preenchimento. De posse dessas informações, podemos definir um método desenhar() que mostrará na tela uma representação visual da figura cadastrada. Entretanto, cada figura terá o seu conjunto próprio de características.  Esse é um caso ótimo para o polimorfismo.  using System.Drawing; public abstract class Figura { public int X {get; set;} public int Y {get; set;} public int Lado {get; set;} public Color Cor {get; set;} public bool Preenchido {get; set;} public figura(int x, int y, int lado, Color cor, bool preenchido) { this.X = x; this.Y = y; this.Lado = lado; this.Cor = cor; this.Preenchido = preenchido; } // método abstrato public abstract void Desenha(); }   De posse dessa abstração chamada Figura, podemos estender esse conceito através do polimorfismo através da criação de classes filhas.  class Quadrado : figura { public Quadrado(int x, int y, int lado, Color cor, bool preenchido) : base(x, y, lado, cor, preenchido) { // como todos os parâmetros foram // usados no construtor base // aqui fica vazio } public override void Desenha() { Console.WriteLine($&quot;Desenhando o Quadrdo&quot;) } } class Circulo : Figura { public Circulo(int x, int y, int lado, Color cor, bool preenchido) : base(x, y, lado, cor, preenchido) { // como todos os parametros foram // usados no construtor base // aqui fica vazio } public override void Desenha() { Console.WriteLine($&quot;Desenhando o Circulo&quot;) } }   Nosso programa agora é capaz (hipoteticamente) de construir figuras que sejam quadrados e círculos. Vejam como usamos o polimorfismo para a construção dessa solução. Podemos criar 2 objetos do seguinte modo:  class MainClass { public static Figura[] figuras = new figura[10]; public static int numfig = 0; public static void Main(string[] args) { figuras[numFig++] = new Quadrado(10,20,50,Color.Red, true); figuras[numFig++] = new Circulo(100,225,80,Color.Blue, false); for (int pos = 0; pos &lt; numFig; pos++) { figuras[pos].Desenha(); } } }   Comentário Se ficou na dúvida, lembre-se do que aprendemos sobre vetores na disciplina de abstração de dados.  Classes e Membros Selados (sealed)​  Da mesma maneira que aprendemos como permitir o polimorfismo, o c# também nos permite impedir que certas classes ou membros de classe sofram herança ou polimorfismo.  Para impedir que uma classe sofra hierarquia, basta defini-la com o token sealed. Isso automaticamente torna esse classe um classe final da hierarquia.  Quando o assunto é um membro de classe (atributo, método ou propriedade) a ideia é bem parecida. Basta usarmos o token sealed para impedir que outros programadores façam uma modificação em algum membro de classe que não temos a intenção que seja alterado por meio de um override.  Como exemplo, o professor da matéria nos dá um método de validação de usuário:  protected sealed bool validateUser()   Se não atribuirmos o selamento do método, é possível que algum programador mal intencionado possa modificar nosso método por algo como:  protected override bool validateUser() { return true; }   Desse modo, nosso método de validação se tornou completamente inútil. Entretanto, da maneira que construímos, o programa do programador mal intencionado retornará um erro porque ele está tentando usar polimorfismo em um membro de classe selado.  Outra vantagem além da segurança é a performance. Como aquela classe não será mais hierarquizada, o compilador trabalhará com ela de um modo a não se preocupar com associações dinâmicas existentes em classes com polimorfismo.  Comparando Private e Sealed  Uma dúvida que pode surgir é a respeito da diferença prática entre usarmos o escopo private para controle de acesso e o sealed para controle de hierarquia.  Vamos aos comparativos:  Private Não podem ser declarados no namespace (apenas dentro de uma classe)Não permitem instânciasAcesso aos membros apenas no bloco de declaração Sealed Podem ser declaradas no namespacePermitem instanciamento (dependendo se for public, private ou protected)Membros de instâncias podem ser acessados por meio dos seus objetos e métodos  Em uma análise básica, o private também é um tipo de controle. Mas o sealed permite que as classes ainda permitam que seus métodos sejam acessíveis às classes filhas sem que possam alterar seus membros e, no caso de uma classe selada, temos a vantagem de instanciamento e criação no namespace.  Abaixo temos um exemplo da implementação desses conceitos.  using System; namespace ClassesSealed { class Extensivel { public virtual void Primeiro() { Console.WriteLine(&quot;Extensível: primeiro método.&quot;); } public virtual void Segundo() { Console.WriteLine(&quot;Extensível: segundo método.&quot;); } } // Aqui temos uma classe estendível com dois procedimentos que apenas imprimem saídas no // terminal. Agora vamos acompanhar como podemos interagir com ela usando o token `sealed`. // classe com membro selado class MembroSelado : Extensivel { public sealed override void Primeiro() { Console.WriteLine(&quot;Membro Selado: primeiro método.&quot;); } public override void Segundo() { Console.WriteLine(&quot;Membro Selado: segundo método.&quot;); } } // classe selada filha da classe de membros selados sealed class Selada : MembroSelado { // Tentativa de sobrepor um método selado // error: 'Selada.Primeiro()': cannot override inherited member 'MembroSelado.Primeiro()' protected override void Primeiro() { Console.WriteLine(&quot;Selada: primeiro método.&quot;); } // esse nao retorna erro public override void Segundo() { Console.WriteLine(&quot;Selada: segundo método.&quot;); } } // Tentativa de extender uma classe selada. // error: 'Sobreposição': cannot derive from sealed type 'Selada' class Sobreposicao : Selada { protected override void Primeiro() { Console.WriteLine(&quot;Sobreposicao: primeiro método.&quot;); } public override void Segundo() { Console.WriteLine(&quot;Sobreposicao: segundo método.&quot;); } } class MainClass { public static void Main(string[] args) { Console.WriteLine(&quot;O código não compila.&quot;); } } }   ","version":"Next","tagName":"h3"},{"title":"Polimorfismo Paramétrico​","type":1,"pageTitle":"Programação Modular","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular#polimorfismo-paramétrico","content":" Tudo o que estudamos sobre polimorfismo que usa herança para reutilização de códigos com a estenção dos métodos é chamado do polimorfismo de inclusão. Agora, vamos aprender sobre outro tipo de polimorfismo.  Imagine que temos que resolver um problema em uma classe e, no processo de ponderação da solução, nos deparamos com uma outra classe que contém um método que resolve o nosso problema. Podemos reutilizar métodos entre classes que não compartilham a mesma hierarquia? A resposta é sim. Isso é o que chamamos de polimorfismo paramétrico.  Nesse tipo de polimorfismo, nós não precisamos instanciar um novo objeto a partir da classe. Podemos fazer uso diretamente dos métodos desse tipo especial de classe chamada de classe genérica.  Tipos Genéricos​  Tal qual o polimorfismo de inclusão, teremos um novo token usado na construção das classes em que usaremos o polimorfismo paramétrico. Chamamos de classes genéricas as classes que são criadas sem um tipo de dados especificado. O tipo de dado que essa classe trabalhará será passado como um parâmetro9.  A declaração de uma classe genérica é feita do mesmo modo da declaração de uma classe normal com a inclusão do token &lt;&gt; após o nome da classe que dará a declaração do tipo.  A declaração de um objeto instanciado de uma classe genérica é feita com a passagem do parâmetro do tipo de dado a ser manipulado no objeto. Diferente das classes abstratas, não precisamos instanciar com a criação de um novo objeto nomeado. Podemos apenas passar o tipo de dado e fazer uso dos métodos da classe diretamente por meio de um ponto seguido do nome do método (classeGenerica.metodo(new T)).  Assim como os tipos abstratos, dentro de uma classe genérica podemos ter membros de classes (métodos, atributos e propriedades) passados como sendo de tipo genéricos. A única condição é que seja usada a variável declarada na assinatura da classe (ela está dentro dos sinais &lt;&gt;.  Abaixo temos um exemplo de construção de um programa que julga se dois conjuntos são disjuntos10.  Comentário Não se preocupe se não entender o algoritmo de primeira. Eu tentei ser bem generoso nos comentários mas esse programa é, na minha opinião, desafiador de ser compreendido por quem não tem um background de matemática e programação um pouco desenvolvido. Leia quantas vezes for necessário e, se a dúvida persistir, entra em contato comigo pela issue do github.  using System; namespace Generics { // criacao da classe generica public class Conjuntos &lt;T&gt; { // criacao de uma funcao como membro estatico // que retorna um booleano para os vetores &quot;s&quot; e &quot;w&quot; // do tipo de dado definido por &quot;&lt;T&gt;&quot; public static bool disjuntos(T[] s, T[] w) { // loop em todos os elementos do vetor &quot;s&quot; for (int i = 0; i &lt; s.Length; i++) { // loop em todos so elementos do vetor &quot;w&quot; for (int j = 0; j &lt; w.Length; j++) { // Teste: O elemento s[i] é igual ao w[j]? // se sim, eles possuem algum elemento em comum // logo, nao sao conjuntos disjuntos! if (s[i].Equals(w[j])) return false; } } // se nenhum dos elementos dos dois conjuntos // for igual ao do outro, entao sao conjuntos // disjuntos! return true; } } // Programa Principal class MainClass { public static void Main(string[] args) { if (Conjuntos&lt;int&gt;.disjuntos(new int[] {1,3,5}, new int[] {2,4,6})) { Console.WriteLine(&quot;Conjuntos Disjuntos!&quot;); } else { Console.WriteLine(&quot;conjuntos não Disjuntos!&quot;); } } } }   Perceba como usamos o método disjuntos() sem que houvesse a necessidade de instanciamento de um novo objeto com o token new Conjuntos. Só precisamos dizer qual o tipo de dado e construir diretamente no método os conjuntos que seriam avaliados pelo método.  Coleções​  Uma coleção ou collection é um objeto que agrupa múltiplos objetos. Elas padronizam o tratamento dos objetos dentro do programa por meio da uma interface genérica.  Mas paremos pra pensar 1 minuto. Nós já não tínhamos definido um conjunto de objetos como um namespace? Sim! Uma coleção é um namespace nativo que nos fornecem métodos otimizados para o tratamento de dados de maneira a tornar nossos programas o mais eficiente possível.  Comentário Eu gosto de pensar nas coleções como um &quot;kit de ferramentas&quot; que já nos fornecem maneiras de lidar com problemas comuns. Mais vale aprender bem quais ferramentas o .NET nos dá nativamente do que perder horas e horas reinventando a roda.  Aqui vamos aprender sobre algumas das coleções que certamente usaremos várias vezes ao longo da nossa trajetória de desenvolvedores c#. Mas antes de irmos direto para elas, vamos aprender algumas características em comum que podemos avaliar para definir quando e onde implementar alguns de seus objetos.  Podemos elencar as seguintes funcionalidades comuns às coleções:  Adicionar itensRemover itensPesquisar itensSubstituir itensCopiar conjuntos de itens ou clonarRetornar as propriedades de capacidade  Coleções em C#  Existem 3 namespaces com as collections em c# (basta clicar para acessar a documentação oficial da microsoft):  System.Collections.Generic - Coleções genéricas usando polimorfismo paramétricoSystem.Collectons.Concurrent - Coleções genéricas para aplicações muilt-threadSystem.Collections - Coleções não genéricas que usam polimorfismo de inclusão  Aqui estão alguns objetos da coleção System.Collections.Generic:  Dictionary&lt;TKey,TValue&gt;List&lt;T&gt;Queue&lt;T&gt;SortedList&lt;TKey,TValueStack&lt;T&gt;  Aqui estão alguns objetos da coleção System.Collections.Concurrent:  BlockingCollection&lt;T&gt;ConcurrentDictionary&lt;TKey,TValue&gt;ConcurrentQueue&lt;T&gt;ConcurrentStack&lt;T&gt;  Aqui estão alguns objetos da coleção System.Collections:  ArrayListHashtableQueueStack  Por agora, vamos apenas citar a existência dessas coleções mas é mandatório que saibamos usar esses objetos para uma produção de software mais profissional com c#.  Classe Collectio&lt;T&gt;  Essa coleção fornece a base para implementação de tipos genéricos de dados. As classes anteriores manipulam os métodos fornecidos justamente por Collection&lt;T&gt;. A documentação oficial dessa classe pode ser encontrada nesse link. Agora vamos aprender um pouco sobre essa classe.  Construtores: Podemos iniciar uma coleção vazia com Collectoin&lt;T&gt;() ou podemos passar os valores de um objeto anteriormente criado como, por exemplo, Collection&lt;T&gt;(IList&lt;T&gt;).  Propriedades:  Count - Retorna o número de elementosItems - Retorna uma lista dos elementos do tipo Ilist11Item[Int32] - Retorna ou altera um elemento em uma posição da lista. Index inicial é 0.  Métodos de manipulação de elementos:  Add(T) - Insere um elemento no finalRemove(T) - Remove a primeira ocorrência do elementoSetAt(Int32, T) - Insere um elementa na posiçãoRemove(Int32) - Remove um elemento na posiçãoIndexOf(T) - Retorna o index de um elementoContains(T) - Bolleano para verificar se um elemento está na coleção  Métodos de manipulação de conjuntos de elementos:  Clear() - Remove todos os elementosCopyTo(T[], Int32) - Copia a Collection&lt;T&gt; para um vetorEquals(Object) - Compara duas coleções  A vantagem do uso do Collection&lt;T&gt; é que o c# já sabe como otimizar o uso de memória para esse tipo genérico de dados. Isso retira a necessidade de gestão de armazenamento para soluções que envolvam manipulação de grandes volumes de dados.  Delegates, Funções Lambda e Eventos​  Para o fechamento da nossa unidade de polimorfismo paramétrico temos três conceitos avançados de programação.  Delegates (Delegações)​  Essa estrutura nos permite passar uma referência de um método para outras classes. A sintaxe do método com delegação é parecida com a de um método qualquer com a adição do token delegate:  public delegate void Exibir(string mensagem);   Nós iniciamos o delegate passando o método como parâmetro. Por exemplo, se quisermos usar o método Exibir() acima para executar métodos que mostram mensagens. Podemos fazer do seguinte modo: &quot;  public class Program { // Metodo que printa mensagem no console public static void MensagemConsole(string mensagem) { Console.WriteLine(mensagem); } // Delegate com o tipo string de input e // tipo void de metodo public class Mensageiro { public delegate void Exibir(string mensagem); } // Como o nosso delegate foi criado para um void com string // e o nosso metodo MensagemConsole tambem possui essas // caracteristicas, podemos &quot;puxar&quot; esse metodo para // o nosso procedimento delegado Mensageiro public static void Main(string[] args) { Mensageiro.Exibir exibir = new Mensageiro.Exibir(MensagemConsole); exibir(&quot;Mensagem no console!&quot;); } }   Alguns podem se perguntar qual a utilidade de se puxar um método de outra classe. Agora observe essa modificação do código:  namespace Program { public class Class1 { // Metodo que printa mensagem no console public static void MensagemConsole(string mensagem) { Console.WriteLine(mensagem); } // Delegate com o tipo string de input e // tipo void de metodo public class Mensageiro { public delegate void Exibir(string mensagem); } } public class Class2 { // Como o nosso delegate foi criado para um void com string // e o nosso metodo MensagemConsole tambem possui essas // caracteristicas, podemos &quot;puxar&quot; esse metodo para // o nosso procedimento delegado Mensageiro public static void Main(string[] args) { Class1.Mensageiro.Exibir exibir = new Class1.Mensageiro.Exibir(Class1.MensagemConsole); exibir(&quot;Mensagem no console!&quot;); } } }   Perceba que agora, estamos fazendo referência ao método MensagemConsole no delegate que estão em outra classe sem qualquer relação de hierarquia entre as classes 1 e 2! O poder do delegate está justamente na capacidade de passarmos métodos sem o vínculo formal das hierarquias.  A documentação oficial dessa estrutura é encontrada nesse link.  Funções Anônimas (Lambda)​  Essa é uma das estruturas que possuem várias implantações práticas. Até agora, todas as funções que criamos tinham de ter um nome associado. Entretanto, c# e outras linguagens modernas permitem criar funções específicas que podem ser executadas sem a necessidade de criação de um objeto para elas.  Temos algumas maneiras de usar as funções lambda em c#. A primeira delas é com uso do delegate:  class Program { // delegate com int e dois valores inteiros public delegate int Soma(int x, int y); static void Main(string[] args) { // aqui estamos declarando a forma // funcional da funcao Soma(x,y) // sintaxe 1 Soma soma1 = (int x, int y) =&gt; { int result = x + y; return result; } // sintaxe 2 Soma soma2 = (x, y) =&gt; (x + y); } }   Agora vamos aprender como usar funções lambdas com o uso da classe Func&lt;T, TResult&gt;  class Program { static void Main(string[] args) { // sintaxe 1 Func&lt;int, int, int&gt; soma1 = (int x, int y) =&gt; { int result = x + y; return result; } // sintaxe 2 Func&lt;int, int, int&gt; soma2 = (x, y) =&gt; (x + y); } }   Events​  Por fim, vamos aprender como uma classe pode publicar notificações para classes assinantes. Isso mesmo, estamos falando aqui de comunicação entre classes. Esse modelo de comunicação é chamado de Publish-Subscribe (Pub-Sub) e funciona baseado em dois tipos de classes. As classes assinantes se registram na classe geradora dos eventos para que as mesmas sejam notificadas quando uma mudança de estado acontecer.  Os exemplos mais clássicos são relacionados à interação do usuário humano como: clique do mouse, novo email, teclas apertadas, cópia de arquivo finalizada e etc.  A classe assinante registra um método de chamada de retorno, denominado de callback12 que é executado quando a condição do evento é satisfeita na classe geradora.  Chamamos de hook o processo de adicionar um callback em um evento e, logicamente, chamamos o contrário disso de unhook.  Abaixo temos um exemplo em que &quot;acordaremos&quot; as classes registradas no alarme:  // Classe geradora class Alarme { // delegate Acordar que sera usado como // callback do evento public delegate void Acordar(string msg); // evento que vai chamar o metodo Acordar // em cada assinante sendo que sao as classes // assinantes que vao inserir os callbacks public event Acordar TempoEsgotado; // void para disparar o evento public void DisparaEvento() { AoEsgotarTempo(); } public void AoEsgotarTempo() { // verifica se existem assinantes do evento // se alguma classe tiver assinado por // meio do hook de callback o TempoEsgotado nao // vai ser null if (TempoEsgotado != null) { TempoEsgotado(&quot;Tempo Esgotado!&quot;); } } } // Classe assinante class Program { // callback da classe assinante public static void MensagemConsole(string msg) { Console.WriteLine(mensagem); } // programa static void Main(string[] args) { Alarme alarme = new Alarme(); // hook do callback no alarme com o // metodo MensagemConsole alarme.TempoEsgotado += MensagemConsole; // disparando o evento para receber // a mensagem do callback alarme.DisparaEvento(); } }   Comentário De todas as seções desse microfundamento, essa é provavelmente a que mais contém conceitos que diferenciam os programadores .NET iniciantes dos mais experientes. O uso dessas três categorias de polimorfismo paramétrico fazem muita diferença na qualidade do seu código e devem ser entendidas muito profundamente.  ","version":"Next","tagName":"h3"},{"title":"Projeto Orientado para Objetos​","type":1,"pageTitle":"Programação Modular","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular#projeto-orientado-para-objetos","content":" O objetivo de qualquer programador profissional é produzir códigos de qualidade. Nessa última parte do microfundamento, vamos aprender sobre alguns normativos que regem os princípios e práticas para construção de programas com essas qualidades.  Os princípios que vamos aprender aqui são uma maneira de se produzir código fácil de ler, fácil de modificar e fácil de testar. De modo a permitir que um time de desenvolvedores atue de forma colaborativa.  Comentário Uma boa maneira de saber se estamos indo bem é sempre olhar os nossos códigos se perguntando &quot;Outra pessoa poderia continuar o meu trabalho se eu sair desse projeto?&quot; ou &quot;Caso eu precise trabalhar com alguém, essa pessoa conseguirá entender o meu código apenas olhando diretamente para ele?&quot;.  Princípios SOLID​  Os princípios que vamos estudar agora foram introduzidos por Robert C. Martin (também conhecido como Uncle Bob) no artigo Design Principles and Design Patterns. Posteriormente, os conceitos foram desenvolvidos por Michael Feathers e ganharam o acrônimo SOLID. Nos últimos 20 anos, esses princípios têm impacto fortemente o mundo das programação orientada à objetos e devem ser compreendidos e internalizados por quem se propõe a entrar nessa jornada.    Os princípios SOLID são um conjunto de boas práticas de projeto de software que nos permitem construir sistemas com extensibilidade, reusabilidade, adaptabilidade e manutenibilidade. O objetivo é manter a complexidade de uma solução constante mesmo com o crescimento do tamanho dos módulos.  Os princípios SOLID são:  Single Responsability Principle (SRP)Open/Closed Principle (OCP)Liskov Substitution Principle (LSP)Interface Segregation Principle (ISP)Dependency Inversion Principle (DIP)  Fonte: Martin, Robert Cecil (2002). Agile software development: principles, patterns, and practices. Upper Saddle River, NJ: Pearson Education. ISBN 9780135974445.  Single Responsability Principle - SRP  &quot;Uma classe deve ter apenas um motivo para mudar, o que significa que ele deve ter uma única função&quot;  Se, na construção das classes, usarmos os outros princípios de coesão e encapsulamento que já aprendemos anteriormente, o SRP é consequência direta. Como cada classe deve ter uma razão de existir o mais específica e clara possível, cada classe deve ser facilmente definida e deve ter apenas uma função.  Para Roger Whitney, 2016, Advanced Object-Oriented Design &amp; Programming, se você precisar de mais de 25 palavras (uma frase) com o uso dos conectivos &quot;e&quot; ou &quot;ou&quot; para definir o que é uma determinada classe, significa que o SRP já não foi observado.  As classes precisam ter uma razão objetiva e compacta para existir.  Open/Closed Principle - OCP  &quot;Objetos ou entidades devem ser abertos para extensão, mas fechados para modificação&quot;  Aberto para extensão significa que temos que pensar em classes abstratas e interfaces que permitam novas classes concretas que estendam suas funções sem que haja modificação nas classes anteriores. Isso evita termos que adaptar uma classe que seja referência para várias outras constantemente, evitando o risco de quebras em cascata por conflito de herança.  Liskov Substitution Principle - LSP  &quot;Se q(x) é uma propriedade demonstrável dos objetos x de tipo T. então q(y) deve ser verdadeiro para objetos y de tipo S, onde S é subtipo de T&quot;  Essa maneira de definir é derivada da formalização matemática mas, em resumo, se S e é uma subclasse de T. Se temos uma propriedade q() que funciona em T, essa propriedade deve ser herdada para S devido a sua herança.  Isso implica que podemos sempre Substituir objetos por seus subtipos sem prejuízo porque todos os métodos do objeto anterior devem ser herdados pelos objetos filhos.  Interface Segregation Principle - ISP  &quot;Classes não devem ser forçadas a implementar uma interface que não usam, ou seja, não devem ser forçadas a depender de métodos que não usam&quot;  Como contraponto ao LSP, uma classe não deve ter comportamentos (ou métodos) que não façam sentidos a ela. Esse controle é obtido pela separação em classes diferentes para que as classes sempre possuam apenas o necessário.  Dependency Inversion Principle - DIP  &quot;Módulos de alto nível não devem depender de módulos de baixo nível. Ambos devem depender de abstrações&quot;  Na construção de soluções complexas, temos que evitar referenciamento para objetos concretos. As referências devem ser sempre para tipos abstratos que podem ser instanciados em situações concretas de uso.  Outra implicação do DIP é que não devemos derivar classes de uma classe concreta. As classes base devem ser sempre abstratas porque assim permitem que as subclasses sejam expandidas a medida que novos problemas e melhorias são inseridas no processo.  Nenhum método deve sobrescrever os que foram herdados da sua classe base. Ao fazer isso, corremos o risco de violar o LSP porque aumentamos o risco da propriedade (ou método) da classe base não se comportar como o previsto na classe derivada após a sua modificação.  Padrões de Projeto​  Para concluir nossa jornada (inicial) no mundo da programação modular, vamos aprender mais sobre Padrões de Projetos que são maneiras de organizar uma solução para resolver problemas relativamente comuns ao processo de Engenharia de Software. Eles são modelos que precisam ser adaptados aos casos concretos e não metodologias dogmáticas.  Um padrão foca apenas nos aspectos essenciais da construção do projeto e os detalhes são omitidos porque cada projeto possui especificidades únicas.  Fonte: Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. 1995. Design patterns: elements of reusable object-oriented software. Addison-Wesley Longman Publishing Co., Inc., USA.  O começo dos padrões computacionais é referido à Beck e Cunningham que apresentaram suas ideias na conferência OOPSLA (Object-Oriented Programming, Systems, Languages, and Applications) em 1987 para uma linguagem famosa na época chamada Smalltalk.  Posteriormente, os trabalhos de Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides que ficaram conhecidos como &quot;Gang of Four&quot; foram responsáveis pela popularização dessa linha de conhecimento no processo de construção de soluções. Os padrões apresentados por eles em 1995 ficaram conhecidos como GoF Patterns.  O foco dos padrões é a reutilização de código. Esse objetivo é alcançado porque os padrões capturam anos de experência em Engenharia de Software e fornecem soluções para definição da Arquitetura dos sistemas. Como o insumo desse conhecimento é a prática de vários profissionais, o resultado da utilização desses padrões costuma ser satisfatório se seguido da maneira correta.  Estrutura de um Padrão de Projeto  Existe uma lista de elementos comuns em um padrão de projeto:  Nome: Resume a proposta da soluçãoProblema: Resumo o objetivo a ser resolvidoContexto: Situações de aplicação idealSolução: Relacionamento entre as entidadesExemplo: Diagramas ilustrativos da solução  A capacidade de reutilização dos padrões de projeto é devida a duas características centras nas linguagens orientadas à objeto: composição e herança.  A composição é entendida como o reuso por delegação. Se um objeto não pode executar determinada tarefa (porque poderíamos ferir um princípio SOLID, por exemplo) ele delega essa função a outro objeto através da troca de mensagens. Desse modo podemos ter o reuso de funções entre objetos que não compartilham graus de hierarquia. Padrões com foco em composição são chamados de padrões de escopo de objeto.  A herança é uma abordagem que usa so vínculos entre subclasses e superclasses. Esse tipo de reuso costuma ser mais simples de implementar porque a lógica é mais natural e intuitiva, contudo, temos que tomar bastante cuidado para não violarmos os princípios da ocultação da informação nessa dinâmica entre classes derivadas e classes principais. Outro risco é a violação do LSP13. Padrões com foco na herança são chamados de padrões de escopo de classe.  Existe uma regra de bolso no mercado que é incorporada na frase &quot;favorecer composição sobre herança&quot;. Mesmo que o c# permita uma ampla flexibilidade nessas duas abordagens, as vezes é melhor abrir mão de funcionalidades disponíveis em favor de um maior controle de gestão das soluções desenvolvidas.  Tipos de Padrões  No livro da Gang of Four (1995) temos a classificação dos pradrões em 3 grandes grupos: Criacionais, Estruturais e Comportamentais.  Padrões Criacionais são padrões que focam na abstração do processo de criação de objetos. Costumam ser mais relacionados à inicialização e configuração de objetos. Alguns exemplos de padrões desse grupo são: Abstract Factory, Builder, Prototype, Singleton.  Padrões Estruturais tratam do desacoplamento entre interface e implmentação dos objetos. Estão mais relacionados à composição de objetos. Exemplos de padrões desse tipos são: Object Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.  Padrões Comportamentais são focados na definição de mecanismos de colaboração entre objetos. Mais relacionados à distribuição de responsabilidades e padronização de comunicações. Exemplos de padrões desse tipos são: Chain of Responsability, Comand Iterator, Mediator, Memento, Observer, State, Strategy, Visitor.  Comentário Essa parte final é só uma introdução geral aos conceitos de padrões de projeto. Existe um mundo a ser explorado nesse tópico mas agora estamos cientes da existência dele e já temos algumas referências iniciais para aprofundarmos o conhecimento.  ","version":"Next","tagName":"h3"},{"title":"Bibliografia​","type":1,"pageTitle":"Programação Modular","url":"/CC_site/docs/puc/segundo-periodo/programacao-modular#bibliografia","content":" MCGEE, Pat. C#: A Beginner's Guide. New York: McGraw-Hill Education, 2014 (O’Reilly Media).MARTIN, Robert C.; MARTIN, Micah; TORTELLO, João E. N. Princípios, padrões e práticas ágeis em C#. Porto Alegre: Bookman, 2011. E-book ISBN 9788577808427.GAMMA, Erich et al. Padrões de projeto: soluções reutilizáveis de software orientado a objetos. Porto Alegre: Bookman, 2000. E-book. ISBN 9788577800469.LISKOV, Barbara: Data abstraction and hierarchy, 1987.MARTIN, Robert C. Agile software development: principles, patterns, and practices. Upper Saddle River, NJ: Pearson Education. 2002. ISBN 9780135974445.    Footnotes​ Esse conceito é visto no estudo das funções matemáticas. ↩ Usaremos muitas vezes esse conceito ao longo dessa matéria. ↩ Uma das definições da palavra instância no contexto da ciência da computação é justamente &quot;um objeto cujo comportamento e estado são definidos por uma classe&quot;. ↩ Só prossiga quando essa frase tiver pleno sentido na sua mente. ↩ Que também podemos chamar de classe. ↩ Ou seja, atributo ou método da classe. ↩ Os manuais de qualidade de código ainda impõe um limite máximo de 100 linhas para essas implementações. Programador bom é programador que resolve o problema com poucas linhas de código. ↩ Ele vai funcionar parecido com o token de referência this, por exemplo, base.function(). ↩ Dai o nome paramétrico. ↩ Ou seja, se não possuem nenhum elemento em comum. ↩ A documentação desse tipo de lista pode ser lida aqui. ↩ Esse termo é MUITO comum em vários contextos além desse. Agora você tem o conhecimento para entender muitas outras relações complexas em várias linguagens de programação. ↩ Liskov Substitution Principle pois a classe derivada pode tentar sobrescrever uma propriedade da classe pai. ↩ ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}