{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"hljs.initHighlightingOnLoad(); Eu me chamo Bruno de Melo Ruas. Sou Economista pela Universidade do Estado do Amazonas (UEA). Especialista em Gest\u00e3o Financeira pela Funda\u00e7\u00e3o Get\u00falio Vargas (FGV). Atualmente curso o tecn\u00f3logo de An\u00e1lise e Desenvolvimento de Sistemas da Pontif\u00edcia Universidade Cat\u00f3lica de Minas Gerais (PUC-MG). Minhas Redes: Linkedin Twitter Github Eu tenho um m\u00e9todo de estudar: fingindo que estou dando aula . Ao longo dos anos, percebi que eu havia escrito tanto material, que poderia ajudar outras pessoas com meus textos. Esse site \u00e9 justamente o reposit\u00f3rio p\u00fablico dos conte\u00fados que venho estudando sobre Ci\u00eancia da Computa\u00e7\u00e3o seguindo duas fontes: O conte\u00fado da forma\u00e7\u00e3o em Tecn\u00f3logo em An\u00e1lise e Desenvolvimento de Sistemas pela PUC Minas Gerais . Os cursos da Open Source Society University - OSSU . Originalmente, eu escrevia minhas notas de estudos em LaTeX mas o eu percebi que Markdown era uma maneira mais simples de manter o projeto a medida que a quantidade de p\u00e1ginas foram se aproximando das centenas. Dessa feita, os reposit\u00f3rios antigos em pdf v\u00e3o ser todos migrados para esse projeto. Pontif\u00edcia Universidade Cat\u00f3lica (PUC-MG) O Tecn\u00f3logo foi iniciado em 2022/01 e deve terminar em 2024/2. Ao todo, o curso \u00e9 divido em 3 ciclos e 5 semestres (chamados de Eixos Tem\u00e1ticos). As mat\u00e9rias t\u00e9cnicas que ser\u00e3o estudas (e ter\u00e3o as minhas anota\u00e7\u00f5es salvas aqui) s\u00e3o essas. Ciclo 1: Concep\u00e7\u00e3o e Implementa\u00e7\u00e3o de Sistemas de Software Implementa\u00e7\u00e3o de Sistemas de Software Algoritmos e Abstra\u00e7\u00e3o de Dados Algoritmos e L\u00f3gica de Programa\u00e7\u00e3o Desenvolvimento Web Front-End Matem\u00e1tica B\u00e1sica Organiza\u00e7\u00e3o de Computadores Fundamentos de Engenharia de Sofware Pensamento Computacional L\u00f3gica Computacional Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Web Fron-End An\u00e1lise e Projeto de Sistemas de Software Algoritmos e Estruturas de Dados Modelagem de Dados Engenharia de Requisitos de Software Design de Intera\u00e7\u00e3o Programa\u00e7\u00e3o Modular Desenvolvimento Wb Back-End Fundamentos de Redes de Computadores Manipula\u00e7\u00e3o de Dados com SQL Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Interativa Ciclo 2: Desenvolvimento de Sistemas de Software Orientados a Processos de Neg\u00f3cios Processos de Neg\u00f3cio e de Desenvolvimento de Software Modelagem e Gest\u00e3o de Processos de Neg\u00f3cios Estat\u00edstica Descritiva Desenvolvimento de Aplica\u00e7\u00f5es M\u00f3veis Ger\u00eancia de Projetos de TI Ger\u00eancia de Configura\u00e7\u00e3o Qualidade de Processos de Software Ger\u00eancia de Requisitos de Software Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o M\u00f3vel Infraestrutura para Sistemas de Software Cloud Computing Projeto de Software Arquitetura de Software Distribu\u00eddo APIs e Web Services Teste de Software Banco de Dados NoSQL Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Distribu\u00edda Ciclo 3: Empreendedorismo e Inova\u00e7\u00e3o Empreendedorismo e Inova\u00e7\u00e3o com Sistemas de Software Seguran\u00e7a Aplicada ao Desenvolvimento Compliance em TI Implanta\u00e7\u00e3o de Solu\u00e7\u00e3o de TI Projeto: Desenvolvimento de um Sistema Sociot\u00e9cnico Inovador","title":"Bem Vindos"},{"location":"#pontificia-universidade-catolica-puc-mg","text":"O Tecn\u00f3logo foi iniciado em 2022/01 e deve terminar em 2024/2. Ao todo, o curso \u00e9 divido em 3 ciclos e 5 semestres (chamados de Eixos Tem\u00e1ticos). As mat\u00e9rias t\u00e9cnicas que ser\u00e3o estudas (e ter\u00e3o as minhas anota\u00e7\u00f5es salvas aqui) s\u00e3o essas. Ciclo 1: Concep\u00e7\u00e3o e Implementa\u00e7\u00e3o de Sistemas de Software Implementa\u00e7\u00e3o de Sistemas de Software Algoritmos e Abstra\u00e7\u00e3o de Dados Algoritmos e L\u00f3gica de Programa\u00e7\u00e3o Desenvolvimento Web Front-End Matem\u00e1tica B\u00e1sica Organiza\u00e7\u00e3o de Computadores Fundamentos de Engenharia de Sofware Pensamento Computacional L\u00f3gica Computacional Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Web Fron-End An\u00e1lise e Projeto de Sistemas de Software Algoritmos e Estruturas de Dados Modelagem de Dados Engenharia de Requisitos de Software Design de Intera\u00e7\u00e3o Programa\u00e7\u00e3o Modular Desenvolvimento Wb Back-End Fundamentos de Redes de Computadores Manipula\u00e7\u00e3o de Dados com SQL Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Interativa Ciclo 2: Desenvolvimento de Sistemas de Software Orientados a Processos de Neg\u00f3cios Processos de Neg\u00f3cio e de Desenvolvimento de Software Modelagem e Gest\u00e3o de Processos de Neg\u00f3cios Estat\u00edstica Descritiva Desenvolvimento de Aplica\u00e7\u00f5es M\u00f3veis Ger\u00eancia de Projetos de TI Ger\u00eancia de Configura\u00e7\u00e3o Qualidade de Processos de Software Ger\u00eancia de Requisitos de Software Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o M\u00f3vel Infraestrutura para Sistemas de Software Cloud Computing Projeto de Software Arquitetura de Software Distribu\u00eddo APIs e Web Services Teste de Software Banco de Dados NoSQL Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Distribu\u00edda Ciclo 3: Empreendedorismo e Inova\u00e7\u00e3o Empreendedorismo e Inova\u00e7\u00e3o com Sistemas de Software Seguran\u00e7a Aplicada ao Desenvolvimento Compliance em TI Implanta\u00e7\u00e3o de Solu\u00e7\u00e3o de TI Projeto: Desenvolvimento de um Sistema Sociot\u00e9cnico Inovador","title":"Pontif\u00edcia Universidade Cat\u00f3lica (PUC-MG)"},{"location":"nav/tech/","text":"Aqui eu coloco o conjunto de ferramentas que usei para construir esse portal. Links mkdocs para construir um repo local que pode ser facilmente convertido em um site. simple-blog theme para esse tema simplesmente maravilho. mkdocs-material para expandir algumas funcionalidades importantes do mkdocs. Tecnicamente, \u00e9 um outro tema, mas o material de refer\u00eancia deles \u00e9 \u00f3timo. markdown Extensions para expandir a capacidade do markdown no projeto. S\u00e9rio, existem muitas . github pages para hospedagem gratuita do site.","title":"Tech"},{"location":"nav/tech/#links","text":"mkdocs para construir um repo local que pode ser facilmente convertido em um site. simple-blog theme para esse tema simplesmente maravilho. mkdocs-material para expandir algumas funcionalidades importantes do mkdocs. Tecnicamente, \u00e9 um outro tema, mas o material de refer\u00eancia deles \u00e9 \u00f3timo. markdown Extensions para expandir a capacidade do markdown no projeto. S\u00e9rio, existem muitas . github pages para hospedagem gratuita do site.","title":"Links"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/","text":"hljs.initHighlightingOnLoad(); Introdu\u00e7\u00e3o Durante o processo de constru\u00e7\u00e3o de software, a manipula\u00e7\u00e3o de informa\u00e7\u00e3o em mem\u00f3ria \u00e9 tarefa fundamental para que a solu\u00e7\u00e3o de software seja \u00fatil e satisfat\u00f3ria. As linguagens de programa\u00e7\u00e3o possuem especifica\u00e7\u00f5es sobre as caracter\u00edsticas que cada grupo de vari\u00e1veis pode ter, esse controle de propriedade das vari\u00e1veis e das limita\u00e7\u00f5es relacionadas a cada tipo \u00e9 chamado de Tipo de Dado . Dizemos que um Tipo Abstrato de Dado (TAD) \u00e9 a defini\u00e7\u00e3o por parte do programador de uma nova classe de dado otimizada para a resolu\u00e7\u00e3o do problema a ser trabalhado com o software em desenvolvimento. Cont\u00e9m tanto a estrutura da informa\u00e7\u00e3o a ser trabalhada quanto as opera\u00e7\u00f5es, procedimentos e fun\u00e7\u00f5es que podem ser aplicadas a esse tipo de dado novo. A constru\u00e7\u00e3o de TADs passa pela identifica\u00e7\u00e3o das entidades de um problema computacional e a defini\u00e7\u00e3o e desenvolvimento do modelo de dados adequado para a solu\u00e7\u00e3o proposta. Primeiramente, vamos aprender sobre os tipos de dados normalmente existente nas linguagens de programa\u00e7\u00e3o mais comuns do mercado. Podemos dividir os tipos de dados em dois grandes grupos: Homog\u00eaneos e Heterog\u00eaneos. Coment\u00e1rio: Esse microfundamento deve ser estudado somente ap\u00f3s o microfundamento de Algoritmo e L\u00f3gica de Programa\u00e7\u00e3o . Como esse material \u00e9 de refer\u00eancia, ele n\u00e3o deve ser lido, necessariamente, como se fosse um livro. Estrutura de Dados Homog\u00eaneas e Heterog\u00eaneas Estrutura de Dados Homog\u00eaneas Os dois tipos de TAs Homog\u00eaneos mais comuns s\u00e3o os vetores (tamb\u00e9m chamados de arrays), que s\u00e3o formados por uma lista de \\(n\\) elementos de mesmo tipo e as matrizes, que podem ser entendidas como um empilhamento de vetores ou um tipo de vetor de duas dimens\u00f5es. Vetores \u00c9 uma vari\u00e1vel composta, homog\u00eanea e unidimensional. Podemos pensar em um vetor como uma lista com \\(n\\) elementos do mesmo tipo. Como todos os valores de um vetor possuem o mesmo nome (o nome da vari\u00e1vel), para acessarmos algum valor espec\u00edfico de um elemento, precisaremos de um \u00edndice que fa\u00e7a refer\u00eancia ao local na lista onde o valor desejado se encontra. Para criarmos um vetor em c#, usamos a declara\u00e7\u00e3o da vari\u00e1vel com um par de colchetes vazio e a defini\u00e7\u00e3o da quantidade de posi\u00e7\u00f5es (ou lugares) que o nosso vetor ter\u00e1. Abaixo podemos ver um exemplo disso. # c sharp int [] Idades = new int [ 100 ]; // Vetor de int com 100 places double [] Alt = new double [ 20 ]; // Vetor de double com 20 string [] Nomes = new string [ 10 ]; // Vetor de string com 10 No exemplo acima, podemos ver que criamos um vetor denominado Idades que receber\u00e1 apenas valores do tipo inteiro. Um vetor de doubles (que \u00e9 um float com mais casas de precis\u00e3o) chamado salario. E, por fim, um vetor de strings chamado Nomes. Coment\u00e1rio: Existe uma classe que permite a cria\u00e7\u00e3o de um tipo de vetor gen\u00e9rico sem tamanho definido em c# chamado Lista. O curso n\u00e3o entrou nesse assunto mas eu vou deixar esse exemplo de lista aqui. # c sharp using System.Collections.Generic ; List < int > lista = new List < int > (); List . add ( 1 ); List . add ( 2 ); List . remove ( 2 ); Agora que sabemos como criar um vetor. O pr\u00f3ximo passo \u00e9 aprendermos como inserir informa\u00e7\u00e3o nele. Para a nossa sorte, \u00e9 bem simples. Basta colocarmos o nome do vetor seguido da posi\u00e7\u00e3o a ser preenchida entre colchetes. # c sharp Idades [ 20 ] = 10 ; // Valor 10 na posi\u00e7\u00e3o 19 Alt [ 0 ] = 1.2 ; // Valor 1.2 na posi\u00e7\u00e3o 1 S\u00f3 temos que ter cuidado com uma coisa. Existem linguagens (como C#, Java, Python e outras) que colocam o index da primeira posi\u00e7\u00e3o de um vetor como sendo o valor 0. Outras linguagens (como R) usam o numero 1 para essa primeira posi\u00e7\u00e3o. Com base no que aprendemos em Algoritmos e L\u00f3gica da Programa\u00e7\u00e3o , somos capazes de entender o c\u00f3digo abaixo a respeito do uso de um la\u00e7o de repeti\u00e7\u00e3o para preenchimento de um vetor de 5 posi\u00e7\u00f5es. # c sharp int i ; int [] Valores = new int [ 5 ]; // Input dos dados for ( i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( $\"Digite o valor {i + 1}: \" ); Valores [ i ] = int . Parse ( Console . ReadLine ()); }; Desafio O professor prop\u00f5e o seguinte desafio para fixa\u00e7\u00e3o do conceito de vetor: \"Criaremos um vetor de n\u00fameros inteiros com 5 posi\u00e7\u00f5es e ler cada um de seus valores. Criaremos duas fun\u00e7\u00f5es que, tomando esse vetor como par\u00e2metro, ir\u00e3o retornar a soma dos n\u00fameros pares contidos no vetor e a quantidade de n\u00fameros \u00edmpares que ele possui.\" Minha resolu\u00e7\u00e3o desse problema segue abaixo. # c sharp int [] vetor = new int [ 5 ]; int somaPar = 0 ; int contaImpar = 0 ; int input ; // Soma de dois valores int soma ( int valor1 , int valor2 ) { return valor1 + valor2 ; }; // Itera\u00e7\u00e3o para lan\u00e7amento dos valores e somas for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( $\" Valor da Posi\u00e7\u00e3o n\u00ba: {i + 1}\" ); input = int . Parse ( Console . ReadLine ()); vetor [ i ] = input ; if ( input % 2 == 0 ) { somaPar = soma ( somaPar , input ); } else { contaImpar += 1 ; } }; Console . WriteLine ( $\" SomaPar = {somaPar}, ContaImpar = {contaImpar}\" ); Console . WriteLine ( $\"({vetor[0]},{vetor[1]},{vetor[2]},{ vetor[3]},{vetor[4]})\" ); Que produz o seguinte resultado para o input (1,2,1,2,1) . Matrizes Como dito no in\u00edcio dessa se\u00e7\u00e3o. Podemos pensar que matrizes s\u00e3o vetores de duas dimens\u00f5es. Por causa disso, a declara\u00e7\u00e3o da vari\u00e1vel \u00e9 um pouco diferente. # c sharp double [,] Notas = new double [ 4 , 5 ]; // 4 linhas e 5 colunas Por ser uma vari\u00e1vel de duas dimens\u00f5es, a maneira como atribu\u00edmos valores \u00e0 cada posi\u00e7\u00e3o \u00e9 um pouco diferente do caso com vetor. Para cada atribui\u00e7\u00e3o de valor, temos que indicar a linha e coluna que nosso dado ser\u00e1 salvo. # c sharp Notas [ 0 , 0 ] = 1 ; // Linha 1 coluna 1 Notas [ 0 , 1 ] = 1 ; // Linha 1 coluna 2 Notas [ 2 , 3 ] = 1 ; // Linha 3 coluna 4 Notas [ 3 , 4 ] = 1 ; // Linha 4 coluna 5 Devemos sempre lembrar que c# usa a posi\u00e7\u00e3o de numeral 0 para o index inicial de vetores e matrizes. Agora vamos ver um programa simples que exemplifica o que acabamos de aprender. A leitura dele n\u00e3o deve ser dif\u00edcil. Se est\u00e1 tendo dificuldade, volte no microfundamento de l\u00f3gica da programa\u00e7\u00e3o. # c sharp int i , j ; int [,] Valor = new int [ 10 , 3 ]; // Loop para entrada de valores na matriz for ( i = 0 ; i < 10 ; i ++ ) // Loop para linhas { for ( j = 0 ; j < 3 ; j ++ ) // Loop para colunas { Console . WriteLine ( $\"Valor Linha:{i+1} Coluna{j+1}\" ); Valor [ i , j ] = int . Parse ( Console . ReadLine ()); } } Desafio Para a fixa\u00e7\u00e3o do conceito de matrizes, o professor faz o seguinte desafio: \"Vamos fazer um programa que ir\u00e1 ler os dados de uma matriz de inteiros de ordem 5, ou seja, de dimens\u00f5es 5x5. Matematicamente ela \u00e9 chama de matriz quadrada, porque o n\u00famero de \u201clinhas\u201d \u00e9 igual ao n\u00famero de \u201ccolunas\u201d. Depois de darmos entrada nos valores da matriz chamaremos uma fun\u00e7\u00e3o que, tomando essa matriz como par\u00e2metro, retornar\u00e1 um vetor composto pelos elementos da diagonal principal dessa matriz quando, ent\u00e3o, os listaremos.\" # c sharp // Aqui vai ficar o cogido da solu\u00e7\u00e3o do desafio // quando eu tiver vontade de fazer Vetores e Matrizes s\u00e3o os principais tipos homog\u00eaneos de dados. A partir de agora, estudaremos estruturas que nos permitem alocar valores de tipos diferentes em uma mesma vari\u00e1vel. A compreens\u00e3o correta dos tipos de dados \u00e9 a pedra fundamental do paradigma de desenvolvimento chamado de Programa\u00e7\u00e3o Orientada \u00e0 Objetos . Estrutura de Dados Heterog\u00eaneas Registros Na defini\u00e7\u00e3o de um tipo de dado, n\u00f3s definimos precisamente a faixa de valores que podem ser atribu\u00eddos e os m\u00e9todos nativos do tipo de dado. Chamamos de tipo simples de dados os grupos de valores do mesmo tipo (inteiros, reais, string ou booleanos). Por outro lado, chamamos de tipo estruturado de dados os modelos que comportam valores de tipagem diferentes na mesma vari\u00e1vel. Um registro \u00e9 um tipo de dado estruturado. N\u00f3s j\u00e1 estamos familiarizados com as defini\u00e7\u00f5es de vari\u00e1veis em c# para os tipos nativos de dados. # c sharp int x ; double Result ; string Name ; A essa altura do aprendizado, as linhas acima s\u00e3o simples de serem compreendidas. S\u00e3o apenas declara\u00e7\u00f5es do tipos de 3 vari\u00e1veis simples. Mas vejam s\u00f3 o que podemos fazer abaixo. # c sharp Aluno xAlu ; Estranho, n\u00e9?! Estamos declarando a vari\u00e1vel xAlu como sendo do tipo...\"Aluno\"? Sim, \u00e9 isso mesmo! N\u00f3s podemos usar um token dedicado na linguagem para a cria\u00e7\u00e3o de tipos novos de dados que sirvam melhor para solu\u00e7\u00e3o dos problemas que queremos resolver como nosso c\u00f3digo. O token dedicado para constru\u00e7\u00e3o de tipos de dados em c# \u00e9 o struct . Mas para usa-lo bem, temos que aprender os conceitos de tipos de dados heterog\u00eaneos e, no futuro, avan\u00e7aremos para o conceito de classes. O comando struct \u00e9 pensado para o encapsulamento de pequenos conjuntos de vari\u00e1veis relacionadas. No exemplo do tipo Aluno, podemos pensar que todos os alunos devem ter um nome, um cpf e uma data de nascimento, por exemplo. Como essas caracter\u00edsticas se repetem para todos, podemos definir um tipo de dado espec\u00edfico para lidarmos com as informa\u00e7\u00f5es dos alunos. Implementa\u00e7\u00e3o de um Registro A cria\u00e7\u00e3o de um tipo de dado \u00e9 simples. Basta definirmos o nome do tipo de dado e declararmos o conjunto de vari\u00e1veis que far\u00e3o parte dele. No exemplo abaixo, n\u00f3s criamos o tipo \"Funcion\u00e1rio\" com as informa\u00e7\u00f5es que ser\u00e3o usadas. # c sharp struct Funcionario { public string CPF ; public string Name ; public double Salary ; public string dataNasc ; } Podemos ver que a declara\u00e7\u00e3o das vari\u00e1veis dentro do bloco de c\u00f3digo est\u00e3o com o token public antes da declara\u00e7\u00e3o do tipo de dado. Isso ocorre porque precisamos dizer ao compilador da linguagem que essas vari\u00e1veis ser\u00e3o acess\u00edveis fora do bloco de c\u00f3digo em que elas s\u00e3o criadas. Isso tem rela\u00e7\u00e3o direta com o conceito de m\u00e9todo e procedimento que aprendemos no curso de Algoritmo e L\u00f3gica Computacional. Agora que temos o nosso novo tipo de dado criado, podemos usar esse recurso para a defini\u00e7\u00e3o de novas vari\u00e1veis. # c sharp static void Main ( string []) args ) { Funcionario xFunc ; xFunc . CPF = \"1234\" ; xFunc . Name = \"Bruce Wanne\" ; xFunc . Salary = 1234 , 33 ; xFunc . dataNasc = \"31/08/1993\" ; } N\u00e3o precisamos nos preocupar com a primeira linha agora. Basta saber que todo programa em c# \u00e9 um procedimento em algum n\u00edvel. Podemos focar apenas no que est\u00e1 dentro dos colchetes. Com o tipo de dado criado. Podemos criar a vari\u00e1vel xFunc e acessar seus par\u00e2metros usando um ponto ap\u00f3s o seu nome. A atribui\u00e7\u00e3o \u00e9 feita como antes mas agora n\u00e3o precisamos declarar os tipos porque eles est\u00e3o definidos dentro do tipo de dado. J\u00e1 aprendemos no come\u00e7o desse microfundamento que a cria\u00e7\u00e3o de vetores (que s\u00e3o listas de elementos do mesmo tipo) s\u00e3o feitas em c# pela adi\u00e7\u00e3o de colchetes vazios na declara\u00e7\u00e3o das vari\u00e1veis. Por exemplo, um vetor de inteiros \u00e9 definido por int[] . Pois bem, podemos usar a mesma l\u00f3gica e criar um vetor do tipo que acabamos de criar 1 . Analogamente, como nosso tipo de dado \u00e9 Funcionario , seu vetor que conter\u00e1 v\u00e1rios funcion\u00e1rios diferentes ser\u00e1 criado por Funcionario[] . # c sharp Funcionario [] xFunc = new Funcionario [ 5 ]; for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( \"CPF do funcion\u00e1rio: \" ); xFunc [ i ]. CPF = Console . readLine (); Console . WriteLine ( \"Nome do funcion\u00e1rio: \" ); xFunc [ i ]. Name = Console . readLine (); Console . WriteLine ( \"Sal\u00e1rio: \" ); xFunc [ i ]. Salary = Console . readLine (); Console . WriteLine ( \"Data de Nascimento: \" ); xFunc [ i ]. dataNasc = Console . readLine (); } Acima, temos a cria\u00e7\u00e3o de um vetor de 5 posi\u00e7\u00f5es onde cada elemento \u00e9 do tipo Funcionario. Logo abaixo, temos um loop para facilitar o preenchimento das informa\u00e7\u00f5es de cada elemento do vetor. Estamos come\u00e7ando a nos aproximar do conceito de banco de dados. Mas n\u00e3o veremos isso agora. Tipos de Dados Aninhados N\u00e3o precisamos parar por aqui, \u00e9 plenamente poss\u00edvel criarmos um tipo de dados que use outro tipo de dados criado fora dele. Por exemplo, ao inv\u00e9s de salvarmos a data de nascimento como uma string, podemos criar um tipo de dados chamado Data que recebe 3 informa\u00e7\u00f5es: dia, m\u00eas e ano. # c sharp struct Funcionario { public string CPF ; public string Name ; public double Salary ; public Data dataNasc ; } struct Data { public string day ; public string month ; public string year ; } Dentro do tipo funcion\u00e1rio, temos a declara\u00e7\u00e3o de um vari\u00e1vel do tipo data. Para aproveitarmos o c\u00f3digo de cria\u00e7\u00e3o de um vetor Funcionario. Podemos fazer apenas uma pequena altera\u00e7\u00e3o. # c sharp Funcionario [] xFunc = new Funcionario [ 5 ]; for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( \"CPF do funcion\u00e1rio: \" ); xFunc [ i ]. CPF = Console . readLine (); Console . WriteLine ( \"Nome do funcion\u00e1rio: \" ); xFunc [ i ]. Name = Console . readLine (); // Parte que foi substitu\u00edda // Console.WriteLine(\"Sal\u00e1rio: \"); // xFunc[i].Salary = Console.readLine(); Console . WriteLine ( \"Data de Nascimento - Dia: \" ); xFunc [ i ]. dataNasc . day = Console . readLine (); Console . WriteLine ( \"Data de Nascimento - M\u00eas: \" ); xFunc [ i ]. dataNasc . month = Console . readLine (); Console . WriteLine ( \"Data de Nascimento - Ano: \" ); xFunc [ i ]. dataNasc . year = Console . readLine (); } A cria\u00e7\u00e3o de tipos eficientes de dados \u00e9 uma ferramenta muito eficiente para padroniza\u00e7\u00e3o e manuten\u00e7\u00e3o de solu\u00e7\u00f5es de software. \u00c9 sempre bom entendermos bem o problema proposto e quais tipos de dados podem ser criados para a cria\u00e7\u00e3o de uma resposta adequada a ele. TAD, Classes e Implementa\u00e7\u00e3o Defini\u00e7\u00e3o de um TAD - Classes e Objetos Um tipo abstrato de dado ou TAD \u00e9 um \"padr\u00e3o\" ou \"modelo\" que rege as caracter\u00edsticas que determinada estrutura de dado criada bem como suas fun\u00e7\u00f5es (que chamamos de m\u00e9todos) internas. Ou seja, um TAD \u00e9 a defini\u00e7\u00e3o das informa\u00e7\u00f5es contidas e as opera\u00e7\u00f5es execut\u00e1veis por uma vari\u00e1vel de um determinado modelo. N\u00f3s estamos usando isso o tempo todo sem perceber. Por exemplo, quando usamos a fun\u00e7\u00e3o Math.Pow(a,b) n\u00f3s estamos, na verdade, executando um m\u00e9todo chamamo Pow dentro do objeto Math . Exatamente o mesmo pensamento \u00e9 aplicado ao Console.Write() ou Console.ReadLine() . Agora que estamos avan\u00e7ando mais no nosso conhecimento sobre desenvolvimento de software, come\u00e7amos a entender mais sobre as estruturas que nos permitem realizar os nossos trabalhos, ou no jarg\u00e3o, estamos come\u00e7ando a ver \"de baixo do cap\u00f4\". At\u00e9 agora, n\u00f3s temos definido os nossos TADs atrav\u00e9s da defini\u00e7\u00e3o de sua estrutura (pelo token struct ), mas as linguagens que utilizam o paradigma orientado \u00e0 objeto atuais usam o conceito de classes para defini\u00e7\u00e3o dos seus TADs. Implementando TADs usando Classes J\u00e1 aprendemos a implementar um TAD por estrutura. # c sharp // Definindo o TAD struct Produto { public string Nome ; public double PrecoUnd ; } // Criando uma vari\u00e1vel com TAD Produto xProd ; // Usando o TAD xProd . Nome = \"PS5\" ; xProd . PrecoUnd = 8000.99 ; Podemos construir uma solu\u00e7\u00e3o an\u00e1loga a essa pelo token de cria\u00e7\u00e3o de classes. # c sharp // Definindo o TAD class Produto { public string Nome ; public double PrecoUnd ; } // Criando a classe Produto xProd = new Produto (); // Usando o TAD xProd . Nome = \"Xbox One\" ; xProd . PrecoUnd = 9999.99 ; Em uma primeira vista, parecem ser abordagens equivalentes. Mas existem algumas diferen\u00e7as importantes que merecem a nossa aten\u00e7\u00e3o. Para entender bem a diferen\u00e7a entre essas constru\u00e7\u00f5es, vamos ter que aprender um pouco mais sobre como o computador guarda informa\u00e7\u00f5es. O layout de mem\u00f3ria de programas em C s\u00e3o separados em 5 n\u00edveis : Text segment (instructions) Initializes data segment Uninitialized data segment (bss) Heap Stack (Inline) N\u00f3s n\u00e3o vamos nos atentar muito aos detalhes agora. Mas agora que sabemos um pouco das diferentes aloca\u00e7\u00f5es poss\u00edveis na mem\u00f3ria durante a execu\u00e7\u00e3o de um programa. Podemos focar no que for necess\u00e1rio para diferenciarmos o struct do class . Os valores do tipo struct s\u00e3o alocados na mem\u00f3ria stack. Essa parte de mem\u00f3ria grava temporariamente as vari\u00e1veis criadas por uma fun\u00e7\u00e3o. No stack, as vari\u00e1veis s\u00e3o declaras, guardadas e inicializadas durante a execu\u00e7\u00e3o do programa e apagadas na sua conclus\u00e3o. A mem\u00f3ria \u00e9 alocada em um bloco cont\u00edguos. \u00c9 mais limitada e de r\u00e1pido acesso. Os valores do tipo class s\u00e3o alocados no heap. Essa \u00e9 a parte da mem\u00f3ria usada pelas linguagens de programa\u00e7\u00e3o para suas vari\u00e1veis de escopo global. A mem\u00f3ria \u00e9 alocada de maneira aleat\u00f3ria e \u00e9 mais abundante se comparada com a stack. Sempre que criamos uma nova inst\u00e2ncia como fizemos em Produto xProd = new Produto() n\u00f3s estamos apontando um novo endere\u00e7o de mem\u00f3ria para ser usado. Desafio Cadastrar objetos em um vetor usando uma classe. # c sharp using System ; namespace WorkSpace { // Criando o TAD do tipo class class carro { public string name ; public string marca ; public string anoFab ; public string placa ; public double precoFip ; }; class Program { static void Main ( string [] args ) { // Criando um vetor do tipo carro carro [] cadCarro = new carro [ 3 ]; // Loop para inserir o input no vetor for ( int i = 0 ; i < 2 ; i ++ ) { carro x = new carro (); Console . Write ( $\"\\n Qual o nome? \" ); x . name = Console . ReadLine (); Console . Write ( $\" Qual a marca? \" ); x . marca = Console . ReadLine (); Console . Write ( $\" Qual o ano de fabrica\u00e7\u00e3o? \" ); x . anoFab = Console . ReadLine (); Console . Write ( $\" Qual a placa? \" ); x . placa = Console . ReadLine (); Console . Write ( $\" Qual o pre\u00e7o da tabela FIP? \" ); x . precoFip = double . Parse ( Console . ReadLine ()); // Salvando o x no vetor cadCarro cadCarro [ i ] = x ; }; Console . Clear (); // Mostrando o resultado foreach ( carro C in cadCarro ) { Console . WriteLine ( $\"\\n Carro: {C.name},Marca:{C.marca}\" ); Console . WriteLine ( $\" Placa: {C.placa}, Ano:{C.anoFab}\" ); Console . WriteLine ( $\" Pre\u00e7o da Tabela Fip: {C.precoFip}\" ); }; Console . ReadKey (); } } } \u00c9 muito mais comum se achar situa\u00e7\u00f5es de constru\u00e7\u00e3o de TADs por uso de classes ao inv\u00e9s de estruturas. Vale a pena estudar mais para sabermos exatamente quando cada uma dessas op\u00e7\u00f5es \u00e9 a adequada. Mas no come\u00e7o, as classes nos servir\u00e3o muito bem. Aqui \u00e9 importante frisarmos uma coisa. Quando instanciamos um objeto (ou seja, quando usamos o token new ) o nome que passamos a esse objeto \u00e9 apenas uma refer\u00eancia . Isso quer dizer que, no exemplo acima, cadCarro n\u00e3o \u00e9 o nosso objeto em si e sim uma refer\u00eancia a ele. Alguns de voc\u00eas podem estar questionando o motivo desse aviso. Sabendo que cadCarro n\u00e3o \u00e9 o objeto em si e sim apenas uma refer\u00eancia que aponta para o endere\u00e7o na mem\u00f3ria em que o objeto est\u00e1 salvo, ao criarmos uma nova linha no nosso c\u00f3digo do tipo cadCarro2 = cadCarro estamos criando uma nova refer\u00eancia para o mesmo objeto alocado na mem\u00f3ria. Ou seja, qualquer manipula\u00e7\u00e3o feita usando a refer\u00eancia cadCarro tamb\u00e9m ser\u00e1 refletida em cadCarro2 . Abaixo temos um programa simples que usa essa rela\u00e7\u00e3o de refer\u00eancia. # c sharp using System ; class Program { class carro { public string name ; public string marca ; public string anoFab ; public string placa ; public double precoFip ; }; public static void Main ( string [] args ) { // Criando um vetor do tipo carro carro cadCarro = new carro (); carro cadCarro2 = null ; cadCarro . name = \"carro Nome\" ; cadCarro . marca = \"marca\" ; cadCarro . anoFab = \"2022\" ; cadCarro . placa = \"placa\" ; cadCarro . precoFip = 22.22 ; Console . WriteLine ( $\"{cadCarro.name}\" ); cadCarro2 = cadCarro ; Console . WriteLine ( $\"{cadCarro2.name}\" ); cadCarro2 . name = \"carro nome 2\" ; Console . WriteLine ( $\"{cadCarro.name}\" ); } } Atributos, Propriedades e M\u00e9todos de Classe Vamos analisar com calma essas duas cita\u00e7\u00f5es do texto: \"Uma classe especifica uma estrutura de dados e os seus m\u00e9todos operacionais permiss\u00edveis que se aplicam a cada um dos seus objetos\" (MARTIN e ODELL, 1995). \"Um objeto \u00e9 qualquer coisa, real ou abstrata, a respeito da qual armazenamos os dados e os m\u00e9todos que os manipulam\" (MARTIN e ODELL, 1995). Em ambas as cita\u00e7\u00f5es temos as figuras dos dados e dos m\u00e9todos. A estrutura dos dados n\u00f3s j\u00e1 vimos na se\u00e7\u00e3o passada quando lidamos com defini\u00e7\u00e3o de TADs declarando os tipos das vari\u00e1veis tanto na declara\u00e7\u00e3o via estrutura quanto por classe. Agora, vamos expandir um pouco mais o poder dos TADs nos permitindo definir, al\u00e9m das regras de quais dados ser\u00e3o armazenados, quais opera\u00e7\u00f5es e fun\u00e7\u00f5es ser\u00e3o executadas internamente por nossos objetos. Ao construir um tipo abstrato de dados, nos perguntamos quais informa\u00e7\u00f5es ser\u00e3o necess\u00e1rias e, al\u00e9m disso, quais opera\u00e7\u00f5es ser\u00e3o usadas para resolu\u00e7\u00e3o do nosso problema. Indo um pouco mais fundo Vejamos o seguinte TAD criado apenas com a defini\u00e7\u00e3o da estrutura de dados: # c sharp class pessoa { public string name ; public double salary ; } Dizemos que as informa\u00e7\u00f5es sobre nome e sal\u00e1rio s\u00e3o atributos do nosso objeto pessoa . Eles definem a estrutura do tipo abstrato de dados que definimos. Tamb\u00e9m podemos chama-los de vari\u00e1veis da classe pessoa . Mesmo que o exemplo acima funcione. Uma maneira mais apropriada de reconstruir essa solu\u00e7\u00e3o pode ser vista abaixo. # c sharp class pessoa { private string _name ; public string name { get { return _name ;} set { _name = value ;} } private double _salary ; public double salary { get { return _salary ;} set { _salary = value ;} } } Os campos _name e _salary s\u00e3o definidos com o escopo privado e podem ser acessados somente internamente ao objeto. Para podermos acessar fora do escopo do objeto, usamos as fun\u00e7\u00f5es nativas get e set . Os nomes das fun\u00e7\u00f5es deixam claro o que cada uma faz. set \u00e9 usado para atribui\u00e7\u00e3o de um valor passado (que chamamos de value) e get \u00e9 usado para retorno de valor salvo no objeto. Vamos ver um programa simples que utiliza esses conceitos. # c sharp namespace WorkSpace { class pessoa { private string _name ; public string name { get { return _name ;} set { _name = value ;} } private double _salary ; public double salary { get { return _salary ;} set { _salary = value ;} } }; class Program { static void Main ( string [] args ) { pessoa xpes = new pessoa (); xpes . name = \"Clark Kent\" ; xpes . salary = 1234.56 ; Console . WriteLine ( $\"Nome: {xpes.name}\" ); Console . WriteLine ( $\"Sal\u00e1rio: R$ {xpes.salary}\" ); } } } Na linha xpes.name = \"Clark Kent\" vemos como a fun\u00e7\u00e3o interna set funciona. Ela recebe o valor e atribui \u00e0 vari\u00e1vel provada _name . Quando definimos um atributo privado e fun\u00e7\u00f5es ( get e set ) que manipulam esse atributo dentro da classe, podemos dizer que criamos uma propriedade do objeto. J\u00e1 temos os conceitos de objeto, atributo e propriedade bem definidos. Agora vamos aprender sobre as fun\u00e7\u00f5es dentro de um objeto. A essas fun\u00e7\u00f5es, damos o nome de m\u00e9todos ou servi\u00e7os do objeto . # c sharp class circulo { private double _raio ; public double raio { get { return _raio ; } set { _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Aqui temos um atributo chamado _raio . Uma propriedade chamada raio . E, por fim, temos tamb\u00e9m um m\u00e9todo chamado calcArea . Abaixo temos um exemplo de como usar esses conceitos na pr\u00e1tica. # c sharp namespace WorkSpace { class circulo { private double _raio ; public double raio { get { return _raio ; } set { _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } class Program { static void Main ( string [] args ) { double area ; circulo xcirculo = new circulo (); xcirculo . raio = 2.5 ; area = xcirculo . calcArea (); Console . WriteLine ( $\"A \u00e1rea \u00e9 igual a {area:F2}\" ); Console . ReadKey (); } } } Coment\u00e1rio: Eu n\u00e3o sei voc\u00ea, mas eu fiquei com d\u00favidas sobre essa parte do area:F2 . Isso \u00e9 muito simples. Como o valor area \u00e9 do tipo double, ele possui v\u00e1rias casas ap\u00f3s a v\u00edrgula. Esse par\u00e2metro \u00e9 a defini\u00e7\u00e3o da quantidade de casas ap\u00f3s a v\u00edrgula. Nesse caso, o resultado ter\u00e1 2 casas ap\u00f3s a v\u00edrgula. Quando encapsulamos as propriedades e os m\u00e9todos dentro de um objeto, estamos omitindo os detalhes de como objeto faz as transforma\u00e7\u00f5es e armazena os dados. A essa t\u00e9cnica damos o nome de oculta\u00e7\u00e3o da informa\u00e7\u00e3o . Isso \u00e9 \u00fatil para garantir a integridade da manipula\u00e7\u00e3o dos dados por parte dos usu\u00e1rios e aumenta a seguran\u00e7a quanto a l\u00f3gica implementada no c\u00f3digo. Podemos definir a l\u00f3gica tamb\u00e9m dentro das fun\u00e7\u00f5es de set e get . # c sharp namespace WorkSpace { class circulo { private double _raio ; public double raio { get { return _raio ; } set { if ( value < 0 ) _raio = 0 ; else _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } class Program { static void Main ( string [] args ) { double area ; circulo xcir = new circulo (); xcir . raio = - 2.5 ; area = xcir . calcArea (); Console . WriteLine ( $\"Area: {area:F2}\" ); } } } Desse modo, podemos ver que caso o valor inputado no raio for negativo, o resultado da \u00e1rea ser\u00e1 0. Caso for positivo, o valor da \u00e1rea ser\u00e1 calculado normalmente. Se import\u00e1ssemos esse objeto sem saber o que acontece por dentro dele, n\u00e3o entender\u00edamos o que acontece exatamente dentro do objeto circulo . Mecanismos de Visibilidade/Acessibilidade Os modificadores de acesso ou mecanismos de visibilidade s\u00e3o os m\u00e9todos de acesso \u00e0s classes e seus, atributos, propriedades e m\u00e9todos. Existem v\u00e1rios tipos de modificadores de acesso ( protected , internal , protected internal e etc), mas por agora, vamos estudar somente o public e o private . Observemos novamente o c\u00f3digo da \u00faltima se\u00e7\u00e3o com algumas anota\u00e7\u00f5es adicionais. # c sharp // Bloco contendo todo o programa namespace WorkSpace { // Defini\u00e7\u00e3o do TAD circulo class circulo { private double _raio ; public double raio { get { return _raio ; } set { if ( value < 0 ) _raio = 0 ; else _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } // Bloco contendo o programa class Program { // Procedimento do programa static void Main ( string [] args ) { double area ; circulo xcir = new circulo (); xcir . raio = - 2.5 ; area = xcir . calcArea (); Console . WriteLine ( $\"Area: {area:F2}\" ); } } } Podemos ver que a classe circulo \u00e9 criada antes do bloco que cont\u00e9m o programa propriamente dito. Ou seja, est\u00e3o em escopos diferentes. Desse modo, um comando contido no procedimento Main n\u00e3o tem acesso a nenhuma propriedade ou atributos com o par\u00e2metro private nele somente os de par\u00e2metro public ou atrav\u00e9s das fun\u00e7\u00f5es set e get . Aten\u00e7\u00e3o: Na cria\u00e7\u00e3o da classe circulo n\u00e3o foi dito se ela seria acess\u00edvel fora do seu escopo original, ou seja, n\u00e3o usamos o comando public class circulo e sim o comando class circulo . Em c#, quando se cria uma classe sem a defini\u00e7\u00e3o expl\u00edcita da sua visibilidade, o padr\u00e3o da linguagem \u00e9 deixar a classe como public . Qualidade e Robustez de Software Esses conceitos de controle de acesso s\u00e3o importantes porque nosso c\u00f3digo precisa fazer o que foi planejado, da maneira planejada. Quando n\u00e3o limitamos a capacidade do usu\u00e1rio inserir dados, podemos cair em situa\u00e7\u00f5es n\u00e3o previstas que podem comprometer a execu\u00e7\u00e3o do nosso programa. Um conceito que nos ajuda a entender melhor essa situa\u00e7\u00e3o \u00e9 o robustez do software . Esse conceito \u00e9 usado pelos profissionais de qualidade de software e que \u00e9 referente a capacidade do programa em funcionar da maneira correta em diferentes cen\u00e1rios e condi\u00e7\u00f5es adversas. Outro conceito \u00fatil dessa \u00e1rea \u00e9 o corre\u00e7\u00e3o de software que \u00e9 a qualidade referente a capacidade do nosso programa funcionar da maneira prevista e especificada. A t\u00e9cnica da omiss\u00e3o da informa\u00e7\u00e3o nos ajuda a garantir o cumprimento desses requisitos. Construtores e Destrutores de Classe Um construtor de classe \u00e9 usado para cria\u00e7\u00e3o de um objeto e pela inicializa\u00e7\u00e3o dos seus atributos. Sempre que instanciamos um objeto, o seu construtor entra em a\u00e7\u00e3o. Coment\u00e1rio: N\u00e3o entraremos a fundo no conceito de Common Language Runtime (CLR) agora. Talvez mais pra frente a gente veja isso. Se um construtor n\u00e3o for declarado explicitamente, o c# cria a classe usando algumas conven\u00e7\u00f5es de modo a colocar o objeto dispon\u00edvel para uso. Esses padr\u00f5es de construtores s\u00e3o definidos de acordo com o tipo primitivo das vari\u00e1veis contidas no nosso objeto (que sabemos que se chamam atributos). Por padr\u00e3o, o CLR atribui os seguintes valores para os atributos dos objetos: 0 para vari\u00e1veis do tipo int, double e float false para vari\u00e1veis booleanas '\\0' para vari\u00e1veis do tipo string Definindo Construtores Para n\u00e3o usarmos as conven\u00e7\u00f5es padr\u00e3o do CLR. Podemos, n\u00f3s mesmo, atribuir os construtores dos atributos dos nossos objetos. Para isso, usamos um m\u00e9todo (ou seja, uma fun\u00e7\u00e3o interna do objeto) com o mesmo nome do objeto . Esse m\u00e9todo n\u00e3o possui retorno e s\u00e3o declarados como public . # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor { _raio = 0 ; } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } A partir de agora, sempre que executarmos um instanciamento atrav\u00e9s do comando # c sharp circulo xcir = new circulo (); O construtor ser\u00e1 chamado e executar\u00e1 as instru\u00e7\u00f5es contidas no construtor. No caso de exemplo, o valor default para o atributo _raio ser\u00e1 0. N\u00e3o \u00e9 dif\u00edcil pensar em situa\u00e7\u00f5es onde precisar\u00edamos usar diferentes m\u00e9todos de constru\u00e7\u00e3o em um objeto. Para isso, podemos ter mais de um construtor no mesmo objeto, chamamos isso de sobrecarregamento . A condi\u00e7\u00e3o \u00e9 que esses construtores sejam diferentes em termos de par\u00e2metros ou ordem dos par\u00e2metros. # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor { _raio = 0 ; } public circulo ( int R ) { _raio = R ; } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Para executar o segundo construtor, basta passarmos um par\u00e2metro no momento do instanciamento do nosso novo objeto. # c sharp circulo xcirc = new circulo ( 2.3 ); Como fizemos um instanciamento com valor, o c# saber\u00e1 que queremos usar o segundo construtor ao inv\u00e9s do primeiro. Destrutores Ao contr\u00e1rio do que podemos pensar pelo nome, os destrutores n\u00e3o s\u00e3o usados para \"destruir\" os objetos. Eles s\u00e3o usados definir um comportamento espec\u00edfico no momento da destrui\u00e7\u00e3o de um objeto. Ou seja, eles s\u00e3o acionados na destrui\u00e7\u00e3o e n\u00e3o s\u00e3o os destruidores. N\u00e3o precisam ser chamados ou referenciados pois s\u00e3o invocados automaticamente. O normal \u00e9 n\u00e3o se usar destrutores no dia a dia visto que o CLR j\u00e1 faz o trabalho de padroniza\u00e7\u00e3o para elimina\u00e7\u00e3o de um objeto. Diferente dos construtores, uma classe pode ter apenas um destrutor . E a sua cria\u00e7\u00e3o \u00e9 parecida com a do construtor, uma vez que s\u00e3o m\u00e9todos sem retorno. A \u00fanica diferen\u00e7a \u00e9 que sua nota\u00e7\u00e3o come\u00e7a com o til. # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor 1 { _raio = 0 ; } public circulo ( int R ) // construtor 2 { _raio = R ; } ~ circulo { Console . WriteLine ( \"Adeus, mundo cruel!\" ); } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Os detalhes de como um computador funciona s\u00e3o estudados em Estrutura de Computadores mas, para adiantar, algumas linguagens tem um programa chamado garbage colector que \u00e9 respons\u00e1vel pela reutiliza\u00e7\u00e3o de slots de mem\u00f3ria que est\u00e3o sendo usados por objetos que n\u00e3o tem mais utiliza\u00e7\u00e3o no c\u00f3digo. Em c# n\u00f3s n\u00e3o precisamos explicitamente eliminar um objeto porque o pr\u00f3prio garbage colector faz esse trabalho. Bibliografia ASCENCIO, Ana Fernanda Gomes; CAMPOS, Edilene Aparecida Veneruchi de. Fundamentos da programa\u00e7\u00e3o de computadores . S\u00e3o Paulo: Pearson, 2012. ISBN 9788564574168 SOUZA, Marco A. Furlan de; GOMES, Marcelo Marques; SOARES, Marcio Vieira; CONC\u00cdLIO, Ricardo. Algoritmos e l\u00f3gica de programa\u00e7\u00e3o: um texto introdut\u00f3rio para a engenharia . S\u00e3o Paulo: Cengage Learning, 2019. ISBN: 9788522128150 AGUILAR, Luis Joyanes. Fundamentos de programa\u00e7\u00e3o algoritmos, estruturas de dados e objetos . 3. ed. Porto Alegre: AMGH, 2008. ISBN: 9788580550146 DEITEL, Harvey M; DEITEL, Paul J. Java - como programar . 8. ed. S\u00e3o Paulo: Pearson, 2010. ISBN 9788576055631 GRIFFITHS, Ian. Programming C# 8.0 . O'Reilly Media, Inc. 2019. ISBN 9781492056812 MANZANO, Jos\u00e9 Augusto N. G; OLIVEIRA, Jayr Figueiredo de. Algoritmos: l\u00f3gica para desenvolvimento de programa\u00e7\u00e3o de computadores . 28. ed. rev. e atual. S\u00e3o Paulo, SP: \u00c9rica, 2016. E-book. ISBN 9788536518657 PRICE, Mark J. C# 8.0 and .NET Core 3.0 - Modern Cross - Platform Development . O'Reilly Media; 2019. ISBN 9781788478120 PUGA, Sandra; RISSETTI, Gerson. L\u00f3gica de programa\u00e7\u00e3o e estruturas de dados com aplica\u00e7\u00f5es em Java . 2. ed. S\u00e3o Paulo: Prentice Hall, 2009. ISBN 9788576052074 Isso \u00e9 muito legal! \u21a9","title":"Algoritmo e Abstra\u00e7\u00e3o"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#introducao","text":"Durante o processo de constru\u00e7\u00e3o de software, a manipula\u00e7\u00e3o de informa\u00e7\u00e3o em mem\u00f3ria \u00e9 tarefa fundamental para que a solu\u00e7\u00e3o de software seja \u00fatil e satisfat\u00f3ria. As linguagens de programa\u00e7\u00e3o possuem especifica\u00e7\u00f5es sobre as caracter\u00edsticas que cada grupo de vari\u00e1veis pode ter, esse controle de propriedade das vari\u00e1veis e das limita\u00e7\u00f5es relacionadas a cada tipo \u00e9 chamado de Tipo de Dado . Dizemos que um Tipo Abstrato de Dado (TAD) \u00e9 a defini\u00e7\u00e3o por parte do programador de uma nova classe de dado otimizada para a resolu\u00e7\u00e3o do problema a ser trabalhado com o software em desenvolvimento. Cont\u00e9m tanto a estrutura da informa\u00e7\u00e3o a ser trabalhada quanto as opera\u00e7\u00f5es, procedimentos e fun\u00e7\u00f5es que podem ser aplicadas a esse tipo de dado novo. A constru\u00e7\u00e3o de TADs passa pela identifica\u00e7\u00e3o das entidades de um problema computacional e a defini\u00e7\u00e3o e desenvolvimento do modelo de dados adequado para a solu\u00e7\u00e3o proposta. Primeiramente, vamos aprender sobre os tipos de dados normalmente existente nas linguagens de programa\u00e7\u00e3o mais comuns do mercado. Podemos dividir os tipos de dados em dois grandes grupos: Homog\u00eaneos e Heterog\u00eaneos. Coment\u00e1rio: Esse microfundamento deve ser estudado somente ap\u00f3s o microfundamento de Algoritmo e L\u00f3gica de Programa\u00e7\u00e3o . Como esse material \u00e9 de refer\u00eancia, ele n\u00e3o deve ser lido, necessariamente, como se fosse um livro.","title":"Introdu\u00e7\u00e3o"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#estrutura-de-dados-homogeneas-e-heterogeneas","text":"","title":"Estrutura de Dados Homog\u00eaneas e Heterog\u00eaneas"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#estrutura-de-dados-homogeneas","text":"Os dois tipos de TAs Homog\u00eaneos mais comuns s\u00e3o os vetores (tamb\u00e9m chamados de arrays), que s\u00e3o formados por uma lista de \\(n\\) elementos de mesmo tipo e as matrizes, que podem ser entendidas como um empilhamento de vetores ou um tipo de vetor de duas dimens\u00f5es.","title":"Estrutura de Dados Homog\u00eaneas"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#vetores","text":"\u00c9 uma vari\u00e1vel composta, homog\u00eanea e unidimensional. Podemos pensar em um vetor como uma lista com \\(n\\) elementos do mesmo tipo. Como todos os valores de um vetor possuem o mesmo nome (o nome da vari\u00e1vel), para acessarmos algum valor espec\u00edfico de um elemento, precisaremos de um \u00edndice que fa\u00e7a refer\u00eancia ao local na lista onde o valor desejado se encontra. Para criarmos um vetor em c#, usamos a declara\u00e7\u00e3o da vari\u00e1vel com um par de colchetes vazio e a defini\u00e7\u00e3o da quantidade de posi\u00e7\u00f5es (ou lugares) que o nosso vetor ter\u00e1. Abaixo podemos ver um exemplo disso. # c sharp int [] Idades = new int [ 100 ]; // Vetor de int com 100 places double [] Alt = new double [ 20 ]; // Vetor de double com 20 string [] Nomes = new string [ 10 ]; // Vetor de string com 10 No exemplo acima, podemos ver que criamos um vetor denominado Idades que receber\u00e1 apenas valores do tipo inteiro. Um vetor de doubles (que \u00e9 um float com mais casas de precis\u00e3o) chamado salario. E, por fim, um vetor de strings chamado Nomes. Coment\u00e1rio: Existe uma classe que permite a cria\u00e7\u00e3o de um tipo de vetor gen\u00e9rico sem tamanho definido em c# chamado Lista. O curso n\u00e3o entrou nesse assunto mas eu vou deixar esse exemplo de lista aqui. # c sharp using System.Collections.Generic ; List < int > lista = new List < int > (); List . add ( 1 ); List . add ( 2 ); List . remove ( 2 ); Agora que sabemos como criar um vetor. O pr\u00f3ximo passo \u00e9 aprendermos como inserir informa\u00e7\u00e3o nele. Para a nossa sorte, \u00e9 bem simples. Basta colocarmos o nome do vetor seguido da posi\u00e7\u00e3o a ser preenchida entre colchetes. # c sharp Idades [ 20 ] = 10 ; // Valor 10 na posi\u00e7\u00e3o 19 Alt [ 0 ] = 1.2 ; // Valor 1.2 na posi\u00e7\u00e3o 1 S\u00f3 temos que ter cuidado com uma coisa. Existem linguagens (como C#, Java, Python e outras) que colocam o index da primeira posi\u00e7\u00e3o de um vetor como sendo o valor 0. Outras linguagens (como R) usam o numero 1 para essa primeira posi\u00e7\u00e3o. Com base no que aprendemos em Algoritmos e L\u00f3gica da Programa\u00e7\u00e3o , somos capazes de entender o c\u00f3digo abaixo a respeito do uso de um la\u00e7o de repeti\u00e7\u00e3o para preenchimento de um vetor de 5 posi\u00e7\u00f5es. # c sharp int i ; int [] Valores = new int [ 5 ]; // Input dos dados for ( i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( $\"Digite o valor {i + 1}: \" ); Valores [ i ] = int . Parse ( Console . ReadLine ()); };","title":"Vetores"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#desafio","text":"O professor prop\u00f5e o seguinte desafio para fixa\u00e7\u00e3o do conceito de vetor: \"Criaremos um vetor de n\u00fameros inteiros com 5 posi\u00e7\u00f5es e ler cada um de seus valores. Criaremos duas fun\u00e7\u00f5es que, tomando esse vetor como par\u00e2metro, ir\u00e3o retornar a soma dos n\u00fameros pares contidos no vetor e a quantidade de n\u00fameros \u00edmpares que ele possui.\" Minha resolu\u00e7\u00e3o desse problema segue abaixo. # c sharp int [] vetor = new int [ 5 ]; int somaPar = 0 ; int contaImpar = 0 ; int input ; // Soma de dois valores int soma ( int valor1 , int valor2 ) { return valor1 + valor2 ; }; // Itera\u00e7\u00e3o para lan\u00e7amento dos valores e somas for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( $\" Valor da Posi\u00e7\u00e3o n\u00ba: {i + 1}\" ); input = int . Parse ( Console . ReadLine ()); vetor [ i ] = input ; if ( input % 2 == 0 ) { somaPar = soma ( somaPar , input ); } else { contaImpar += 1 ; } }; Console . WriteLine ( $\" SomaPar = {somaPar}, ContaImpar = {contaImpar}\" ); Console . WriteLine ( $\"({vetor[0]},{vetor[1]},{vetor[2]},{ vetor[3]},{vetor[4]})\" ); Que produz o seguinte resultado para o input (1,2,1,2,1) .","title":"Desafio"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#matrizes","text":"Como dito no in\u00edcio dessa se\u00e7\u00e3o. Podemos pensar que matrizes s\u00e3o vetores de duas dimens\u00f5es. Por causa disso, a declara\u00e7\u00e3o da vari\u00e1vel \u00e9 um pouco diferente. # c sharp double [,] Notas = new double [ 4 , 5 ]; // 4 linhas e 5 colunas Por ser uma vari\u00e1vel de duas dimens\u00f5es, a maneira como atribu\u00edmos valores \u00e0 cada posi\u00e7\u00e3o \u00e9 um pouco diferente do caso com vetor. Para cada atribui\u00e7\u00e3o de valor, temos que indicar a linha e coluna que nosso dado ser\u00e1 salvo. # c sharp Notas [ 0 , 0 ] = 1 ; // Linha 1 coluna 1 Notas [ 0 , 1 ] = 1 ; // Linha 1 coluna 2 Notas [ 2 , 3 ] = 1 ; // Linha 3 coluna 4 Notas [ 3 , 4 ] = 1 ; // Linha 4 coluna 5 Devemos sempre lembrar que c# usa a posi\u00e7\u00e3o de numeral 0 para o index inicial de vetores e matrizes. Agora vamos ver um programa simples que exemplifica o que acabamos de aprender. A leitura dele n\u00e3o deve ser dif\u00edcil. Se est\u00e1 tendo dificuldade, volte no microfundamento de l\u00f3gica da programa\u00e7\u00e3o. # c sharp int i , j ; int [,] Valor = new int [ 10 , 3 ]; // Loop para entrada de valores na matriz for ( i = 0 ; i < 10 ; i ++ ) // Loop para linhas { for ( j = 0 ; j < 3 ; j ++ ) // Loop para colunas { Console . WriteLine ( $\"Valor Linha:{i+1} Coluna{j+1}\" ); Valor [ i , j ] = int . Parse ( Console . ReadLine ()); } }","title":"Matrizes"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#desafio_1","text":"Para a fixa\u00e7\u00e3o do conceito de matrizes, o professor faz o seguinte desafio: \"Vamos fazer um programa que ir\u00e1 ler os dados de uma matriz de inteiros de ordem 5, ou seja, de dimens\u00f5es 5x5. Matematicamente ela \u00e9 chama de matriz quadrada, porque o n\u00famero de \u201clinhas\u201d \u00e9 igual ao n\u00famero de \u201ccolunas\u201d. Depois de darmos entrada nos valores da matriz chamaremos uma fun\u00e7\u00e3o que, tomando essa matriz como par\u00e2metro, retornar\u00e1 um vetor composto pelos elementos da diagonal principal dessa matriz quando, ent\u00e3o, os listaremos.\" # c sharp // Aqui vai ficar o cogido da solu\u00e7\u00e3o do desafio // quando eu tiver vontade de fazer Vetores e Matrizes s\u00e3o os principais tipos homog\u00eaneos de dados. A partir de agora, estudaremos estruturas que nos permitem alocar valores de tipos diferentes em uma mesma vari\u00e1vel. A compreens\u00e3o correta dos tipos de dados \u00e9 a pedra fundamental do paradigma de desenvolvimento chamado de Programa\u00e7\u00e3o Orientada \u00e0 Objetos .","title":"Desafio"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#estrutura-de-dados-heterogeneas","text":"","title":"Estrutura de Dados Heterog\u00eaneas"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#registros","text":"Na defini\u00e7\u00e3o de um tipo de dado, n\u00f3s definimos precisamente a faixa de valores que podem ser atribu\u00eddos e os m\u00e9todos nativos do tipo de dado. Chamamos de tipo simples de dados os grupos de valores do mesmo tipo (inteiros, reais, string ou booleanos). Por outro lado, chamamos de tipo estruturado de dados os modelos que comportam valores de tipagem diferentes na mesma vari\u00e1vel. Um registro \u00e9 um tipo de dado estruturado. N\u00f3s j\u00e1 estamos familiarizados com as defini\u00e7\u00f5es de vari\u00e1veis em c# para os tipos nativos de dados. # c sharp int x ; double Result ; string Name ; A essa altura do aprendizado, as linhas acima s\u00e3o simples de serem compreendidas. S\u00e3o apenas declara\u00e7\u00f5es do tipos de 3 vari\u00e1veis simples. Mas vejam s\u00f3 o que podemos fazer abaixo. # c sharp Aluno xAlu ; Estranho, n\u00e9?! Estamos declarando a vari\u00e1vel xAlu como sendo do tipo...\"Aluno\"? Sim, \u00e9 isso mesmo! N\u00f3s podemos usar um token dedicado na linguagem para a cria\u00e7\u00e3o de tipos novos de dados que sirvam melhor para solu\u00e7\u00e3o dos problemas que queremos resolver como nosso c\u00f3digo. O token dedicado para constru\u00e7\u00e3o de tipos de dados em c# \u00e9 o struct . Mas para usa-lo bem, temos que aprender os conceitos de tipos de dados heterog\u00eaneos e, no futuro, avan\u00e7aremos para o conceito de classes. O comando struct \u00e9 pensado para o encapsulamento de pequenos conjuntos de vari\u00e1veis relacionadas. No exemplo do tipo Aluno, podemos pensar que todos os alunos devem ter um nome, um cpf e uma data de nascimento, por exemplo. Como essas caracter\u00edsticas se repetem para todos, podemos definir um tipo de dado espec\u00edfico para lidarmos com as informa\u00e7\u00f5es dos alunos.","title":"Registros"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#implementacao-de-um-registro","text":"A cria\u00e7\u00e3o de um tipo de dado \u00e9 simples. Basta definirmos o nome do tipo de dado e declararmos o conjunto de vari\u00e1veis que far\u00e3o parte dele. No exemplo abaixo, n\u00f3s criamos o tipo \"Funcion\u00e1rio\" com as informa\u00e7\u00f5es que ser\u00e3o usadas. # c sharp struct Funcionario { public string CPF ; public string Name ; public double Salary ; public string dataNasc ; } Podemos ver que a declara\u00e7\u00e3o das vari\u00e1veis dentro do bloco de c\u00f3digo est\u00e3o com o token public antes da declara\u00e7\u00e3o do tipo de dado. Isso ocorre porque precisamos dizer ao compilador da linguagem que essas vari\u00e1veis ser\u00e3o acess\u00edveis fora do bloco de c\u00f3digo em que elas s\u00e3o criadas. Isso tem rela\u00e7\u00e3o direta com o conceito de m\u00e9todo e procedimento que aprendemos no curso de Algoritmo e L\u00f3gica Computacional. Agora que temos o nosso novo tipo de dado criado, podemos usar esse recurso para a defini\u00e7\u00e3o de novas vari\u00e1veis. # c sharp static void Main ( string []) args ) { Funcionario xFunc ; xFunc . CPF = \"1234\" ; xFunc . Name = \"Bruce Wanne\" ; xFunc . Salary = 1234 , 33 ; xFunc . dataNasc = \"31/08/1993\" ; } N\u00e3o precisamos nos preocupar com a primeira linha agora. Basta saber que todo programa em c# \u00e9 um procedimento em algum n\u00edvel. Podemos focar apenas no que est\u00e1 dentro dos colchetes. Com o tipo de dado criado. Podemos criar a vari\u00e1vel xFunc e acessar seus par\u00e2metros usando um ponto ap\u00f3s o seu nome. A atribui\u00e7\u00e3o \u00e9 feita como antes mas agora n\u00e3o precisamos declarar os tipos porque eles est\u00e3o definidos dentro do tipo de dado. J\u00e1 aprendemos no come\u00e7o desse microfundamento que a cria\u00e7\u00e3o de vetores (que s\u00e3o listas de elementos do mesmo tipo) s\u00e3o feitas em c# pela adi\u00e7\u00e3o de colchetes vazios na declara\u00e7\u00e3o das vari\u00e1veis. Por exemplo, um vetor de inteiros \u00e9 definido por int[] . Pois bem, podemos usar a mesma l\u00f3gica e criar um vetor do tipo que acabamos de criar 1 . Analogamente, como nosso tipo de dado \u00e9 Funcionario , seu vetor que conter\u00e1 v\u00e1rios funcion\u00e1rios diferentes ser\u00e1 criado por Funcionario[] . # c sharp Funcionario [] xFunc = new Funcionario [ 5 ]; for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( \"CPF do funcion\u00e1rio: \" ); xFunc [ i ]. CPF = Console . readLine (); Console . WriteLine ( \"Nome do funcion\u00e1rio: \" ); xFunc [ i ]. Name = Console . readLine (); Console . WriteLine ( \"Sal\u00e1rio: \" ); xFunc [ i ]. Salary = Console . readLine (); Console . WriteLine ( \"Data de Nascimento: \" ); xFunc [ i ]. dataNasc = Console . readLine (); } Acima, temos a cria\u00e7\u00e3o de um vetor de 5 posi\u00e7\u00f5es onde cada elemento \u00e9 do tipo Funcionario. Logo abaixo, temos um loop para facilitar o preenchimento das informa\u00e7\u00f5es de cada elemento do vetor. Estamos come\u00e7ando a nos aproximar do conceito de banco de dados. Mas n\u00e3o veremos isso agora.","title":"Implementa\u00e7\u00e3o de um Registro"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#tipos-de-dados-aninhados","text":"N\u00e3o precisamos parar por aqui, \u00e9 plenamente poss\u00edvel criarmos um tipo de dados que use outro tipo de dados criado fora dele. Por exemplo, ao inv\u00e9s de salvarmos a data de nascimento como uma string, podemos criar um tipo de dados chamado Data que recebe 3 informa\u00e7\u00f5es: dia, m\u00eas e ano. # c sharp struct Funcionario { public string CPF ; public string Name ; public double Salary ; public Data dataNasc ; } struct Data { public string day ; public string month ; public string year ; } Dentro do tipo funcion\u00e1rio, temos a declara\u00e7\u00e3o de um vari\u00e1vel do tipo data. Para aproveitarmos o c\u00f3digo de cria\u00e7\u00e3o de um vetor Funcionario. Podemos fazer apenas uma pequena altera\u00e7\u00e3o. # c sharp Funcionario [] xFunc = new Funcionario [ 5 ]; for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( \"CPF do funcion\u00e1rio: \" ); xFunc [ i ]. CPF = Console . readLine (); Console . WriteLine ( \"Nome do funcion\u00e1rio: \" ); xFunc [ i ]. Name = Console . readLine (); // Parte que foi substitu\u00edda // Console.WriteLine(\"Sal\u00e1rio: \"); // xFunc[i].Salary = Console.readLine(); Console . WriteLine ( \"Data de Nascimento - Dia: \" ); xFunc [ i ]. dataNasc . day = Console . readLine (); Console . WriteLine ( \"Data de Nascimento - M\u00eas: \" ); xFunc [ i ]. dataNasc . month = Console . readLine (); Console . WriteLine ( \"Data de Nascimento - Ano: \" ); xFunc [ i ]. dataNasc . year = Console . readLine (); } A cria\u00e7\u00e3o de tipos eficientes de dados \u00e9 uma ferramenta muito eficiente para padroniza\u00e7\u00e3o e manuten\u00e7\u00e3o de solu\u00e7\u00f5es de software. \u00c9 sempre bom entendermos bem o problema proposto e quais tipos de dados podem ser criados para a cria\u00e7\u00e3o de uma resposta adequada a ele.","title":"Tipos de Dados Aninhados"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#tad-classes-e-implementacao","text":"","title":"TAD, Classes e Implementa\u00e7\u00e3o"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#definicao-de-um-tad-classes-e-objetos","text":"Um tipo abstrato de dado ou TAD \u00e9 um \"padr\u00e3o\" ou \"modelo\" que rege as caracter\u00edsticas que determinada estrutura de dado criada bem como suas fun\u00e7\u00f5es (que chamamos de m\u00e9todos) internas. Ou seja, um TAD \u00e9 a defini\u00e7\u00e3o das informa\u00e7\u00f5es contidas e as opera\u00e7\u00f5es execut\u00e1veis por uma vari\u00e1vel de um determinado modelo. N\u00f3s estamos usando isso o tempo todo sem perceber. Por exemplo, quando usamos a fun\u00e7\u00e3o Math.Pow(a,b) n\u00f3s estamos, na verdade, executando um m\u00e9todo chamamo Pow dentro do objeto Math . Exatamente o mesmo pensamento \u00e9 aplicado ao Console.Write() ou Console.ReadLine() . Agora que estamos avan\u00e7ando mais no nosso conhecimento sobre desenvolvimento de software, come\u00e7amos a entender mais sobre as estruturas que nos permitem realizar os nossos trabalhos, ou no jarg\u00e3o, estamos come\u00e7ando a ver \"de baixo do cap\u00f4\". At\u00e9 agora, n\u00f3s temos definido os nossos TADs atrav\u00e9s da defini\u00e7\u00e3o de sua estrutura (pelo token struct ), mas as linguagens que utilizam o paradigma orientado \u00e0 objeto atuais usam o conceito de classes para defini\u00e7\u00e3o dos seus TADs.","title":"Defini\u00e7\u00e3o de um TAD - Classes e Objetos"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#implementando-tads-usando-classes","text":"J\u00e1 aprendemos a implementar um TAD por estrutura. # c sharp // Definindo o TAD struct Produto { public string Nome ; public double PrecoUnd ; } // Criando uma vari\u00e1vel com TAD Produto xProd ; // Usando o TAD xProd . Nome = \"PS5\" ; xProd . PrecoUnd = 8000.99 ; Podemos construir uma solu\u00e7\u00e3o an\u00e1loga a essa pelo token de cria\u00e7\u00e3o de classes. # c sharp // Definindo o TAD class Produto { public string Nome ; public double PrecoUnd ; } // Criando a classe Produto xProd = new Produto (); // Usando o TAD xProd . Nome = \"Xbox One\" ; xProd . PrecoUnd = 9999.99 ; Em uma primeira vista, parecem ser abordagens equivalentes. Mas existem algumas diferen\u00e7as importantes que merecem a nossa aten\u00e7\u00e3o. Para entender bem a diferen\u00e7a entre essas constru\u00e7\u00f5es, vamos ter que aprender um pouco mais sobre como o computador guarda informa\u00e7\u00f5es. O layout de mem\u00f3ria de programas em C s\u00e3o separados em 5 n\u00edveis : Text segment (instructions) Initializes data segment Uninitialized data segment (bss) Heap Stack (Inline) N\u00f3s n\u00e3o vamos nos atentar muito aos detalhes agora. Mas agora que sabemos um pouco das diferentes aloca\u00e7\u00f5es poss\u00edveis na mem\u00f3ria durante a execu\u00e7\u00e3o de um programa. Podemos focar no que for necess\u00e1rio para diferenciarmos o struct do class . Os valores do tipo struct s\u00e3o alocados na mem\u00f3ria stack. Essa parte de mem\u00f3ria grava temporariamente as vari\u00e1veis criadas por uma fun\u00e7\u00e3o. No stack, as vari\u00e1veis s\u00e3o declaras, guardadas e inicializadas durante a execu\u00e7\u00e3o do programa e apagadas na sua conclus\u00e3o. A mem\u00f3ria \u00e9 alocada em um bloco cont\u00edguos. \u00c9 mais limitada e de r\u00e1pido acesso. Os valores do tipo class s\u00e3o alocados no heap. Essa \u00e9 a parte da mem\u00f3ria usada pelas linguagens de programa\u00e7\u00e3o para suas vari\u00e1veis de escopo global. A mem\u00f3ria \u00e9 alocada de maneira aleat\u00f3ria e \u00e9 mais abundante se comparada com a stack. Sempre que criamos uma nova inst\u00e2ncia como fizemos em Produto xProd = new Produto() n\u00f3s estamos apontando um novo endere\u00e7o de mem\u00f3ria para ser usado.","title":"Implementando TADs usando Classes"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#desafio_2","text":"Cadastrar objetos em um vetor usando uma classe. # c sharp using System ; namespace WorkSpace { // Criando o TAD do tipo class class carro { public string name ; public string marca ; public string anoFab ; public string placa ; public double precoFip ; }; class Program { static void Main ( string [] args ) { // Criando um vetor do tipo carro carro [] cadCarro = new carro [ 3 ]; // Loop para inserir o input no vetor for ( int i = 0 ; i < 2 ; i ++ ) { carro x = new carro (); Console . Write ( $\"\\n Qual o nome? \" ); x . name = Console . ReadLine (); Console . Write ( $\" Qual a marca? \" ); x . marca = Console . ReadLine (); Console . Write ( $\" Qual o ano de fabrica\u00e7\u00e3o? \" ); x . anoFab = Console . ReadLine (); Console . Write ( $\" Qual a placa? \" ); x . placa = Console . ReadLine (); Console . Write ( $\" Qual o pre\u00e7o da tabela FIP? \" ); x . precoFip = double . Parse ( Console . ReadLine ()); // Salvando o x no vetor cadCarro cadCarro [ i ] = x ; }; Console . Clear (); // Mostrando o resultado foreach ( carro C in cadCarro ) { Console . WriteLine ( $\"\\n Carro: {C.name},Marca:{C.marca}\" ); Console . WriteLine ( $\" Placa: {C.placa}, Ano:{C.anoFab}\" ); Console . WriteLine ( $\" Pre\u00e7o da Tabela Fip: {C.precoFip}\" ); }; Console . ReadKey (); } } } \u00c9 muito mais comum se achar situa\u00e7\u00f5es de constru\u00e7\u00e3o de TADs por uso de classes ao inv\u00e9s de estruturas. Vale a pena estudar mais para sabermos exatamente quando cada uma dessas op\u00e7\u00f5es \u00e9 a adequada. Mas no come\u00e7o, as classes nos servir\u00e3o muito bem. Aqui \u00e9 importante frisarmos uma coisa. Quando instanciamos um objeto (ou seja, quando usamos o token new ) o nome que passamos a esse objeto \u00e9 apenas uma refer\u00eancia . Isso quer dizer que, no exemplo acima, cadCarro n\u00e3o \u00e9 o nosso objeto em si e sim uma refer\u00eancia a ele. Alguns de voc\u00eas podem estar questionando o motivo desse aviso. Sabendo que cadCarro n\u00e3o \u00e9 o objeto em si e sim apenas uma refer\u00eancia que aponta para o endere\u00e7o na mem\u00f3ria em que o objeto est\u00e1 salvo, ao criarmos uma nova linha no nosso c\u00f3digo do tipo cadCarro2 = cadCarro estamos criando uma nova refer\u00eancia para o mesmo objeto alocado na mem\u00f3ria. Ou seja, qualquer manipula\u00e7\u00e3o feita usando a refer\u00eancia cadCarro tamb\u00e9m ser\u00e1 refletida em cadCarro2 . Abaixo temos um programa simples que usa essa rela\u00e7\u00e3o de refer\u00eancia. # c sharp using System ; class Program { class carro { public string name ; public string marca ; public string anoFab ; public string placa ; public double precoFip ; }; public static void Main ( string [] args ) { // Criando um vetor do tipo carro carro cadCarro = new carro (); carro cadCarro2 = null ; cadCarro . name = \"carro Nome\" ; cadCarro . marca = \"marca\" ; cadCarro . anoFab = \"2022\" ; cadCarro . placa = \"placa\" ; cadCarro . precoFip = 22.22 ; Console . WriteLine ( $\"{cadCarro.name}\" ); cadCarro2 = cadCarro ; Console . WriteLine ( $\"{cadCarro2.name}\" ); cadCarro2 . name = \"carro nome 2\" ; Console . WriteLine ( $\"{cadCarro.name}\" ); } }","title":"Desafio"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#atributos-propriedades-e-metodos-de-classe","text":"Vamos analisar com calma essas duas cita\u00e7\u00f5es do texto: \"Uma classe especifica uma estrutura de dados e os seus m\u00e9todos operacionais permiss\u00edveis que se aplicam a cada um dos seus objetos\" (MARTIN e ODELL, 1995). \"Um objeto \u00e9 qualquer coisa, real ou abstrata, a respeito da qual armazenamos os dados e os m\u00e9todos que os manipulam\" (MARTIN e ODELL, 1995). Em ambas as cita\u00e7\u00f5es temos as figuras dos dados e dos m\u00e9todos. A estrutura dos dados n\u00f3s j\u00e1 vimos na se\u00e7\u00e3o passada quando lidamos com defini\u00e7\u00e3o de TADs declarando os tipos das vari\u00e1veis tanto na declara\u00e7\u00e3o via estrutura quanto por classe. Agora, vamos expandir um pouco mais o poder dos TADs nos permitindo definir, al\u00e9m das regras de quais dados ser\u00e3o armazenados, quais opera\u00e7\u00f5es e fun\u00e7\u00f5es ser\u00e3o executadas internamente por nossos objetos. Ao construir um tipo abstrato de dados, nos perguntamos quais informa\u00e7\u00f5es ser\u00e3o necess\u00e1rias e, al\u00e9m disso, quais opera\u00e7\u00f5es ser\u00e3o usadas para resolu\u00e7\u00e3o do nosso problema.","title":"Atributos, Propriedades e M\u00e9todos de Classe"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#indo-um-pouco-mais-fundo","text":"Vejamos o seguinte TAD criado apenas com a defini\u00e7\u00e3o da estrutura de dados: # c sharp class pessoa { public string name ; public double salary ; } Dizemos que as informa\u00e7\u00f5es sobre nome e sal\u00e1rio s\u00e3o atributos do nosso objeto pessoa . Eles definem a estrutura do tipo abstrato de dados que definimos. Tamb\u00e9m podemos chama-los de vari\u00e1veis da classe pessoa . Mesmo que o exemplo acima funcione. Uma maneira mais apropriada de reconstruir essa solu\u00e7\u00e3o pode ser vista abaixo. # c sharp class pessoa { private string _name ; public string name { get { return _name ;} set { _name = value ;} } private double _salary ; public double salary { get { return _salary ;} set { _salary = value ;} } } Os campos _name e _salary s\u00e3o definidos com o escopo privado e podem ser acessados somente internamente ao objeto. Para podermos acessar fora do escopo do objeto, usamos as fun\u00e7\u00f5es nativas get e set . Os nomes das fun\u00e7\u00f5es deixam claro o que cada uma faz. set \u00e9 usado para atribui\u00e7\u00e3o de um valor passado (que chamamos de value) e get \u00e9 usado para retorno de valor salvo no objeto. Vamos ver um programa simples que utiliza esses conceitos. # c sharp namespace WorkSpace { class pessoa { private string _name ; public string name { get { return _name ;} set { _name = value ;} } private double _salary ; public double salary { get { return _salary ;} set { _salary = value ;} } }; class Program { static void Main ( string [] args ) { pessoa xpes = new pessoa (); xpes . name = \"Clark Kent\" ; xpes . salary = 1234.56 ; Console . WriteLine ( $\"Nome: {xpes.name}\" ); Console . WriteLine ( $\"Sal\u00e1rio: R$ {xpes.salary}\" ); } } } Na linha xpes.name = \"Clark Kent\" vemos como a fun\u00e7\u00e3o interna set funciona. Ela recebe o valor e atribui \u00e0 vari\u00e1vel provada _name . Quando definimos um atributo privado e fun\u00e7\u00f5es ( get e set ) que manipulam esse atributo dentro da classe, podemos dizer que criamos uma propriedade do objeto. J\u00e1 temos os conceitos de objeto, atributo e propriedade bem definidos. Agora vamos aprender sobre as fun\u00e7\u00f5es dentro de um objeto. A essas fun\u00e7\u00f5es, damos o nome de m\u00e9todos ou servi\u00e7os do objeto . # c sharp class circulo { private double _raio ; public double raio { get { return _raio ; } set { _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Aqui temos um atributo chamado _raio . Uma propriedade chamada raio . E, por fim, temos tamb\u00e9m um m\u00e9todo chamado calcArea . Abaixo temos um exemplo de como usar esses conceitos na pr\u00e1tica. # c sharp namespace WorkSpace { class circulo { private double _raio ; public double raio { get { return _raio ; } set { _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } class Program { static void Main ( string [] args ) { double area ; circulo xcirculo = new circulo (); xcirculo . raio = 2.5 ; area = xcirculo . calcArea (); Console . WriteLine ( $\"A \u00e1rea \u00e9 igual a {area:F2}\" ); Console . ReadKey (); } } } Coment\u00e1rio: Eu n\u00e3o sei voc\u00ea, mas eu fiquei com d\u00favidas sobre essa parte do area:F2 . Isso \u00e9 muito simples. Como o valor area \u00e9 do tipo double, ele possui v\u00e1rias casas ap\u00f3s a v\u00edrgula. Esse par\u00e2metro \u00e9 a defini\u00e7\u00e3o da quantidade de casas ap\u00f3s a v\u00edrgula. Nesse caso, o resultado ter\u00e1 2 casas ap\u00f3s a v\u00edrgula. Quando encapsulamos as propriedades e os m\u00e9todos dentro de um objeto, estamos omitindo os detalhes de como objeto faz as transforma\u00e7\u00f5es e armazena os dados. A essa t\u00e9cnica damos o nome de oculta\u00e7\u00e3o da informa\u00e7\u00e3o . Isso \u00e9 \u00fatil para garantir a integridade da manipula\u00e7\u00e3o dos dados por parte dos usu\u00e1rios e aumenta a seguran\u00e7a quanto a l\u00f3gica implementada no c\u00f3digo. Podemos definir a l\u00f3gica tamb\u00e9m dentro das fun\u00e7\u00f5es de set e get . # c sharp namespace WorkSpace { class circulo { private double _raio ; public double raio { get { return _raio ; } set { if ( value < 0 ) _raio = 0 ; else _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } class Program { static void Main ( string [] args ) { double area ; circulo xcir = new circulo (); xcir . raio = - 2.5 ; area = xcir . calcArea (); Console . WriteLine ( $\"Area: {area:F2}\" ); } } } Desse modo, podemos ver que caso o valor inputado no raio for negativo, o resultado da \u00e1rea ser\u00e1 0. Caso for positivo, o valor da \u00e1rea ser\u00e1 calculado normalmente. Se import\u00e1ssemos esse objeto sem saber o que acontece por dentro dele, n\u00e3o entender\u00edamos o que acontece exatamente dentro do objeto circulo .","title":"Indo um pouco mais fundo"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#mecanismos-de-visibilidadeacessibilidade","text":"Os modificadores de acesso ou mecanismos de visibilidade s\u00e3o os m\u00e9todos de acesso \u00e0s classes e seus, atributos, propriedades e m\u00e9todos. Existem v\u00e1rios tipos de modificadores de acesso ( protected , internal , protected internal e etc), mas por agora, vamos estudar somente o public e o private . Observemos novamente o c\u00f3digo da \u00faltima se\u00e7\u00e3o com algumas anota\u00e7\u00f5es adicionais. # c sharp // Bloco contendo todo o programa namespace WorkSpace { // Defini\u00e7\u00e3o do TAD circulo class circulo { private double _raio ; public double raio { get { return _raio ; } set { if ( value < 0 ) _raio = 0 ; else _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } // Bloco contendo o programa class Program { // Procedimento do programa static void Main ( string [] args ) { double area ; circulo xcir = new circulo (); xcir . raio = - 2.5 ; area = xcir . calcArea (); Console . WriteLine ( $\"Area: {area:F2}\" ); } } } Podemos ver que a classe circulo \u00e9 criada antes do bloco que cont\u00e9m o programa propriamente dito. Ou seja, est\u00e3o em escopos diferentes. Desse modo, um comando contido no procedimento Main n\u00e3o tem acesso a nenhuma propriedade ou atributos com o par\u00e2metro private nele somente os de par\u00e2metro public ou atrav\u00e9s das fun\u00e7\u00f5es set e get . Aten\u00e7\u00e3o: Na cria\u00e7\u00e3o da classe circulo n\u00e3o foi dito se ela seria acess\u00edvel fora do seu escopo original, ou seja, n\u00e3o usamos o comando public class circulo e sim o comando class circulo . Em c#, quando se cria uma classe sem a defini\u00e7\u00e3o expl\u00edcita da sua visibilidade, o padr\u00e3o da linguagem \u00e9 deixar a classe como public .","title":"Mecanismos de Visibilidade/Acessibilidade"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#qualidade-e-robustez-de-software","text":"Esses conceitos de controle de acesso s\u00e3o importantes porque nosso c\u00f3digo precisa fazer o que foi planejado, da maneira planejada. Quando n\u00e3o limitamos a capacidade do usu\u00e1rio inserir dados, podemos cair em situa\u00e7\u00f5es n\u00e3o previstas que podem comprometer a execu\u00e7\u00e3o do nosso programa. Um conceito que nos ajuda a entender melhor essa situa\u00e7\u00e3o \u00e9 o robustez do software . Esse conceito \u00e9 usado pelos profissionais de qualidade de software e que \u00e9 referente a capacidade do programa em funcionar da maneira correta em diferentes cen\u00e1rios e condi\u00e7\u00f5es adversas. Outro conceito \u00fatil dessa \u00e1rea \u00e9 o corre\u00e7\u00e3o de software que \u00e9 a qualidade referente a capacidade do nosso programa funcionar da maneira prevista e especificada. A t\u00e9cnica da omiss\u00e3o da informa\u00e7\u00e3o nos ajuda a garantir o cumprimento desses requisitos.","title":"Qualidade e Robustez de Software"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#construtores-e-destrutores-de-classe","text":"Um construtor de classe \u00e9 usado para cria\u00e7\u00e3o de um objeto e pela inicializa\u00e7\u00e3o dos seus atributos. Sempre que instanciamos um objeto, o seu construtor entra em a\u00e7\u00e3o. Coment\u00e1rio: N\u00e3o entraremos a fundo no conceito de Common Language Runtime (CLR) agora. Talvez mais pra frente a gente veja isso. Se um construtor n\u00e3o for declarado explicitamente, o c# cria a classe usando algumas conven\u00e7\u00f5es de modo a colocar o objeto dispon\u00edvel para uso. Esses padr\u00f5es de construtores s\u00e3o definidos de acordo com o tipo primitivo das vari\u00e1veis contidas no nosso objeto (que sabemos que se chamam atributos). Por padr\u00e3o, o CLR atribui os seguintes valores para os atributos dos objetos: 0 para vari\u00e1veis do tipo int, double e float false para vari\u00e1veis booleanas '\\0' para vari\u00e1veis do tipo string","title":"Construtores e Destrutores de Classe"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#definindo-construtores","text":"Para n\u00e3o usarmos as conven\u00e7\u00f5es padr\u00e3o do CLR. Podemos, n\u00f3s mesmo, atribuir os construtores dos atributos dos nossos objetos. Para isso, usamos um m\u00e9todo (ou seja, uma fun\u00e7\u00e3o interna do objeto) com o mesmo nome do objeto . Esse m\u00e9todo n\u00e3o possui retorno e s\u00e3o declarados como public . # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor { _raio = 0 ; } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } A partir de agora, sempre que executarmos um instanciamento atrav\u00e9s do comando # c sharp circulo xcir = new circulo (); O construtor ser\u00e1 chamado e executar\u00e1 as instru\u00e7\u00f5es contidas no construtor. No caso de exemplo, o valor default para o atributo _raio ser\u00e1 0. N\u00e3o \u00e9 dif\u00edcil pensar em situa\u00e7\u00f5es onde precisar\u00edamos usar diferentes m\u00e9todos de constru\u00e7\u00e3o em um objeto. Para isso, podemos ter mais de um construtor no mesmo objeto, chamamos isso de sobrecarregamento . A condi\u00e7\u00e3o \u00e9 que esses construtores sejam diferentes em termos de par\u00e2metros ou ordem dos par\u00e2metros. # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor { _raio = 0 ; } public circulo ( int R ) { _raio = R ; } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Para executar o segundo construtor, basta passarmos um par\u00e2metro no momento do instanciamento do nosso novo objeto. # c sharp circulo xcirc = new circulo ( 2.3 ); Como fizemos um instanciamento com valor, o c# saber\u00e1 que queremos usar o segundo construtor ao inv\u00e9s do primeiro.","title":"Definindo Construtores"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#destrutores","text":"Ao contr\u00e1rio do que podemos pensar pelo nome, os destrutores n\u00e3o s\u00e3o usados para \"destruir\" os objetos. Eles s\u00e3o usados definir um comportamento espec\u00edfico no momento da destrui\u00e7\u00e3o de um objeto. Ou seja, eles s\u00e3o acionados na destrui\u00e7\u00e3o e n\u00e3o s\u00e3o os destruidores. N\u00e3o precisam ser chamados ou referenciados pois s\u00e3o invocados automaticamente. O normal \u00e9 n\u00e3o se usar destrutores no dia a dia visto que o CLR j\u00e1 faz o trabalho de padroniza\u00e7\u00e3o para elimina\u00e7\u00e3o de um objeto. Diferente dos construtores, uma classe pode ter apenas um destrutor . E a sua cria\u00e7\u00e3o \u00e9 parecida com a do construtor, uma vez que s\u00e3o m\u00e9todos sem retorno. A \u00fanica diferen\u00e7a \u00e9 que sua nota\u00e7\u00e3o come\u00e7a com o til. # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor 1 { _raio = 0 ; } public circulo ( int R ) // construtor 2 { _raio = R ; } ~ circulo { Console . WriteLine ( \"Adeus, mundo cruel!\" ); } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Os detalhes de como um computador funciona s\u00e3o estudados em Estrutura de Computadores mas, para adiantar, algumas linguagens tem um programa chamado garbage colector que \u00e9 respons\u00e1vel pela reutiliza\u00e7\u00e3o de slots de mem\u00f3ria que est\u00e3o sendo usados por objetos que n\u00e3o tem mais utiliza\u00e7\u00e3o no c\u00f3digo. Em c# n\u00f3s n\u00e3o precisamos explicitamente eliminar um objeto porque o pr\u00f3prio garbage colector faz esse trabalho.","title":"Destrutores"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#bibliografia","text":"ASCENCIO, Ana Fernanda Gomes; CAMPOS, Edilene Aparecida Veneruchi de. Fundamentos da programa\u00e7\u00e3o de computadores . S\u00e3o Paulo: Pearson, 2012. ISBN 9788564574168 SOUZA, Marco A. Furlan de; GOMES, Marcelo Marques; SOARES, Marcio Vieira; CONC\u00cdLIO, Ricardo. Algoritmos e l\u00f3gica de programa\u00e7\u00e3o: um texto introdut\u00f3rio para a engenharia . S\u00e3o Paulo: Cengage Learning, 2019. ISBN: 9788522128150 AGUILAR, Luis Joyanes. Fundamentos de programa\u00e7\u00e3o algoritmos, estruturas de dados e objetos . 3. ed. Porto Alegre: AMGH, 2008. ISBN: 9788580550146 DEITEL, Harvey M; DEITEL, Paul J. Java - como programar . 8. ed. S\u00e3o Paulo: Pearson, 2010. ISBN 9788576055631 GRIFFITHS, Ian. Programming C# 8.0 . O'Reilly Media, Inc. 2019. ISBN 9781492056812 MANZANO, Jos\u00e9 Augusto N. G; OLIVEIRA, Jayr Figueiredo de. Algoritmos: l\u00f3gica para desenvolvimento de programa\u00e7\u00e3o de computadores . 28. ed. rev. e atual. S\u00e3o Paulo, SP: \u00c9rica, 2016. E-book. ISBN 9788536518657 PRICE, Mark J. C# 8.0 and .NET Core 3.0 - Modern Cross - Platform Development . O'Reilly Media; 2019. ISBN 9781788478120 PUGA, Sandra; RISSETTI, Gerson. L\u00f3gica de programa\u00e7\u00e3o e estruturas de dados com aplica\u00e7\u00f5es em Java . 2. ed. S\u00e3o Paulo: Prentice Hall, 2009. ISBN 9788576052074 Isso \u00e9 muito legal! \u21a9","title":"Bibliografia"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/","text":"hljs.initHighlightingOnLoad();","title":"Algoritmo e L\u00f3gica"},{"location":"nav/PUC/eixo1/desenvolvimento_web/","text":"hljs.initHighlightingOnLoad();","title":"Desenvolvimento Web Frontend"},{"location":"nav/PUC/eixo1/fundamentos_eng_soft/","text":"hljs.initHighlightingOnLoad();","title":"Fundamentos de Eng. de Software"},{"location":"nav/PUC/eixo1/logica_comp/","text":"hljs.initHighlightingOnLoad();","title":"L\u00f3gica Computacional"},{"location":"nav/PUC/eixo1/matematica_basica/","text":"hljs.initHighlightingOnLoad();","title":"Matem\u00e1tica B\u00e1sica"},{"location":"nav/PUC/eixo1/organizacao_computadores/","text":"hljs.initHighlightingOnLoad();","title":"Organiza\u00e7\u00e3o de Computadores"},{"location":"nav/PUC/eixo1/pensamento_comp/","text":"hljs.initHighlightingOnLoad();","title":"Pensamento Computacional"},{"location":"nav/PUC/eixo1/projeto_dev_web_frontend/","text":"hljs.initHighlightingOnLoad();","title":"Projeto 1 - Web Fron-End"},{"location":"nav/setup/colors/","text":"January 17, 2023 Changing the colors Color scheme Default: light theme: theme_style: light light dark Primary color Default: black theme: colors: primary: black black blue green yellow orange purple red white Text color Default: black theme: colors: text: black black blue green yellow orange purple red white Title color Default: black theme: colors: title: black black blue green yellow orange purple red white Background color Default: white theme: colors: background: white black blue green yellow orange purple red white","title":"Colors"},{"location":"nav/setup/colors/#changing-the-colors","text":"","title":"Changing the colors"},{"location":"nav/setup/colors/#color-scheme","text":"Default: light theme: theme_style: light light dark","title":"Color scheme"},{"location":"nav/setup/colors/#primary-color","text":"Default: black theme: colors: primary: black black blue green yellow orange purple red white","title":"Primary color"},{"location":"nav/setup/colors/#text-color","text":"Default: black theme: colors: text: black black blue green yellow orange purple red white","title":"Text color"},{"location":"nav/setup/colors/#title-color","text":"Default: black theme: colors: title: black black blue green yellow orange purple red white","title":"Title color"},{"location":"nav/setup/colors/#background-color","text":"Default: white theme: colors: background: white black blue green yellow orange purple red white","title":"Background color"},{"location":"nav/setup/components/","text":"January 21, 2023 Enable and Disable Components Site Name Default: true theme: components: site_name: true true false Title Default: true theme: components: title: true true false Menu Default: true theme: components: menu: true true false Preview Default: true theme: components: preview: true true false Footer Default: true theme: components: footer: true true false","title":"Components"},{"location":"nav/setup/components/#enable-and-disable-components","text":"","title":"Enable and Disable Components"},{"location":"nav/setup/components/#site-name","text":"Default: true theme: components: site_name: true true false","title":"Site Name"},{"location":"nav/setup/components/#title","text":"Default: true theme: components: title: true true false","title":"Title"},{"location":"nav/setup/components/#menu","text":"Default: true theme: components: menu: true true false","title":"Menu"},{"location":"nav/setup/components/#preview","text":"Default: true theme: components: preview: true true false","title":"Preview"},{"location":"nav/setup/components/#footer","text":"Default: true theme: components: footer: true true false","title":"Footer"},{"location":"nav/setup/favicon/","text":"January 17, 2023 Changing the favicon theme: favicon: assets/favicon.ico","title":"Favicon"},{"location":"nav/setup/favicon/#changing-the-favicon","text":"theme: favicon: assets/favicon.ico","title":"Changing the favicon"},{"location":"nav/setup/fonts/","text":"January 17, 2023 Changing the fonts Site name style Default: normal theme: site_name_style: normal normal bold italic scratched underline overline Title style Default: bold theme: title_style: bold normal bold italic scratched underline overline","title":"Fonts"},{"location":"nav/setup/fonts/#changing-the-fonts","text":"","title":"Changing the fonts"},{"location":"nav/setup/fonts/#site-name-style","text":"Default: normal theme: site_name_style: normal normal bold italic scratched underline overline","title":"Site name style"},{"location":"nav/setup/fonts/#title-style","text":"Default: bold theme: title_style: bold normal bold italic scratched underline overline","title":"Title style"},{"location":"nav/setup/logo/","text":"January 17, 2023 Changing the logo theme: logo: assets/logo.png","title":"Logo"},{"location":"nav/setup/logo/#changing-the-logo","text":"theme: logo: assets/logo.png","title":"Changing the logo"}]}