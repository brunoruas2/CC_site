{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"hljs.initHighlightingOnLoad(); Eu me chamo Bruno de Melo Ruas. Sou Economista pela Universidade do Estado do Amazonas (UEA). Especialista em Gest\u00e3o Financeira pela Funda\u00e7\u00e3o Get\u00falio Vargas (FGV). Atualmente curso o tecn\u00f3logo de An\u00e1lise e Desenvolvimento de Sistemas da Pontif\u00edcia Universidade Cat\u00f3lica de Minas Gerais (PUC-MG). Minhas Redes: Linkedin Twitter Github Eu tenho um m\u00e9todo de estudar: fingindo que estou dando aula . Ao longo dos anos, percebi que eu havia escrito tanto material, que poderia ajudar outras pessoas com meus textos. Esse site \u00e9 justamente o reposit\u00f3rio p\u00fablico dos conte\u00fados que venho estudando sobre Ci\u00eancia da Computa\u00e7\u00e3o seguindo duas fontes: O conte\u00fado da forma\u00e7\u00e3o em Tecn\u00f3logo em An\u00e1lise e Desenvolvimento de Sistemas pela PUC Minas Gerais . Os cursos da Open Source Society University - OSSU . Originalmente, eu escrevia minhas notas de estudos em LaTeX mas o eu percebi que Markdown era uma maneira mais simples de manter o projeto a medida que a quantidade de p\u00e1ginas foram se aproximando das centenas. Dessa feita, os reposit\u00f3rios antigos em pdf v\u00e3o ser todos migrados para esse projeto. Pontif\u00edcia Universidade Cat\u00f3lica (PUC-MG) O Tecn\u00f3logo foi iniciado em 2022/01 e deve terminar em 2024/2. Ao todo, o curso \u00e9 divido em 3 ciclos e 5 semestres (chamados de Eixos Tem\u00e1ticos). As mat\u00e9rias t\u00e9cnicas que ser\u00e3o estudas (e ter\u00e3o as minhas anota\u00e7\u00f5es salvas aqui) s\u00e3o essas. Ciclo 1: Concep\u00e7\u00e3o e Implementa\u00e7\u00e3o de Sistemas de Software Implementa\u00e7\u00e3o de Sistemas de Software Algoritmos e Abstra\u00e7\u00e3o de Dados Algoritmos e L\u00f3gica de Programa\u00e7\u00e3o Desenvolvimento Web Front-End Matem\u00e1tica B\u00e1sica Organiza\u00e7\u00e3o de Computadores Fundamentos de Engenharia de Software Pensamento Computacional L\u00f3gica Computacional Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Web Front-End An\u00e1lise e Projeto de Sistemas de Software Algoritmos e Estruturas de Dados Modelagem de Dados Engenharia de Requisitos de Software Design de Intera\u00e7\u00e3o Programa\u00e7\u00e3o Modular Desenvolvimento Wb Back-End Fundamentos de Redes de Computadores Manipula\u00e7\u00e3o de Dados com SQL Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Interativa Ciclo 2: Desenvolvimento de Sistemas de Software Orientados a Processos de Neg\u00f3cios Processos de Neg\u00f3cio e de Desenvolvimento de Software Modelagem e Gest\u00e3o de Processos de Neg\u00f3cios Estat\u00edstica Descritiva Desenvolvimento de Aplica\u00e7\u00f5es M\u00f3veis Ger\u00eancia de Projetos de TI Ger\u00eancia de Configura\u00e7\u00e3o Qualidade de Processos de Software Ger\u00eancia de Requisitos de Software Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o M\u00f3vel Infraestrutura para Sistemas de Software Cloud Computing Projeto de Software Arquitetura de Software Distribu\u00eddo APIs e Web Services Teste de Software Banco de Dados NoSQL Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Distribu\u00edda Ciclo 3: Empreendedorismo e Inova\u00e7\u00e3o Empreendedorismo e Inova\u00e7\u00e3o com Sistemas de Software Seguran\u00e7a Aplicada ao Desenvolvimento Compliance em TI Implanta\u00e7\u00e3o de Solu\u00e7\u00e3o de TI Projeto: Desenvolvimento de um Sistema Sociot\u00e9cnico Inovador","title":"Bem Vindos"},{"location":"#pontificia-universidade-catolica-puc-mg","text":"O Tecn\u00f3logo foi iniciado em 2022/01 e deve terminar em 2024/2. Ao todo, o curso \u00e9 divido em 3 ciclos e 5 semestres (chamados de Eixos Tem\u00e1ticos). As mat\u00e9rias t\u00e9cnicas que ser\u00e3o estudas (e ter\u00e3o as minhas anota\u00e7\u00f5es salvas aqui) s\u00e3o essas. Ciclo 1: Concep\u00e7\u00e3o e Implementa\u00e7\u00e3o de Sistemas de Software Implementa\u00e7\u00e3o de Sistemas de Software Algoritmos e Abstra\u00e7\u00e3o de Dados Algoritmos e L\u00f3gica de Programa\u00e7\u00e3o Desenvolvimento Web Front-End Matem\u00e1tica B\u00e1sica Organiza\u00e7\u00e3o de Computadores Fundamentos de Engenharia de Software Pensamento Computacional L\u00f3gica Computacional Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Web Front-End An\u00e1lise e Projeto de Sistemas de Software Algoritmos e Estruturas de Dados Modelagem de Dados Engenharia de Requisitos de Software Design de Intera\u00e7\u00e3o Programa\u00e7\u00e3o Modular Desenvolvimento Wb Back-End Fundamentos de Redes de Computadores Manipula\u00e7\u00e3o de Dados com SQL Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Interativa Ciclo 2: Desenvolvimento de Sistemas de Software Orientados a Processos de Neg\u00f3cios Processos de Neg\u00f3cio e de Desenvolvimento de Software Modelagem e Gest\u00e3o de Processos de Neg\u00f3cios Estat\u00edstica Descritiva Desenvolvimento de Aplica\u00e7\u00f5es M\u00f3veis Ger\u00eancia de Projetos de TI Ger\u00eancia de Configura\u00e7\u00e3o Qualidade de Processos de Software Ger\u00eancia de Requisitos de Software Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o M\u00f3vel Infraestrutura para Sistemas de Software Cloud Computing Projeto de Software Arquitetura de Software Distribu\u00eddo APIs e Web Services Teste de Software Banco de Dados NoSQL Projeto: Desenvolvimento de Uma Aplica\u00e7\u00e3o Distribu\u00edda Ciclo 3: Empreendedorismo e Inova\u00e7\u00e3o Empreendedorismo e Inova\u00e7\u00e3o com Sistemas de Software Seguran\u00e7a Aplicada ao Desenvolvimento Compliance em TI Implanta\u00e7\u00e3o de Solu\u00e7\u00e3o de TI Projeto: Desenvolvimento de um Sistema Sociot\u00e9cnico Inovador","title":"Pontif\u00edcia Universidade Cat\u00f3lica (PUC-MG)"},{"location":"nav/tech/","text":"Aqui eu coloco o conjunto de ferramentas que usei para construir esse portal. Links mkdocs para construir um repo local que pode ser facilmente convertido em um site. simple-blog theme para esse tema simplesmente maravilho. mkdocs-material para expandir algumas funcionalidades importantes do mkdocs. Tecnicamente, \u00e9 um outro tema, mas o material de refer\u00eancia deles \u00e9 \u00f3timo. markdown Extensions para expandir a capacidade do markdown no projeto. S\u00e9rio, existem muitas . github pages para hospedagem gratuita do site.","title":"Tech"},{"location":"nav/tech/#links","text":"mkdocs para construir um repo local que pode ser facilmente convertido em um site. simple-blog theme para esse tema simplesmente maravilho. mkdocs-material para expandir algumas funcionalidades importantes do mkdocs. Tecnicamente, \u00e9 um outro tema, mas o material de refer\u00eancia deles \u00e9 \u00f3timo. markdown Extensions para expandir a capacidade do markdown no projeto. S\u00e9rio, existem muitas . github pages para hospedagem gratuita do site.","title":"Links"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/","text":"hljs.initHighlightingOnLoad(); Assuntos Estrutura de Dados Homog\u00eaneas e Heterog\u00eaneas Estrutura de Dados Homog\u00eaneas Estrutura de Dados Heterog\u00eaneas Tipos Abstratos de Dados, Classes e Implementa\u00e7\u00e3o Defini\u00e7\u00e3o de um TAD - Classes e Objetos Atributos, Propriedades e M\u00e9todos de Classe Mecanismos de Visibilidade/Acessibilidade Construtores e Destrutores de Classe Bibliografia Introdu\u00e7\u00e3o Durante o processo de constru\u00e7\u00e3o de software, a manipula\u00e7\u00e3o de informa\u00e7\u00e3o em mem\u00f3ria \u00e9 tarefa fundamental para que a solu\u00e7\u00e3o de software seja \u00fatil e satisfat\u00f3ria. As linguagens de programa\u00e7\u00e3o possuem especifica\u00e7\u00f5es sobre as caracter\u00edsticas que cada grupo de vari\u00e1veis pode ter, esse controle de propriedade das vari\u00e1veis e das limita\u00e7\u00f5es relacionadas a cada tipo \u00e9 chamado de Tipo de Dado . Dizemos que um Tipo Abstrato de Dado (TAD) \u00e9 a defini\u00e7\u00e3o por parte do programador de uma nova classe de dado otimizada para a resolu\u00e7\u00e3o do problema a ser trabalhado com o software em desenvolvimento. Cont\u00e9m tanto a estrutura da informa\u00e7\u00e3o a ser trabalhada quanto as opera\u00e7\u00f5es, procedimentos e fun\u00e7\u00f5es que podem ser aplicadas a esse tipo de dado novo. A constru\u00e7\u00e3o de TADs passa pela identifica\u00e7\u00e3o das entidades de um problema computacional e a defini\u00e7\u00e3o e desenvolvimento do modelo de dados adequado para a solu\u00e7\u00e3o proposta. Primeiramente, vamos aprender sobre os tipos de dados normalmente existente nas linguagens de programa\u00e7\u00e3o mais comuns do mercado. Podemos dividir os tipos de dados em dois grandes grupos: Homog\u00eaneos e Heterog\u00eaneos. Coment\u00e1rio: Esse microfundamento deve ser estudado somente ap\u00f3s o microfundamento de Algoritmo e L\u00f3gica de Programa\u00e7\u00e3o . Como esse material \u00e9 de refer\u00eancia, ele n\u00e3o deve ser lido, necessariamente, como se fosse um livro. Estrutura de Dados Homog\u00eaneas e Heterog\u00eaneas Estrutura de Dados Homog\u00eaneas Os dois tipos de TAs Homog\u00eaneos mais comuns s\u00e3o os vetores (tamb\u00e9m chamados de arrays), que s\u00e3o formados por uma lista de \\(n\\) elementos de mesmo tipo e as matrizes, que podem ser entendidas como um empilhamento de vetores ou um tipo de vetor de duas dimens\u00f5es. Vetores \u00c9 uma vari\u00e1vel composta, homog\u00eanea e unidimensional. Podemos pensar em um vetor como uma lista com \\(n\\) elementos do mesmo tipo. Como todos os valores de um vetor possuem o mesmo nome (o nome da vari\u00e1vel), para acessarmos algum valor espec\u00edfico de um elemento, precisaremos de um \u00edndice que fa\u00e7a refer\u00eancia ao local na lista onde o valor desejado se encontra. Para criarmos um vetor em c#, usamos a declara\u00e7\u00e3o da vari\u00e1vel com um par de colchetes vazio e a defini\u00e7\u00e3o da quantidade de posi\u00e7\u00f5es (ou lugares) que o nosso vetor ter\u00e1. Abaixo podemos ver um exemplo disso. # c sharp int [] Idades = new int [ 100 ]; // Vetor de int com 100 places double [] Alt = new double [ 20 ]; // Vetor de double com 20 string [] Nomes = new string [ 10 ]; // Vetor de string com 10 No exemplo acima, podemos ver que criamos um vetor denominado Idades que receber\u00e1 apenas valores do tipo inteiro. Um vetor de doubles (que \u00e9 um float com mais casas de precis\u00e3o) chamado salario. E, por fim, um vetor de strings chamado Nomes. Coment\u00e1rio: Existe uma classe que permite a cria\u00e7\u00e3o de um tipo de vetor gen\u00e9rico sem tamanho definido em c# chamado Lista. O curso n\u00e3o entrou nesse assunto mas eu vou deixar esse exemplo de lista aqui. # c sharp using System.Collections.Generic ; List < int > lista = new List < int > (); List . add ( 1 ); List . add ( 2 ); List . remove ( 2 ); Agora que sabemos como criar um vetor. O pr\u00f3ximo passo \u00e9 aprendermos como inserir informa\u00e7\u00e3o nele. Para a nossa sorte, \u00e9 bem simples. Basta colocarmos o nome do vetor seguido da posi\u00e7\u00e3o a ser preenchida entre colchetes. # c sharp Idades [ 20 ] = 10 ; // Valor 10 na posi\u00e7\u00e3o 19 Alt [ 0 ] = 1.2 ; // Valor 1.2 na posi\u00e7\u00e3o 1 S\u00f3 temos que ter cuidado com uma coisa. Existem linguagens (como C#, Java, Python e outras) que colocam o index da primeira posi\u00e7\u00e3o de um vetor como sendo o valor 0. Outras linguagens (como R) usam o numero 1 para essa primeira posi\u00e7\u00e3o. Com base no que aprendemos em Algoritmos e L\u00f3gica da Programa\u00e7\u00e3o , somos capazes de entender o c\u00f3digo abaixo a respeito do uso de um la\u00e7o de repeti\u00e7\u00e3o para preenchimento de um vetor de 5 posi\u00e7\u00f5es. # c sharp int i ; int [] Valores = new int [ 5 ]; // Input dos dados for ( i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( $\"Digite o valor {i + 1}: \" ); Valores [ i ] = int . Parse ( Console . ReadLine ()); }; Desafio O professor prop\u00f5e o seguinte desafio para fixa\u00e7\u00e3o do conceito de vetor: \"Criaremos um vetor de n\u00fameros inteiros com 5 posi\u00e7\u00f5es e ler cada um de seus valores. Criaremos duas fun\u00e7\u00f5es que, tomando esse vetor como par\u00e2metro, ir\u00e3o retornar a soma dos n\u00fameros pares contidos no vetor e a quantidade de n\u00fameros \u00edmpares que ele possui.\" Minha resolu\u00e7\u00e3o desse problema segue abaixo. # c sharp int [] vetor = new int [ 5 ]; int somaPar = 0 ; int contaImpar = 0 ; int input ; // Soma de dois valores int soma ( int valor1 , int valor2 ) { return valor1 + valor2 ; }; // Itera\u00e7\u00e3o para lan\u00e7amento dos valores e somas for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( $\" Valor da Posi\u00e7\u00e3o n\u00ba: {i + 1}\" ); input = int . Parse ( Console . ReadLine ()); vetor [ i ] = input ; if ( input % 2 == 0 ) { somaPar = soma ( somaPar , input ); } else { contaImpar += 1 ; } }; Console . WriteLine ( $\" SomaPar = {somaPar}, ContaImpar = {contaImpar}\" ); Console . WriteLine ( $\"({vetor[0]},{vetor[1]},{vetor[2]},{ vetor[3]},{vetor[4]})\" ); Que produz o seguinte resultado para o input (1,2,1,2,1) . Matrizes Como dito no in\u00edcio dessa se\u00e7\u00e3o. Podemos pensar que matrizes s\u00e3o vetores de duas dimens\u00f5es. Por causa disso, a declara\u00e7\u00e3o da vari\u00e1vel \u00e9 um pouco diferente. # c sharp double [,] Notas = new double [ 4 , 5 ]; // 4 linhas e 5 colunas Por ser uma vari\u00e1vel de duas dimens\u00f5es, a maneira como atribu\u00edmos valores \u00e0 cada posi\u00e7\u00e3o \u00e9 um pouco diferente do caso com vetor. Para cada atribui\u00e7\u00e3o de valor, temos que indicar a linha e coluna que nosso dado ser\u00e1 salvo. # c sharp Notas [ 0 , 0 ] = 1 ; // Linha 1 coluna 1 Notas [ 0 , 1 ] = 1 ; // Linha 1 coluna 2 Notas [ 2 , 3 ] = 1 ; // Linha 3 coluna 4 Notas [ 3 , 4 ] = 1 ; // Linha 4 coluna 5 Devemos sempre lembrar que c# usa a posi\u00e7\u00e3o de numeral 0 para o index inicial de vetores e matrizes. Agora vamos ver um programa simples que exemplifica o que acabamos de aprender. A leitura dele n\u00e3o deve ser dif\u00edcil. Se est\u00e1 tendo dificuldade, volte no microfundamento de l\u00f3gica da programa\u00e7\u00e3o. # c sharp int i , j ; int [,] Valor = new int [ 10 , 3 ]; // Loop para entrada de valores na matriz for ( i = 0 ; i < 10 ; i ++ ) // Loop para linhas { for ( j = 0 ; j < 3 ; j ++ ) // Loop para colunas { Console . WriteLine ( $\"Valor Linha:{i+1} Coluna{j+1}\" ); Valor [ i , j ] = int . Parse ( Console . ReadLine ()); } } Desafio Para a fixa\u00e7\u00e3o do conceito de matrizes, o professor faz o seguinte desafio: \"Vamos fazer um programa que ir\u00e1 ler os dados de uma matriz de inteiros de ordem 5, ou seja, de dimens\u00f5es 5x5. Matematicamente ela \u00e9 chama de matriz quadrada, porque o n\u00famero de \u201clinhas\u201d \u00e9 igual ao n\u00famero de \u201ccolunas\u201d. Depois de darmos entrada nos valores da matriz chamaremos uma fun\u00e7\u00e3o que, tomando essa matriz como par\u00e2metro, retornar\u00e1 um vetor composto pelos elementos da diagonal principal dessa matriz quando, ent\u00e3o, os listaremos.\" # c sharp // Aqui vai ficar o cogido da solu\u00e7\u00e3o do desafio // quando eu tiver vontade de fazer Vetores e Matrizes s\u00e3o os principais tipos homog\u00eaneos de dados. A partir de agora, estudaremos estruturas que nos permitem alocar valores de tipos diferentes em uma mesma vari\u00e1vel. A compreens\u00e3o correta dos tipos de dados \u00e9 a pedra fundamental do paradigma de desenvolvimento chamado de Programa\u00e7\u00e3o Orientada \u00e0 Objetos . Estrutura de Dados Heterog\u00eaneas Registros Na defini\u00e7\u00e3o de um tipo de dado, n\u00f3s definimos precisamente a faixa de valores que podem ser atribu\u00eddos e os m\u00e9todos nativos do tipo de dado. Chamamos de tipo simples de dados os grupos de valores do mesmo tipo (inteiros, reais, string ou booleanos). Por outro lado, chamamos de tipo estruturado de dados os modelos que comportam valores de tipagem diferentes na mesma vari\u00e1vel. Um registro \u00e9 um tipo de dado estruturado. N\u00f3s j\u00e1 estamos familiarizados com as defini\u00e7\u00f5es de vari\u00e1veis em c# para os tipos nativos de dados. # c sharp int x ; double Result ; string Name ; A essa altura do aprendizado, as linhas acima s\u00e3o simples de serem compreendidas. S\u00e3o apenas declara\u00e7\u00f5es do tipos de 3 vari\u00e1veis simples. Mas vejam s\u00f3 o que podemos fazer abaixo. # c sharp Aluno xAlu ; Estranho, n\u00e9?! Estamos declarando a vari\u00e1vel xAlu como sendo do tipo...\"Aluno\"? Sim, \u00e9 isso mesmo! N\u00f3s podemos usar um token dedicado na linguagem para a cria\u00e7\u00e3o de tipos novos de dados que sirvam melhor para solu\u00e7\u00e3o dos problemas que queremos resolver como nosso c\u00f3digo. O token dedicado para constru\u00e7\u00e3o de tipos de dados em c# \u00e9 o struct . Mas para usa-lo bem, temos que aprender os conceitos de tipos de dados heterog\u00eaneos e, no futuro, avan\u00e7aremos para o conceito de classes. O comando struct \u00e9 pensado para o encapsulamento de pequenos conjuntos de vari\u00e1veis relacionadas. No exemplo do tipo Aluno, podemos pensar que todos os alunos devem ter um nome, um cpf e uma data de nascimento, por exemplo. Como essas caracter\u00edsticas se repetem para todos, podemos definir um tipo de dado espec\u00edfico para lidarmos com as informa\u00e7\u00f5es dos alunos. Implementa\u00e7\u00e3o de um Registro A cria\u00e7\u00e3o de um tipo de dado \u00e9 simples. Basta definirmos o nome do tipo de dado e declararmos o conjunto de vari\u00e1veis que far\u00e3o parte dele. No exemplo abaixo, n\u00f3s criamos o tipo \"Funcion\u00e1rio\" com as informa\u00e7\u00f5es que ser\u00e3o usadas. # c sharp struct Funcionario { public string CPF ; public string Name ; public double Salary ; public string dataNasc ; } Podemos ver que a declara\u00e7\u00e3o das vari\u00e1veis dentro do bloco de c\u00f3digo est\u00e3o com o token public antes da declara\u00e7\u00e3o do tipo de dado. Isso ocorre porque precisamos dizer ao compilador da linguagem que essas vari\u00e1veis ser\u00e3o acess\u00edveis fora do bloco de c\u00f3digo em que elas s\u00e3o criadas. Isso tem rela\u00e7\u00e3o direta com o conceito de m\u00e9todo e procedimento que aprendemos no curso de Algoritmo e L\u00f3gica Computacional. Agora que temos o nosso novo tipo de dado criado, podemos usar esse recurso para a defini\u00e7\u00e3o de novas vari\u00e1veis. # c sharp static void Main ( string []) args ) { Funcionario xFunc ; xFunc . CPF = \"1234\" ; xFunc . Name = \"Bruce Wanne\" ; xFunc . Salary = 1234 , 33 ; xFunc . dataNasc = \"31/08/1993\" ; } N\u00e3o precisamos nos preocupar com a primeira linha agora. Basta saber que todo programa em c# \u00e9 um procedimento em algum n\u00edvel. Podemos focar apenas no que est\u00e1 dentro dos colchetes. Com o tipo de dado criado. Podemos criar a vari\u00e1vel xFunc e acessar seus par\u00e2metros usando um ponto ap\u00f3s o seu nome. A atribui\u00e7\u00e3o \u00e9 feita como antes mas agora n\u00e3o precisamos declarar os tipos porque eles est\u00e3o definidos dentro do tipo de dado. J\u00e1 aprendemos no come\u00e7o desse microfundamento que a cria\u00e7\u00e3o de vetores (que s\u00e3o listas de elementos do mesmo tipo) s\u00e3o feitas em c# pela adi\u00e7\u00e3o de colchetes vazios na declara\u00e7\u00e3o das vari\u00e1veis. Por exemplo, um vetor de inteiros \u00e9 definido por int[] . Pois bem, podemos usar a mesma l\u00f3gica e criar um vetor do tipo que acabamos de criar 1 . Analogamente, como nosso tipo de dado \u00e9 Funcionario , seu vetor que conter\u00e1 v\u00e1rios funcion\u00e1rios diferentes ser\u00e1 criado por Funcionario[] . # c sharp Funcionario [] xFunc = new Funcionario [ 5 ]; for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( \"CPF do funcion\u00e1rio: \" ); xFunc [ i ]. CPF = Console . readLine (); Console . WriteLine ( \"Nome do funcion\u00e1rio: \" ); xFunc [ i ]. Name = Console . readLine (); Console . WriteLine ( \"Sal\u00e1rio: \" ); xFunc [ i ]. Salary = Console . readLine (); Console . WriteLine ( \"Data de Nascimento: \" ); xFunc [ i ]. dataNasc = Console . readLine (); } Acima, temos a cria\u00e7\u00e3o de um vetor de 5 posi\u00e7\u00f5es onde cada elemento \u00e9 do tipo Funcionario. Logo abaixo, temos um loop para facilitar o preenchimento das informa\u00e7\u00f5es de cada elemento do vetor. Estamos come\u00e7ando a nos aproximar do conceito de banco de dados. Mas n\u00e3o veremos isso agora. Tipos de Dados Aninhados N\u00e3o precisamos parar por aqui, \u00e9 plenamente poss\u00edvel criarmos um tipo de dados que use outro tipo de dados criado fora dele. Por exemplo, ao inv\u00e9s de salvarmos a data de nascimento como uma string, podemos criar um tipo de dados chamado Data que recebe 3 informa\u00e7\u00f5es: dia, m\u00eas e ano. # c sharp struct Funcionario { public string CPF ; public string Name ; public double Salary ; public Data dataNasc ; } struct Data { public string day ; public string month ; public string year ; } Dentro do tipo funcion\u00e1rio, temos a declara\u00e7\u00e3o de um vari\u00e1vel do tipo data. Para aproveitarmos o c\u00f3digo de cria\u00e7\u00e3o de um vetor Funcionario. Podemos fazer apenas uma pequena altera\u00e7\u00e3o. # c sharp Funcionario [] xFunc = new Funcionario [ 5 ]; for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( \"CPF do funcion\u00e1rio: \" ); xFunc [ i ]. CPF = Console . readLine (); Console . WriteLine ( \"Nome do funcion\u00e1rio: \" ); xFunc [ i ]. Name = Console . readLine (); // Parte que foi substitu\u00edda // Console.WriteLine(\"Sal\u00e1rio: \"); // xFunc[i].Salary = Console.readLine(); Console . WriteLine ( \"Data de Nascimento - Dia: \" ); xFunc [ i ]. dataNasc . day = Console . readLine (); Console . WriteLine ( \"Data de Nascimento - M\u00eas: \" ); xFunc [ i ]. dataNasc . month = Console . readLine (); Console . WriteLine ( \"Data de Nascimento - Ano: \" ); xFunc [ i ]. dataNasc . year = Console . readLine (); } A cria\u00e7\u00e3o de tipos eficientes de dados \u00e9 uma ferramenta muito eficiente para padroniza\u00e7\u00e3o e manuten\u00e7\u00e3o de solu\u00e7\u00f5es de software. \u00c9 sempre bom entendermos bem o problema proposto e quais tipos de dados podem ser criados para a cria\u00e7\u00e3o de uma resposta adequada a ele. TAD, Classes e Implementa\u00e7\u00e3o Defini\u00e7\u00e3o de um TAD - Classes e Objetos Um tipo abstrato de dado ou TAD \u00e9 um \"padr\u00e3o\" ou \"modelo\" que rege as caracter\u00edsticas que determinada estrutura de dado criada bem como suas fun\u00e7\u00f5es (que chamamos de m\u00e9todos) internas. Ou seja, um TAD \u00e9 a defini\u00e7\u00e3o das informa\u00e7\u00f5es contidas e as opera\u00e7\u00f5es execut\u00e1veis por uma vari\u00e1vel de um determinado modelo. N\u00f3s estamos usando isso o tempo todo sem perceber. Por exemplo, quando usamos a fun\u00e7\u00e3o Math.Pow(a,b) n\u00f3s estamos, na verdade, executando um m\u00e9todo chamamo Pow dentro do objeto Math . Exatamente o mesmo pensamento \u00e9 aplicado ao Console.Write() ou Console.ReadLine() . Agora que estamos avan\u00e7ando mais no nosso conhecimento sobre desenvolvimento de software, come\u00e7amos a entender mais sobre as estruturas que nos permitem realizar os nossos trabalhos, ou no jarg\u00e3o, estamos come\u00e7ando a ver \"de baixo do cap\u00f4\". At\u00e9 agora, n\u00f3s temos definido os nossos TADs atrav\u00e9s da defini\u00e7\u00e3o de sua estrutura (pelo token struct ), mas as linguagens que utilizam o paradigma orientado \u00e0 objeto atuais usam o conceito de classes para defini\u00e7\u00e3o dos seus TADs. Implementando TADs usando Classes J\u00e1 aprendemos a implementar um TAD por estrutura. # c sharp // Definindo o TAD struct Produto { public string Nome ; public double PrecoUnd ; } // Criando uma vari\u00e1vel com TAD Produto xProd ; // Usando o TAD xProd . Nome = \"PS5\" ; xProd . PrecoUnd = 8000.99 ; Podemos construir uma solu\u00e7\u00e3o an\u00e1loga a essa pelo token de cria\u00e7\u00e3o de classes. # c sharp // Definindo o TAD class Produto { public string Nome ; public double PrecoUnd ; } // Criando a classe Produto xProd = new Produto (); // Usando o TAD xProd . Nome = \"Xbox One\" ; xProd . PrecoUnd = 9999.99 ; Em uma primeira vista, parecem ser abordagens equivalentes. Mas existem algumas diferen\u00e7as importantes que merecem a nossa aten\u00e7\u00e3o. Para entender bem a diferen\u00e7a entre essas constru\u00e7\u00f5es, vamos ter que aprender um pouco mais sobre como o computador guarda informa\u00e7\u00f5es. O layout de mem\u00f3ria de programas em C s\u00e3o separados em 5 n\u00edveis : Text segment (instructions) Initializes data segment Uninitialized data segment (bss) Heap Stack (Inline) N\u00f3s n\u00e3o vamos nos atentar muito aos detalhes agora. Mas agora que sabemos um pouco das diferentes aloca\u00e7\u00f5es poss\u00edveis na mem\u00f3ria durante a execu\u00e7\u00e3o de um programa. Podemos focar no que for necess\u00e1rio para diferenciarmos o struct do class . Os valores do tipo struct s\u00e3o alocados na mem\u00f3ria stack. Essa parte de mem\u00f3ria grava temporariamente as vari\u00e1veis criadas por uma fun\u00e7\u00e3o. No stack, as vari\u00e1veis s\u00e3o declaras, guardadas e inicializadas durante a execu\u00e7\u00e3o do programa e apagadas na sua conclus\u00e3o. A mem\u00f3ria \u00e9 alocada em um bloco cont\u00edguos. \u00c9 mais limitada e de r\u00e1pido acesso. Os valores do tipo class s\u00e3o alocados no heap. Essa \u00e9 a parte da mem\u00f3ria usada pelas linguagens de programa\u00e7\u00e3o para suas vari\u00e1veis de escopo global. A mem\u00f3ria \u00e9 alocada de maneira aleat\u00f3ria e \u00e9 mais abundante se comparada com a stack. Sempre que criamos uma nova inst\u00e2ncia como fizemos em Produto xProd = new Produto() n\u00f3s estamos apontando um novo endere\u00e7o de mem\u00f3ria para ser usado. Desafio Cadastrar objetos em um vetor usando uma classe. # c sharp using System ; namespace WorkSpace { // Criando o TAD do tipo class class carro { public string name ; public string marca ; public string anoFab ; public string placa ; public double precoFip ; }; class Program { static void Main ( string [] args ) { // Criando um vetor do tipo carro carro [] cadCarro = new carro [ 3 ]; // Loop para inserir o input no vetor for ( int i = 0 ; i < 2 ; i ++ ) { carro x = new carro (); Console . Write ( $\"\\n Qual o nome? \" ); x . name = Console . ReadLine (); Console . Write ( $\" Qual a marca? \" ); x . marca = Console . ReadLine (); Console . Write ( $\" Qual o ano de fabrica\u00e7\u00e3o? \" ); x . anoFab = Console . ReadLine (); Console . Write ( $\" Qual a placa? \" ); x . placa = Console . ReadLine (); Console . Write ( $\" Qual o pre\u00e7o da tabela FIP? \" ); x . precoFip = double . Parse ( Console . ReadLine ()); // Salvando o x no vetor cadCarro cadCarro [ i ] = x ; }; Console . Clear (); // Mostrando o resultado foreach ( carro C in cadCarro ) { Console . WriteLine ( $\"\\n Carro: {C.name},Marca:{C.marca}\" ); Console . WriteLine ( $\" Placa: {C.placa}, Ano:{C.anoFab}\" ); Console . WriteLine ( $\" Pre\u00e7o da Tabela Fip: {C.precoFip}\" ); }; Console . ReadKey (); } } } \u00c9 muito mais comum se achar situa\u00e7\u00f5es de constru\u00e7\u00e3o de TADs por uso de classes ao inv\u00e9s de estruturas. Vale a pena estudar mais para sabermos exatamente quando cada uma dessas op\u00e7\u00f5es \u00e9 a adequada. Mas no come\u00e7o, as classes nos servir\u00e3o muito bem. Aqui \u00e9 importante frisarmos uma coisa. Quando instanciamos um objeto (ou seja, quando usamos o token new ) o nome que passamos a esse objeto \u00e9 apenas uma refer\u00eancia . Isso quer dizer que, no exemplo acima, cadCarro n\u00e3o \u00e9 o nosso objeto em si e sim uma refer\u00eancia a ele. Alguns de voc\u00eas podem estar questionando o motivo desse aviso. Sabendo que cadCarro n\u00e3o \u00e9 o objeto em si e sim apenas uma refer\u00eancia que aponta para o endere\u00e7o na mem\u00f3ria em que o objeto est\u00e1 salvo, ao criarmos uma nova linha no nosso c\u00f3digo do tipo cadCarro2 = cadCarro estamos criando uma nova refer\u00eancia para o mesmo objeto alocado na mem\u00f3ria. Ou seja, qualquer manipula\u00e7\u00e3o feita usando a refer\u00eancia cadCarro tamb\u00e9m ser\u00e1 refletida em cadCarro2 . Abaixo temos um programa simples que usa essa rela\u00e7\u00e3o de refer\u00eancia. # c sharp using System ; class Program { class carro { public string name ; public string marca ; public string anoFab ; public string placa ; public double precoFip ; }; public static void Main ( string [] args ) { // Criando um vetor do tipo carro carro cadCarro = new carro (); carro cadCarro2 = null ; cadCarro . name = \"carro Nome\" ; cadCarro . marca = \"marca\" ; cadCarro . anoFab = \"2022\" ; cadCarro . placa = \"placa\" ; cadCarro . precoFip = 22.22 ; Console . WriteLine ( $\"{cadCarro.name}\" ); cadCarro2 = cadCarro ; Console . WriteLine ( $\"{cadCarro2.name}\" ); cadCarro2 . name = \"carro nome 2\" ; Console . WriteLine ( $\"{cadCarro.name}\" ); } } Atributos, Propriedades e M\u00e9todos de Classe Vamos analisar com calma essas duas cita\u00e7\u00f5es do texto: \"Uma classe especifica uma estrutura de dados e os seus m\u00e9todos operacionais permiss\u00edveis que se aplicam a cada um dos seus objetos\" (MARTIN e ODELL, 1995). \"Um objeto \u00e9 qualquer coisa, real ou abstrata, a respeito da qual armazenamos os dados e os m\u00e9todos que os manipulam\" (MARTIN e ODELL, 1995). Em ambas as cita\u00e7\u00f5es temos as figuras dos dados e dos m\u00e9todos. A estrutura dos dados n\u00f3s j\u00e1 vimos na se\u00e7\u00e3o passada quando lidamos com defini\u00e7\u00e3o de TADs declarando os tipos das vari\u00e1veis tanto na declara\u00e7\u00e3o via estrutura quanto por classe. Agora, vamos expandir um pouco mais o poder dos TADs nos permitindo definir, al\u00e9m das regras de quais dados ser\u00e3o armazenados, quais opera\u00e7\u00f5es e fun\u00e7\u00f5es ser\u00e3o executadas internamente por nossos objetos. Ao construir um tipo abstrato de dados, nos perguntamos quais informa\u00e7\u00f5es ser\u00e3o necess\u00e1rias e, al\u00e9m disso, quais opera\u00e7\u00f5es ser\u00e3o usadas para resolu\u00e7\u00e3o do nosso problema. Indo um pouco mais fundo Vejamos o seguinte TAD criado apenas com a defini\u00e7\u00e3o da estrutura de dados: # c sharp class pessoa { public string name ; public double salary ; } Dizemos que as informa\u00e7\u00f5es sobre nome e sal\u00e1rio s\u00e3o atributos do nosso objeto pessoa . Eles definem a estrutura do tipo abstrato de dados que definimos. Tamb\u00e9m podemos chama-los de vari\u00e1veis da classe pessoa . Mesmo que o exemplo acima funcione. Uma maneira mais apropriada de reconstruir essa solu\u00e7\u00e3o pode ser vista abaixo. # c sharp class pessoa { private string _name ; public string name { get { return _name ;} set { _name = value ;} } private double _salary ; public double salary { get { return _salary ;} set { _salary = value ;} } } Os campos _name e _salary s\u00e3o definidos com o escopo privado e podem ser acessados somente internamente ao objeto. Para podermos acessar fora do escopo do objeto, usamos as fun\u00e7\u00f5es nativas get e set . Os nomes das fun\u00e7\u00f5es deixam claro o que cada uma faz. set \u00e9 usado para atribui\u00e7\u00e3o de um valor passado (que chamamos de value) e get \u00e9 usado para retorno de valor salvo no objeto. Vamos ver um programa simples que utiliza esses conceitos. # c sharp namespace WorkSpace { class pessoa { private string _name ; public string name { get { return _name ;} set { _name = value ;} } private double _salary ; public double salary { get { return _salary ;} set { _salary = value ;} } }; class Program { static void Main ( string [] args ) { pessoa xpes = new pessoa (); xpes . name = \"Clark Kent\" ; xpes . salary = 1234.56 ; Console . WriteLine ( $\"Nome: {xpes.name}\" ); Console . WriteLine ( $\"Sal\u00e1rio: R$ {xpes.salary}\" ); } } } Na linha xpes.name = \"Clark Kent\" vemos como a fun\u00e7\u00e3o interna set funciona. Ela recebe o valor e atribui \u00e0 vari\u00e1vel provada _name . Quando definimos um atributo privado e fun\u00e7\u00f5es ( get e set ) que manipulam esse atributo dentro da classe, podemos dizer que criamos uma propriedade do objeto. J\u00e1 temos os conceitos de objeto, atributo e propriedade bem definidos. Agora vamos aprender sobre as fun\u00e7\u00f5es dentro de um objeto. A essas fun\u00e7\u00f5es, damos o nome de m\u00e9todos ou servi\u00e7os do objeto . # c sharp class circulo { private double _raio ; public double raio { get { return _raio ; } set { _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Aqui temos um atributo chamado _raio . Uma propriedade chamada raio . E, por fim, temos tamb\u00e9m um m\u00e9todo chamado calcArea . Abaixo temos um exemplo de como usar esses conceitos na pr\u00e1tica. # c sharp namespace WorkSpace { class circulo { private double _raio ; public double raio { get { return _raio ; } set { _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } class Program { static void Main ( string [] args ) { double area ; circulo xcirculo = new circulo (); xcirculo . raio = 2.5 ; area = xcirculo . calcArea (); Console . WriteLine ( $\"A \u00e1rea \u00e9 igual a {area:F2}\" ); Console . ReadKey (); } } } Coment\u00e1rio: Eu n\u00e3o sei voc\u00ea, mas eu fiquei com d\u00favidas sobre essa parte do area:F2 . Isso \u00e9 muito simples. Como o valor area \u00e9 do tipo double, ele possui v\u00e1rias casas ap\u00f3s a v\u00edrgula. Esse par\u00e2metro \u00e9 a defini\u00e7\u00e3o da quantidade de casas ap\u00f3s a v\u00edrgula. Nesse caso, o resultado ter\u00e1 2 casas ap\u00f3s a v\u00edrgula. Quando encapsulamos as propriedades e os m\u00e9todos dentro de um objeto, estamos omitindo os detalhes de como objeto faz as transforma\u00e7\u00f5es e armazena os dados. A essa t\u00e9cnica damos o nome de oculta\u00e7\u00e3o da informa\u00e7\u00e3o . Isso \u00e9 \u00fatil para garantir a integridade da manipula\u00e7\u00e3o dos dados por parte dos usu\u00e1rios e aumenta a seguran\u00e7a quanto a l\u00f3gica implementada no c\u00f3digo. Podemos definir a l\u00f3gica tamb\u00e9m dentro das fun\u00e7\u00f5es de set e get . # c sharp namespace WorkSpace { class circulo { private double _raio ; public double raio { get { return _raio ; } set { if ( value < 0 ) _raio = 0 ; else _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } class Program { static void Main ( string [] args ) { double area ; circulo xcir = new circulo (); xcir . raio = - 2.5 ; area = xcir . calcArea (); Console . WriteLine ( $\"Area: {area:F2}\" ); } } } Desse modo, podemos ver que caso o valor inputado no raio for negativo, o resultado da \u00e1rea ser\u00e1 0. Caso for positivo, o valor da \u00e1rea ser\u00e1 calculado normalmente. Se import\u00e1ssemos esse objeto sem saber o que acontece por dentro dele, n\u00e3o entender\u00edamos o que acontece exatamente dentro do objeto circulo . Mecanismos de Visibilidade/Acessibilidade Os modificadores de acesso ou mecanismos de visibilidade s\u00e3o os m\u00e9todos de acesso \u00e0s classes e seus, atributos, propriedades e m\u00e9todos. Existem v\u00e1rios tipos de modificadores de acesso ( protected , internal , protected internal e etc), mas por agora, vamos estudar somente o public e o private . Observemos novamente o c\u00f3digo da \u00faltima se\u00e7\u00e3o com algumas anota\u00e7\u00f5es adicionais. # c sharp // Bloco contendo todo o programa namespace WorkSpace { // Defini\u00e7\u00e3o do TAD circulo class circulo { private double _raio ; public double raio { get { return _raio ; } set { if ( value < 0 ) _raio = 0 ; else _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } // Bloco contendo o programa class Program { // Procedimento do programa static void Main ( string [] args ) { double area ; circulo xcir = new circulo (); xcir . raio = - 2.5 ; area = xcir . calcArea (); Console . WriteLine ( $\"Area: {area:F2}\" ); } } } Podemos ver que a classe circulo \u00e9 criada antes do bloco que cont\u00e9m o programa propriamente dito. Ou seja, est\u00e3o em escopos diferentes. Desse modo, um comando contido no procedimento Main n\u00e3o tem acesso a nenhuma propriedade ou atributos com o par\u00e2metro private nele somente os de par\u00e2metro public ou atrav\u00e9s das fun\u00e7\u00f5es set e get . Aten\u00e7\u00e3o: Na cria\u00e7\u00e3o da classe circulo n\u00e3o foi dito se ela seria acess\u00edvel fora do seu escopo original, ou seja, n\u00e3o usamos o comando public class circulo e sim o comando class circulo . Em c#, quando se cria uma classe sem a defini\u00e7\u00e3o expl\u00edcita da sua visibilidade, o padr\u00e3o da linguagem \u00e9 deixar a classe como public . Qualidade e Robustez de Software Esses conceitos de controle de acesso s\u00e3o importantes porque nosso c\u00f3digo precisa fazer o que foi planejado, da maneira planejada. Quando n\u00e3o limitamos a capacidade do usu\u00e1rio inserir dados, podemos cair em situa\u00e7\u00f5es n\u00e3o previstas que podem comprometer a execu\u00e7\u00e3o do nosso programa. Um conceito que nos ajuda a entender melhor essa situa\u00e7\u00e3o \u00e9 o robustez do software . Esse conceito \u00e9 usado pelos profissionais de qualidade de software e que \u00e9 referente a capacidade do programa em funcionar da maneira correta em diferentes cen\u00e1rios e condi\u00e7\u00f5es adversas. Outro conceito \u00fatil dessa \u00e1rea \u00e9 o corre\u00e7\u00e3o de software que \u00e9 a qualidade referente a capacidade do nosso programa funcionar da maneira prevista e especificada. A t\u00e9cnica da omiss\u00e3o da informa\u00e7\u00e3o nos ajuda a garantir o cumprimento desses requisitos. Construtores e Destrutores de Classe Um construtor de classe \u00e9 usado para cria\u00e7\u00e3o de um objeto e pela inicializa\u00e7\u00e3o dos seus atributos. Sempre que instanciamos um objeto, o seu construtor entra em a\u00e7\u00e3o. Coment\u00e1rio: N\u00e3o entraremos a fundo no conceito de Common Language Runtime (CLR) agora. Talvez mais pra frente a gente veja isso. Se um construtor n\u00e3o for declarado explicitamente, o c# cria a classe usando algumas conven\u00e7\u00f5es de modo a colocar o objeto dispon\u00edvel para uso. Esses padr\u00f5es de construtores s\u00e3o definidos de acordo com o tipo primitivo das vari\u00e1veis contidas no nosso objeto (que sabemos que se chamam atributos). Por padr\u00e3o, o CLR atribui os seguintes valores para os atributos dos objetos: 0 para vari\u00e1veis do tipo int, double e float false para vari\u00e1veis booleanas '\\0' para vari\u00e1veis do tipo string Definindo Construtores Para n\u00e3o usarmos as conven\u00e7\u00f5es padr\u00e3o do CLR. Podemos, n\u00f3s mesmo, atribuir os construtores dos atributos dos nossos objetos. Para isso, usamos um m\u00e9todo (ou seja, uma fun\u00e7\u00e3o interna do objeto) com o mesmo nome do objeto . Esse m\u00e9todo n\u00e3o possui retorno e s\u00e3o declarados como public . # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor { _raio = 0 ; } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } A partir de agora, sempre que executarmos um instanciamento atrav\u00e9s do comando # c sharp circulo xcir = new circulo (); O construtor ser\u00e1 chamado e executar\u00e1 as instru\u00e7\u00f5es contidas no construtor. No caso de exemplo, o valor default para o atributo _raio ser\u00e1 0. N\u00e3o \u00e9 dif\u00edcil pensar em situa\u00e7\u00f5es onde precisar\u00edamos usar diferentes m\u00e9todos de constru\u00e7\u00e3o em um objeto. Para isso, podemos ter mais de um construtor no mesmo objeto, chamamos isso de sobrecarregamento . A condi\u00e7\u00e3o \u00e9 que esses construtores sejam diferentes em termos de par\u00e2metros ou ordem dos par\u00e2metros. # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor { _raio = 0 ; } public circulo ( int R ) { _raio = R ; } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Para executar o segundo construtor, basta passarmos um par\u00e2metro no momento do instanciamento do nosso novo objeto. # c sharp circulo xcirc = new circulo ( 2.3 ); Como fizemos um instanciamento com valor, o c# saber\u00e1 que queremos usar o segundo construtor ao inv\u00e9s do primeiro. Destrutores Ao contr\u00e1rio do que podemos pensar pelo nome, os destrutores n\u00e3o s\u00e3o usados para \"destruir\" os objetos. Eles s\u00e3o usados definir um comportamento espec\u00edfico no momento da destrui\u00e7\u00e3o de um objeto. Ou seja, eles s\u00e3o acionados na destrui\u00e7\u00e3o e n\u00e3o s\u00e3o os destruidores. N\u00e3o precisam ser chamados ou referenciados pois s\u00e3o invocados automaticamente. O normal \u00e9 n\u00e3o se usar destrutores no dia a dia visto que o CLR j\u00e1 faz o trabalho de padroniza\u00e7\u00e3o para elimina\u00e7\u00e3o de um objeto. Diferente dos construtores, uma classe pode ter apenas um destrutor . E a sua cria\u00e7\u00e3o \u00e9 parecida com a do construtor, uma vez que s\u00e3o m\u00e9todos sem retorno. A \u00fanica diferen\u00e7a \u00e9 que sua nota\u00e7\u00e3o come\u00e7a com o til. # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor 1 { _raio = 0 ; } public circulo ( int R ) // construtor 2 { _raio = R ; } ~ circulo { Console . WriteLine ( \"Adeus, mundo cruel!\" ); } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Os detalhes de como um computador funciona s\u00e3o estudados em Estrutura de Computadores mas, para adiantar, algumas linguagens tem um programa chamado garbage colector que \u00e9 respons\u00e1vel pela reutiliza\u00e7\u00e3o de slots de mem\u00f3ria que est\u00e3o sendo usados por objetos que n\u00e3o tem mais utiliza\u00e7\u00e3o no c\u00f3digo. Em c# n\u00f3s n\u00e3o precisamos explicitamente eliminar um objeto porque o pr\u00f3prio garbage colector faz esse trabalho. Bibliografia ASCENCIO, Ana Fernanda Gomes; CAMPOS, Edilene Aparecida Veneruchi de. Fundamentos da programa\u00e7\u00e3o de computadores . S\u00e3o Paulo: Pearson, 2012. ISBN 9788564574168 SOUZA, Marco A. Furlan de; GOMES, Marcelo Marques; SOARES, Marcio Vieira; CONC\u00cdLIO, Ricardo. Algoritmos e l\u00f3gica de programa\u00e7\u00e3o: um texto introdut\u00f3rio para a engenharia . S\u00e3o Paulo: Cengage Learning, 2019. ISBN: 9788522128150 AGUILAR, Luis Joyanes. Fundamentos de programa\u00e7\u00e3o algoritmos, estruturas de dados e objetos . 3. ed. Porto Alegre: AMGH, 2008. ISBN: 9788580550146 DEITEL, Harvey M; DEITEL, Paul J. Java - como programar . 8. ed. S\u00e3o Paulo: Pearson, 2010. ISBN 9788576055631 GRIFFITHS, Ian. Programming C# 8.0 . O'Reilly Media, Inc. 2019. ISBN 9781492056812 MANZANO, Jos\u00e9 Augusto N. G; OLIVEIRA, Jayr Figueiredo de. Algoritmos: l\u00f3gica para desenvolvimento de programa\u00e7\u00e3o de computadores . 28. ed. rev. e atual. S\u00e3o Paulo, SP: \u00c9rica, 2016. E-book. ISBN 9788536518657 PRICE, Mark J. C# 8.0 and T Core 3.0 - Modern Cross - Platform Development . O'Reilly Media; 2019. ISBN 9781788478120 PUGA, Sandra; RISSETTI, Gerson. L\u00f3gica de programa\u00e7\u00e3o e estruturas de dados com aplica\u00e7\u00f5es em Java . 2. ed. S\u00e3o Paulo: Prentice Hall, 2009. ISBN 9788576052074 Isso \u00e9 muito legal! \u21a9","title":"Algoritmo e Abstra\u00e7\u00e3o"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#assuntos","text":"Estrutura de Dados Homog\u00eaneas e Heterog\u00eaneas Estrutura de Dados Homog\u00eaneas Estrutura de Dados Heterog\u00eaneas Tipos Abstratos de Dados, Classes e Implementa\u00e7\u00e3o Defini\u00e7\u00e3o de um TAD - Classes e Objetos Atributos, Propriedades e M\u00e9todos de Classe Mecanismos de Visibilidade/Acessibilidade Construtores e Destrutores de Classe Bibliografia","title":"Assuntos"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#introducao","text":"Durante o processo de constru\u00e7\u00e3o de software, a manipula\u00e7\u00e3o de informa\u00e7\u00e3o em mem\u00f3ria \u00e9 tarefa fundamental para que a solu\u00e7\u00e3o de software seja \u00fatil e satisfat\u00f3ria. As linguagens de programa\u00e7\u00e3o possuem especifica\u00e7\u00f5es sobre as caracter\u00edsticas que cada grupo de vari\u00e1veis pode ter, esse controle de propriedade das vari\u00e1veis e das limita\u00e7\u00f5es relacionadas a cada tipo \u00e9 chamado de Tipo de Dado . Dizemos que um Tipo Abstrato de Dado (TAD) \u00e9 a defini\u00e7\u00e3o por parte do programador de uma nova classe de dado otimizada para a resolu\u00e7\u00e3o do problema a ser trabalhado com o software em desenvolvimento. Cont\u00e9m tanto a estrutura da informa\u00e7\u00e3o a ser trabalhada quanto as opera\u00e7\u00f5es, procedimentos e fun\u00e7\u00f5es que podem ser aplicadas a esse tipo de dado novo. A constru\u00e7\u00e3o de TADs passa pela identifica\u00e7\u00e3o das entidades de um problema computacional e a defini\u00e7\u00e3o e desenvolvimento do modelo de dados adequado para a solu\u00e7\u00e3o proposta. Primeiramente, vamos aprender sobre os tipos de dados normalmente existente nas linguagens de programa\u00e7\u00e3o mais comuns do mercado. Podemos dividir os tipos de dados em dois grandes grupos: Homog\u00eaneos e Heterog\u00eaneos. Coment\u00e1rio: Esse microfundamento deve ser estudado somente ap\u00f3s o microfundamento de Algoritmo e L\u00f3gica de Programa\u00e7\u00e3o . Como esse material \u00e9 de refer\u00eancia, ele n\u00e3o deve ser lido, necessariamente, como se fosse um livro.","title":"Introdu\u00e7\u00e3o"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#estrutura-de-dados-homogeneas-e-heterogeneas","text":"","title":"Estrutura de Dados Homog\u00eaneas e Heterog\u00eaneas"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#estrutura-de-dados-homogeneas","text":"Os dois tipos de TAs Homog\u00eaneos mais comuns s\u00e3o os vetores (tamb\u00e9m chamados de arrays), que s\u00e3o formados por uma lista de \\(n\\) elementos de mesmo tipo e as matrizes, que podem ser entendidas como um empilhamento de vetores ou um tipo de vetor de duas dimens\u00f5es.","title":"Estrutura de Dados Homog\u00eaneas"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#vetores","text":"\u00c9 uma vari\u00e1vel composta, homog\u00eanea e unidimensional. Podemos pensar em um vetor como uma lista com \\(n\\) elementos do mesmo tipo. Como todos os valores de um vetor possuem o mesmo nome (o nome da vari\u00e1vel), para acessarmos algum valor espec\u00edfico de um elemento, precisaremos de um \u00edndice que fa\u00e7a refer\u00eancia ao local na lista onde o valor desejado se encontra. Para criarmos um vetor em c#, usamos a declara\u00e7\u00e3o da vari\u00e1vel com um par de colchetes vazio e a defini\u00e7\u00e3o da quantidade de posi\u00e7\u00f5es (ou lugares) que o nosso vetor ter\u00e1. Abaixo podemos ver um exemplo disso. # c sharp int [] Idades = new int [ 100 ]; // Vetor de int com 100 places double [] Alt = new double [ 20 ]; // Vetor de double com 20 string [] Nomes = new string [ 10 ]; // Vetor de string com 10 No exemplo acima, podemos ver que criamos um vetor denominado Idades que receber\u00e1 apenas valores do tipo inteiro. Um vetor de doubles (que \u00e9 um float com mais casas de precis\u00e3o) chamado salario. E, por fim, um vetor de strings chamado Nomes. Coment\u00e1rio: Existe uma classe que permite a cria\u00e7\u00e3o de um tipo de vetor gen\u00e9rico sem tamanho definido em c# chamado Lista. O curso n\u00e3o entrou nesse assunto mas eu vou deixar esse exemplo de lista aqui. # c sharp using System.Collections.Generic ; List < int > lista = new List < int > (); List . add ( 1 ); List . add ( 2 ); List . remove ( 2 ); Agora que sabemos como criar um vetor. O pr\u00f3ximo passo \u00e9 aprendermos como inserir informa\u00e7\u00e3o nele. Para a nossa sorte, \u00e9 bem simples. Basta colocarmos o nome do vetor seguido da posi\u00e7\u00e3o a ser preenchida entre colchetes. # c sharp Idades [ 20 ] = 10 ; // Valor 10 na posi\u00e7\u00e3o 19 Alt [ 0 ] = 1.2 ; // Valor 1.2 na posi\u00e7\u00e3o 1 S\u00f3 temos que ter cuidado com uma coisa. Existem linguagens (como C#, Java, Python e outras) que colocam o index da primeira posi\u00e7\u00e3o de um vetor como sendo o valor 0. Outras linguagens (como R) usam o numero 1 para essa primeira posi\u00e7\u00e3o. Com base no que aprendemos em Algoritmos e L\u00f3gica da Programa\u00e7\u00e3o , somos capazes de entender o c\u00f3digo abaixo a respeito do uso de um la\u00e7o de repeti\u00e7\u00e3o para preenchimento de um vetor de 5 posi\u00e7\u00f5es. # c sharp int i ; int [] Valores = new int [ 5 ]; // Input dos dados for ( i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( $\"Digite o valor {i + 1}: \" ); Valores [ i ] = int . Parse ( Console . ReadLine ()); };","title":"Vetores"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#desafio","text":"O professor prop\u00f5e o seguinte desafio para fixa\u00e7\u00e3o do conceito de vetor: \"Criaremos um vetor de n\u00fameros inteiros com 5 posi\u00e7\u00f5es e ler cada um de seus valores. Criaremos duas fun\u00e7\u00f5es que, tomando esse vetor como par\u00e2metro, ir\u00e3o retornar a soma dos n\u00fameros pares contidos no vetor e a quantidade de n\u00fameros \u00edmpares que ele possui.\" Minha resolu\u00e7\u00e3o desse problema segue abaixo. # c sharp int [] vetor = new int [ 5 ]; int somaPar = 0 ; int contaImpar = 0 ; int input ; // Soma de dois valores int soma ( int valor1 , int valor2 ) { return valor1 + valor2 ; }; // Itera\u00e7\u00e3o para lan\u00e7amento dos valores e somas for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( $\" Valor da Posi\u00e7\u00e3o n\u00ba: {i + 1}\" ); input = int . Parse ( Console . ReadLine ()); vetor [ i ] = input ; if ( input % 2 == 0 ) { somaPar = soma ( somaPar , input ); } else { contaImpar += 1 ; } }; Console . WriteLine ( $\" SomaPar = {somaPar}, ContaImpar = {contaImpar}\" ); Console . WriteLine ( $\"({vetor[0]},{vetor[1]},{vetor[2]},{ vetor[3]},{vetor[4]})\" ); Que produz o seguinte resultado para o input (1,2,1,2,1) .","title":"Desafio"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#matrizes","text":"Como dito no in\u00edcio dessa se\u00e7\u00e3o. Podemos pensar que matrizes s\u00e3o vetores de duas dimens\u00f5es. Por causa disso, a declara\u00e7\u00e3o da vari\u00e1vel \u00e9 um pouco diferente. # c sharp double [,] Notas = new double [ 4 , 5 ]; // 4 linhas e 5 colunas Por ser uma vari\u00e1vel de duas dimens\u00f5es, a maneira como atribu\u00edmos valores \u00e0 cada posi\u00e7\u00e3o \u00e9 um pouco diferente do caso com vetor. Para cada atribui\u00e7\u00e3o de valor, temos que indicar a linha e coluna que nosso dado ser\u00e1 salvo. # c sharp Notas [ 0 , 0 ] = 1 ; // Linha 1 coluna 1 Notas [ 0 , 1 ] = 1 ; // Linha 1 coluna 2 Notas [ 2 , 3 ] = 1 ; // Linha 3 coluna 4 Notas [ 3 , 4 ] = 1 ; // Linha 4 coluna 5 Devemos sempre lembrar que c# usa a posi\u00e7\u00e3o de numeral 0 para o index inicial de vetores e matrizes. Agora vamos ver um programa simples que exemplifica o que acabamos de aprender. A leitura dele n\u00e3o deve ser dif\u00edcil. Se est\u00e1 tendo dificuldade, volte no microfundamento de l\u00f3gica da programa\u00e7\u00e3o. # c sharp int i , j ; int [,] Valor = new int [ 10 , 3 ]; // Loop para entrada de valores na matriz for ( i = 0 ; i < 10 ; i ++ ) // Loop para linhas { for ( j = 0 ; j < 3 ; j ++ ) // Loop para colunas { Console . WriteLine ( $\"Valor Linha:{i+1} Coluna{j+1}\" ); Valor [ i , j ] = int . Parse ( Console . ReadLine ()); } }","title":"Matrizes"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#desafio_1","text":"Para a fixa\u00e7\u00e3o do conceito de matrizes, o professor faz o seguinte desafio: \"Vamos fazer um programa que ir\u00e1 ler os dados de uma matriz de inteiros de ordem 5, ou seja, de dimens\u00f5es 5x5. Matematicamente ela \u00e9 chama de matriz quadrada, porque o n\u00famero de \u201clinhas\u201d \u00e9 igual ao n\u00famero de \u201ccolunas\u201d. Depois de darmos entrada nos valores da matriz chamaremos uma fun\u00e7\u00e3o que, tomando essa matriz como par\u00e2metro, retornar\u00e1 um vetor composto pelos elementos da diagonal principal dessa matriz quando, ent\u00e3o, os listaremos.\" # c sharp // Aqui vai ficar o cogido da solu\u00e7\u00e3o do desafio // quando eu tiver vontade de fazer Vetores e Matrizes s\u00e3o os principais tipos homog\u00eaneos de dados. A partir de agora, estudaremos estruturas que nos permitem alocar valores de tipos diferentes em uma mesma vari\u00e1vel. A compreens\u00e3o correta dos tipos de dados \u00e9 a pedra fundamental do paradigma de desenvolvimento chamado de Programa\u00e7\u00e3o Orientada \u00e0 Objetos .","title":"Desafio"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#estrutura-de-dados-heterogeneas","text":"","title":"Estrutura de Dados Heterog\u00eaneas"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#registros","text":"Na defini\u00e7\u00e3o de um tipo de dado, n\u00f3s definimos precisamente a faixa de valores que podem ser atribu\u00eddos e os m\u00e9todos nativos do tipo de dado. Chamamos de tipo simples de dados os grupos de valores do mesmo tipo (inteiros, reais, string ou booleanos). Por outro lado, chamamos de tipo estruturado de dados os modelos que comportam valores de tipagem diferentes na mesma vari\u00e1vel. Um registro \u00e9 um tipo de dado estruturado. N\u00f3s j\u00e1 estamos familiarizados com as defini\u00e7\u00f5es de vari\u00e1veis em c# para os tipos nativos de dados. # c sharp int x ; double Result ; string Name ; A essa altura do aprendizado, as linhas acima s\u00e3o simples de serem compreendidas. S\u00e3o apenas declara\u00e7\u00f5es do tipos de 3 vari\u00e1veis simples. Mas vejam s\u00f3 o que podemos fazer abaixo. # c sharp Aluno xAlu ; Estranho, n\u00e9?! Estamos declarando a vari\u00e1vel xAlu como sendo do tipo...\"Aluno\"? Sim, \u00e9 isso mesmo! N\u00f3s podemos usar um token dedicado na linguagem para a cria\u00e7\u00e3o de tipos novos de dados que sirvam melhor para solu\u00e7\u00e3o dos problemas que queremos resolver como nosso c\u00f3digo. O token dedicado para constru\u00e7\u00e3o de tipos de dados em c# \u00e9 o struct . Mas para usa-lo bem, temos que aprender os conceitos de tipos de dados heterog\u00eaneos e, no futuro, avan\u00e7aremos para o conceito de classes. O comando struct \u00e9 pensado para o encapsulamento de pequenos conjuntos de vari\u00e1veis relacionadas. No exemplo do tipo Aluno, podemos pensar que todos os alunos devem ter um nome, um cpf e uma data de nascimento, por exemplo. Como essas caracter\u00edsticas se repetem para todos, podemos definir um tipo de dado espec\u00edfico para lidarmos com as informa\u00e7\u00f5es dos alunos.","title":"Registros"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#implementacao-de-um-registro","text":"A cria\u00e7\u00e3o de um tipo de dado \u00e9 simples. Basta definirmos o nome do tipo de dado e declararmos o conjunto de vari\u00e1veis que far\u00e3o parte dele. No exemplo abaixo, n\u00f3s criamos o tipo \"Funcion\u00e1rio\" com as informa\u00e7\u00f5es que ser\u00e3o usadas. # c sharp struct Funcionario { public string CPF ; public string Name ; public double Salary ; public string dataNasc ; } Podemos ver que a declara\u00e7\u00e3o das vari\u00e1veis dentro do bloco de c\u00f3digo est\u00e3o com o token public antes da declara\u00e7\u00e3o do tipo de dado. Isso ocorre porque precisamos dizer ao compilador da linguagem que essas vari\u00e1veis ser\u00e3o acess\u00edveis fora do bloco de c\u00f3digo em que elas s\u00e3o criadas. Isso tem rela\u00e7\u00e3o direta com o conceito de m\u00e9todo e procedimento que aprendemos no curso de Algoritmo e L\u00f3gica Computacional. Agora que temos o nosso novo tipo de dado criado, podemos usar esse recurso para a defini\u00e7\u00e3o de novas vari\u00e1veis. # c sharp static void Main ( string []) args ) { Funcionario xFunc ; xFunc . CPF = \"1234\" ; xFunc . Name = \"Bruce Wanne\" ; xFunc . Salary = 1234 , 33 ; xFunc . dataNasc = \"31/08/1993\" ; } N\u00e3o precisamos nos preocupar com a primeira linha agora. Basta saber que todo programa em c# \u00e9 um procedimento em algum n\u00edvel. Podemos focar apenas no que est\u00e1 dentro dos colchetes. Com o tipo de dado criado. Podemos criar a vari\u00e1vel xFunc e acessar seus par\u00e2metros usando um ponto ap\u00f3s o seu nome. A atribui\u00e7\u00e3o \u00e9 feita como antes mas agora n\u00e3o precisamos declarar os tipos porque eles est\u00e3o definidos dentro do tipo de dado. J\u00e1 aprendemos no come\u00e7o desse microfundamento que a cria\u00e7\u00e3o de vetores (que s\u00e3o listas de elementos do mesmo tipo) s\u00e3o feitas em c# pela adi\u00e7\u00e3o de colchetes vazios na declara\u00e7\u00e3o das vari\u00e1veis. Por exemplo, um vetor de inteiros \u00e9 definido por int[] . Pois bem, podemos usar a mesma l\u00f3gica e criar um vetor do tipo que acabamos de criar 1 . Analogamente, como nosso tipo de dado \u00e9 Funcionario , seu vetor que conter\u00e1 v\u00e1rios funcion\u00e1rios diferentes ser\u00e1 criado por Funcionario[] . # c sharp Funcionario [] xFunc = new Funcionario [ 5 ]; for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( \"CPF do funcion\u00e1rio: \" ); xFunc [ i ]. CPF = Console . readLine (); Console . WriteLine ( \"Nome do funcion\u00e1rio: \" ); xFunc [ i ]. Name = Console . readLine (); Console . WriteLine ( \"Sal\u00e1rio: \" ); xFunc [ i ]. Salary = Console . readLine (); Console . WriteLine ( \"Data de Nascimento: \" ); xFunc [ i ]. dataNasc = Console . readLine (); } Acima, temos a cria\u00e7\u00e3o de um vetor de 5 posi\u00e7\u00f5es onde cada elemento \u00e9 do tipo Funcionario. Logo abaixo, temos um loop para facilitar o preenchimento das informa\u00e7\u00f5es de cada elemento do vetor. Estamos come\u00e7ando a nos aproximar do conceito de banco de dados. Mas n\u00e3o veremos isso agora.","title":"Implementa\u00e7\u00e3o de um Registro"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#tipos-de-dados-aninhados","text":"N\u00e3o precisamos parar por aqui, \u00e9 plenamente poss\u00edvel criarmos um tipo de dados que use outro tipo de dados criado fora dele. Por exemplo, ao inv\u00e9s de salvarmos a data de nascimento como uma string, podemos criar um tipo de dados chamado Data que recebe 3 informa\u00e7\u00f5es: dia, m\u00eas e ano. # c sharp struct Funcionario { public string CPF ; public string Name ; public double Salary ; public Data dataNasc ; } struct Data { public string day ; public string month ; public string year ; } Dentro do tipo funcion\u00e1rio, temos a declara\u00e7\u00e3o de um vari\u00e1vel do tipo data. Para aproveitarmos o c\u00f3digo de cria\u00e7\u00e3o de um vetor Funcionario. Podemos fazer apenas uma pequena altera\u00e7\u00e3o. # c sharp Funcionario [] xFunc = new Funcionario [ 5 ]; for ( int i = 0 ; i < 5 ; i ++ ) { Console . WriteLine ( \"CPF do funcion\u00e1rio: \" ); xFunc [ i ]. CPF = Console . readLine (); Console . WriteLine ( \"Nome do funcion\u00e1rio: \" ); xFunc [ i ]. Name = Console . readLine (); // Parte que foi substitu\u00edda // Console.WriteLine(\"Sal\u00e1rio: \"); // xFunc[i].Salary = Console.readLine(); Console . WriteLine ( \"Data de Nascimento - Dia: \" ); xFunc [ i ]. dataNasc . day = Console . readLine (); Console . WriteLine ( \"Data de Nascimento - M\u00eas: \" ); xFunc [ i ]. dataNasc . month = Console . readLine (); Console . WriteLine ( \"Data de Nascimento - Ano: \" ); xFunc [ i ]. dataNasc . year = Console . readLine (); } A cria\u00e7\u00e3o de tipos eficientes de dados \u00e9 uma ferramenta muito eficiente para padroniza\u00e7\u00e3o e manuten\u00e7\u00e3o de solu\u00e7\u00f5es de software. \u00c9 sempre bom entendermos bem o problema proposto e quais tipos de dados podem ser criados para a cria\u00e7\u00e3o de uma resposta adequada a ele.","title":"Tipos de Dados Aninhados"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#tad-classes-e-implementacao","text":"","title":"TAD, Classes e Implementa\u00e7\u00e3o"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#definicao-de-um-tad-classes-e-objetos","text":"Um tipo abstrato de dado ou TAD \u00e9 um \"padr\u00e3o\" ou \"modelo\" que rege as caracter\u00edsticas que determinada estrutura de dado criada bem como suas fun\u00e7\u00f5es (que chamamos de m\u00e9todos) internas. Ou seja, um TAD \u00e9 a defini\u00e7\u00e3o das informa\u00e7\u00f5es contidas e as opera\u00e7\u00f5es execut\u00e1veis por uma vari\u00e1vel de um determinado modelo. N\u00f3s estamos usando isso o tempo todo sem perceber. Por exemplo, quando usamos a fun\u00e7\u00e3o Math.Pow(a,b) n\u00f3s estamos, na verdade, executando um m\u00e9todo chamamo Pow dentro do objeto Math . Exatamente o mesmo pensamento \u00e9 aplicado ao Console.Write() ou Console.ReadLine() . Agora que estamos avan\u00e7ando mais no nosso conhecimento sobre desenvolvimento de software, come\u00e7amos a entender mais sobre as estruturas que nos permitem realizar os nossos trabalhos, ou no jarg\u00e3o, estamos come\u00e7ando a ver \"de baixo do cap\u00f4\". At\u00e9 agora, n\u00f3s temos definido os nossos TADs atrav\u00e9s da defini\u00e7\u00e3o de sua estrutura (pelo token struct ), mas as linguagens que utilizam o paradigma orientado \u00e0 objeto atuais usam o conceito de classes para defini\u00e7\u00e3o dos seus TADs.","title":"Defini\u00e7\u00e3o de um TAD - Classes e Objetos"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#implementando-tads-usando-classes","text":"J\u00e1 aprendemos a implementar um TAD por estrutura. # c sharp // Definindo o TAD struct Produto { public string Nome ; public double PrecoUnd ; } // Criando uma vari\u00e1vel com TAD Produto xProd ; // Usando o TAD xProd . Nome = \"PS5\" ; xProd . PrecoUnd = 8000.99 ; Podemos construir uma solu\u00e7\u00e3o an\u00e1loga a essa pelo token de cria\u00e7\u00e3o de classes. # c sharp // Definindo o TAD class Produto { public string Nome ; public double PrecoUnd ; } // Criando a classe Produto xProd = new Produto (); // Usando o TAD xProd . Nome = \"Xbox One\" ; xProd . PrecoUnd = 9999.99 ; Em uma primeira vista, parecem ser abordagens equivalentes. Mas existem algumas diferen\u00e7as importantes que merecem a nossa aten\u00e7\u00e3o. Para entender bem a diferen\u00e7a entre essas constru\u00e7\u00f5es, vamos ter que aprender um pouco mais sobre como o computador guarda informa\u00e7\u00f5es. O layout de mem\u00f3ria de programas em C s\u00e3o separados em 5 n\u00edveis : Text segment (instructions) Initializes data segment Uninitialized data segment (bss) Heap Stack (Inline) N\u00f3s n\u00e3o vamos nos atentar muito aos detalhes agora. Mas agora que sabemos um pouco das diferentes aloca\u00e7\u00f5es poss\u00edveis na mem\u00f3ria durante a execu\u00e7\u00e3o de um programa. Podemos focar no que for necess\u00e1rio para diferenciarmos o struct do class . Os valores do tipo struct s\u00e3o alocados na mem\u00f3ria stack. Essa parte de mem\u00f3ria grava temporariamente as vari\u00e1veis criadas por uma fun\u00e7\u00e3o. No stack, as vari\u00e1veis s\u00e3o declaras, guardadas e inicializadas durante a execu\u00e7\u00e3o do programa e apagadas na sua conclus\u00e3o. A mem\u00f3ria \u00e9 alocada em um bloco cont\u00edguos. \u00c9 mais limitada e de r\u00e1pido acesso. Os valores do tipo class s\u00e3o alocados no heap. Essa \u00e9 a parte da mem\u00f3ria usada pelas linguagens de programa\u00e7\u00e3o para suas vari\u00e1veis de escopo global. A mem\u00f3ria \u00e9 alocada de maneira aleat\u00f3ria e \u00e9 mais abundante se comparada com a stack. Sempre que criamos uma nova inst\u00e2ncia como fizemos em Produto xProd = new Produto() n\u00f3s estamos apontando um novo endere\u00e7o de mem\u00f3ria para ser usado.","title":"Implementando TADs usando Classes"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#desafio_2","text":"Cadastrar objetos em um vetor usando uma classe. # c sharp using System ; namespace WorkSpace { // Criando o TAD do tipo class class carro { public string name ; public string marca ; public string anoFab ; public string placa ; public double precoFip ; }; class Program { static void Main ( string [] args ) { // Criando um vetor do tipo carro carro [] cadCarro = new carro [ 3 ]; // Loop para inserir o input no vetor for ( int i = 0 ; i < 2 ; i ++ ) { carro x = new carro (); Console . Write ( $\"\\n Qual o nome? \" ); x . name = Console . ReadLine (); Console . Write ( $\" Qual a marca? \" ); x . marca = Console . ReadLine (); Console . Write ( $\" Qual o ano de fabrica\u00e7\u00e3o? \" ); x . anoFab = Console . ReadLine (); Console . Write ( $\" Qual a placa? \" ); x . placa = Console . ReadLine (); Console . Write ( $\" Qual o pre\u00e7o da tabela FIP? \" ); x . precoFip = double . Parse ( Console . ReadLine ()); // Salvando o x no vetor cadCarro cadCarro [ i ] = x ; }; Console . Clear (); // Mostrando o resultado foreach ( carro C in cadCarro ) { Console . WriteLine ( $\"\\n Carro: {C.name},Marca:{C.marca}\" ); Console . WriteLine ( $\" Placa: {C.placa}, Ano:{C.anoFab}\" ); Console . WriteLine ( $\" Pre\u00e7o da Tabela Fip: {C.precoFip}\" ); }; Console . ReadKey (); } } } \u00c9 muito mais comum se achar situa\u00e7\u00f5es de constru\u00e7\u00e3o de TADs por uso de classes ao inv\u00e9s de estruturas. Vale a pena estudar mais para sabermos exatamente quando cada uma dessas op\u00e7\u00f5es \u00e9 a adequada. Mas no come\u00e7o, as classes nos servir\u00e3o muito bem. Aqui \u00e9 importante frisarmos uma coisa. Quando instanciamos um objeto (ou seja, quando usamos o token new ) o nome que passamos a esse objeto \u00e9 apenas uma refer\u00eancia . Isso quer dizer que, no exemplo acima, cadCarro n\u00e3o \u00e9 o nosso objeto em si e sim uma refer\u00eancia a ele. Alguns de voc\u00eas podem estar questionando o motivo desse aviso. Sabendo que cadCarro n\u00e3o \u00e9 o objeto em si e sim apenas uma refer\u00eancia que aponta para o endere\u00e7o na mem\u00f3ria em que o objeto est\u00e1 salvo, ao criarmos uma nova linha no nosso c\u00f3digo do tipo cadCarro2 = cadCarro estamos criando uma nova refer\u00eancia para o mesmo objeto alocado na mem\u00f3ria. Ou seja, qualquer manipula\u00e7\u00e3o feita usando a refer\u00eancia cadCarro tamb\u00e9m ser\u00e1 refletida em cadCarro2 . Abaixo temos um programa simples que usa essa rela\u00e7\u00e3o de refer\u00eancia. # c sharp using System ; class Program { class carro { public string name ; public string marca ; public string anoFab ; public string placa ; public double precoFip ; }; public static void Main ( string [] args ) { // Criando um vetor do tipo carro carro cadCarro = new carro (); carro cadCarro2 = null ; cadCarro . name = \"carro Nome\" ; cadCarro . marca = \"marca\" ; cadCarro . anoFab = \"2022\" ; cadCarro . placa = \"placa\" ; cadCarro . precoFip = 22.22 ; Console . WriteLine ( $\"{cadCarro.name}\" ); cadCarro2 = cadCarro ; Console . WriteLine ( $\"{cadCarro2.name}\" ); cadCarro2 . name = \"carro nome 2\" ; Console . WriteLine ( $\"{cadCarro.name}\" ); } }","title":"Desafio"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#atributos-propriedades-e-metodos-de-classe","text":"Vamos analisar com calma essas duas cita\u00e7\u00f5es do texto: \"Uma classe especifica uma estrutura de dados e os seus m\u00e9todos operacionais permiss\u00edveis que se aplicam a cada um dos seus objetos\" (MARTIN e ODELL, 1995). \"Um objeto \u00e9 qualquer coisa, real ou abstrata, a respeito da qual armazenamos os dados e os m\u00e9todos que os manipulam\" (MARTIN e ODELL, 1995). Em ambas as cita\u00e7\u00f5es temos as figuras dos dados e dos m\u00e9todos. A estrutura dos dados n\u00f3s j\u00e1 vimos na se\u00e7\u00e3o passada quando lidamos com defini\u00e7\u00e3o de TADs declarando os tipos das vari\u00e1veis tanto na declara\u00e7\u00e3o via estrutura quanto por classe. Agora, vamos expandir um pouco mais o poder dos TADs nos permitindo definir, al\u00e9m das regras de quais dados ser\u00e3o armazenados, quais opera\u00e7\u00f5es e fun\u00e7\u00f5es ser\u00e3o executadas internamente por nossos objetos. Ao construir um tipo abstrato de dados, nos perguntamos quais informa\u00e7\u00f5es ser\u00e3o necess\u00e1rias e, al\u00e9m disso, quais opera\u00e7\u00f5es ser\u00e3o usadas para resolu\u00e7\u00e3o do nosso problema.","title":"Atributos, Propriedades e M\u00e9todos de Classe"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#indo-um-pouco-mais-fundo","text":"Vejamos o seguinte TAD criado apenas com a defini\u00e7\u00e3o da estrutura de dados: # c sharp class pessoa { public string name ; public double salary ; } Dizemos que as informa\u00e7\u00f5es sobre nome e sal\u00e1rio s\u00e3o atributos do nosso objeto pessoa . Eles definem a estrutura do tipo abstrato de dados que definimos. Tamb\u00e9m podemos chama-los de vari\u00e1veis da classe pessoa . Mesmo que o exemplo acima funcione. Uma maneira mais apropriada de reconstruir essa solu\u00e7\u00e3o pode ser vista abaixo. # c sharp class pessoa { private string _name ; public string name { get { return _name ;} set { _name = value ;} } private double _salary ; public double salary { get { return _salary ;} set { _salary = value ;} } } Os campos _name e _salary s\u00e3o definidos com o escopo privado e podem ser acessados somente internamente ao objeto. Para podermos acessar fora do escopo do objeto, usamos as fun\u00e7\u00f5es nativas get e set . Os nomes das fun\u00e7\u00f5es deixam claro o que cada uma faz. set \u00e9 usado para atribui\u00e7\u00e3o de um valor passado (que chamamos de value) e get \u00e9 usado para retorno de valor salvo no objeto. Vamos ver um programa simples que utiliza esses conceitos. # c sharp namespace WorkSpace { class pessoa { private string _name ; public string name { get { return _name ;} set { _name = value ;} } private double _salary ; public double salary { get { return _salary ;} set { _salary = value ;} } }; class Program { static void Main ( string [] args ) { pessoa xpes = new pessoa (); xpes . name = \"Clark Kent\" ; xpes . salary = 1234.56 ; Console . WriteLine ( $\"Nome: {xpes.name}\" ); Console . WriteLine ( $\"Sal\u00e1rio: R$ {xpes.salary}\" ); } } } Na linha xpes.name = \"Clark Kent\" vemos como a fun\u00e7\u00e3o interna set funciona. Ela recebe o valor e atribui \u00e0 vari\u00e1vel provada _name . Quando definimos um atributo privado e fun\u00e7\u00f5es ( get e set ) que manipulam esse atributo dentro da classe, podemos dizer que criamos uma propriedade do objeto. J\u00e1 temos os conceitos de objeto, atributo e propriedade bem definidos. Agora vamos aprender sobre as fun\u00e7\u00f5es dentro de um objeto. A essas fun\u00e7\u00f5es, damos o nome de m\u00e9todos ou servi\u00e7os do objeto . # c sharp class circulo { private double _raio ; public double raio { get { return _raio ; } set { _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Aqui temos um atributo chamado _raio . Uma propriedade chamada raio . E, por fim, temos tamb\u00e9m um m\u00e9todo chamado calcArea . Abaixo temos um exemplo de como usar esses conceitos na pr\u00e1tica. # c sharp namespace WorkSpace { class circulo { private double _raio ; public double raio { get { return _raio ; } set { _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } class Program { static void Main ( string [] args ) { double area ; circulo xcirculo = new circulo (); xcirculo . raio = 2.5 ; area = xcirculo . calcArea (); Console . WriteLine ( $\"A \u00e1rea \u00e9 igual a {area:F2}\" ); Console . ReadKey (); } } } Coment\u00e1rio: Eu n\u00e3o sei voc\u00ea, mas eu fiquei com d\u00favidas sobre essa parte do area:F2 . Isso \u00e9 muito simples. Como o valor area \u00e9 do tipo double, ele possui v\u00e1rias casas ap\u00f3s a v\u00edrgula. Esse par\u00e2metro \u00e9 a defini\u00e7\u00e3o da quantidade de casas ap\u00f3s a v\u00edrgula. Nesse caso, o resultado ter\u00e1 2 casas ap\u00f3s a v\u00edrgula. Quando encapsulamos as propriedades e os m\u00e9todos dentro de um objeto, estamos omitindo os detalhes de como objeto faz as transforma\u00e7\u00f5es e armazena os dados. A essa t\u00e9cnica damos o nome de oculta\u00e7\u00e3o da informa\u00e7\u00e3o . Isso \u00e9 \u00fatil para garantir a integridade da manipula\u00e7\u00e3o dos dados por parte dos usu\u00e1rios e aumenta a seguran\u00e7a quanto a l\u00f3gica implementada no c\u00f3digo. Podemos definir a l\u00f3gica tamb\u00e9m dentro das fun\u00e7\u00f5es de set e get . # c sharp namespace WorkSpace { class circulo { private double _raio ; public double raio { get { return _raio ; } set { if ( value < 0 ) _raio = 0 ; else _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } class Program { static void Main ( string [] args ) { double area ; circulo xcir = new circulo (); xcir . raio = - 2.5 ; area = xcir . calcArea (); Console . WriteLine ( $\"Area: {area:F2}\" ); } } } Desse modo, podemos ver que caso o valor inputado no raio for negativo, o resultado da \u00e1rea ser\u00e1 0. Caso for positivo, o valor da \u00e1rea ser\u00e1 calculado normalmente. Se import\u00e1ssemos esse objeto sem saber o que acontece por dentro dele, n\u00e3o entender\u00edamos o que acontece exatamente dentro do objeto circulo .","title":"Indo um pouco mais fundo"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#mecanismos-de-visibilidadeacessibilidade","text":"Os modificadores de acesso ou mecanismos de visibilidade s\u00e3o os m\u00e9todos de acesso \u00e0s classes e seus, atributos, propriedades e m\u00e9todos. Existem v\u00e1rios tipos de modificadores de acesso ( protected , internal , protected internal e etc), mas por agora, vamos estudar somente o public e o private . Observemos novamente o c\u00f3digo da \u00faltima se\u00e7\u00e3o com algumas anota\u00e7\u00f5es adicionais. # c sharp // Bloco contendo todo o programa namespace WorkSpace { // Defini\u00e7\u00e3o do TAD circulo class circulo { private double _raio ; public double raio { get { return _raio ; } set { if ( value < 0 ) _raio = 0 ; else _raio = value ; } } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } // Bloco contendo o programa class Program { // Procedimento do programa static void Main ( string [] args ) { double area ; circulo xcir = new circulo (); xcir . raio = - 2.5 ; area = xcir . calcArea (); Console . WriteLine ( $\"Area: {area:F2}\" ); } } } Podemos ver que a classe circulo \u00e9 criada antes do bloco que cont\u00e9m o programa propriamente dito. Ou seja, est\u00e3o em escopos diferentes. Desse modo, um comando contido no procedimento Main n\u00e3o tem acesso a nenhuma propriedade ou atributos com o par\u00e2metro private nele somente os de par\u00e2metro public ou atrav\u00e9s das fun\u00e7\u00f5es set e get . Aten\u00e7\u00e3o: Na cria\u00e7\u00e3o da classe circulo n\u00e3o foi dito se ela seria acess\u00edvel fora do seu escopo original, ou seja, n\u00e3o usamos o comando public class circulo e sim o comando class circulo . Em c#, quando se cria uma classe sem a defini\u00e7\u00e3o expl\u00edcita da sua visibilidade, o padr\u00e3o da linguagem \u00e9 deixar a classe como public .","title":"Mecanismos de Visibilidade/Acessibilidade"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#qualidade-e-robustez-de-software","text":"Esses conceitos de controle de acesso s\u00e3o importantes porque nosso c\u00f3digo precisa fazer o que foi planejado, da maneira planejada. Quando n\u00e3o limitamos a capacidade do usu\u00e1rio inserir dados, podemos cair em situa\u00e7\u00f5es n\u00e3o previstas que podem comprometer a execu\u00e7\u00e3o do nosso programa. Um conceito que nos ajuda a entender melhor essa situa\u00e7\u00e3o \u00e9 o robustez do software . Esse conceito \u00e9 usado pelos profissionais de qualidade de software e que \u00e9 referente a capacidade do programa em funcionar da maneira correta em diferentes cen\u00e1rios e condi\u00e7\u00f5es adversas. Outro conceito \u00fatil dessa \u00e1rea \u00e9 o corre\u00e7\u00e3o de software que \u00e9 a qualidade referente a capacidade do nosso programa funcionar da maneira prevista e especificada. A t\u00e9cnica da omiss\u00e3o da informa\u00e7\u00e3o nos ajuda a garantir o cumprimento desses requisitos.","title":"Qualidade e Robustez de Software"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#construtores-e-destrutores-de-classe","text":"Um construtor de classe \u00e9 usado para cria\u00e7\u00e3o de um objeto e pela inicializa\u00e7\u00e3o dos seus atributos. Sempre que instanciamos um objeto, o seu construtor entra em a\u00e7\u00e3o. Coment\u00e1rio: N\u00e3o entraremos a fundo no conceito de Common Language Runtime (CLR) agora. Talvez mais pra frente a gente veja isso. Se um construtor n\u00e3o for declarado explicitamente, o c# cria a classe usando algumas conven\u00e7\u00f5es de modo a colocar o objeto dispon\u00edvel para uso. Esses padr\u00f5es de construtores s\u00e3o definidos de acordo com o tipo primitivo das vari\u00e1veis contidas no nosso objeto (que sabemos que se chamam atributos). Por padr\u00e3o, o CLR atribui os seguintes valores para os atributos dos objetos: 0 para vari\u00e1veis do tipo int, double e float false para vari\u00e1veis booleanas '\\0' para vari\u00e1veis do tipo string","title":"Construtores e Destrutores de Classe"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#definindo-construtores","text":"Para n\u00e3o usarmos as conven\u00e7\u00f5es padr\u00e3o do CLR. Podemos, n\u00f3s mesmo, atribuir os construtores dos atributos dos nossos objetos. Para isso, usamos um m\u00e9todo (ou seja, uma fun\u00e7\u00e3o interna do objeto) com o mesmo nome do objeto . Esse m\u00e9todo n\u00e3o possui retorno e s\u00e3o declarados como public . # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor { _raio = 0 ; } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } A partir de agora, sempre que executarmos um instanciamento atrav\u00e9s do comando # c sharp circulo xcir = new circulo (); O construtor ser\u00e1 chamado e executar\u00e1 as instru\u00e7\u00f5es contidas no construtor. No caso de exemplo, o valor default para o atributo _raio ser\u00e1 0. N\u00e3o \u00e9 dif\u00edcil pensar em situa\u00e7\u00f5es onde precisar\u00edamos usar diferentes m\u00e9todos de constru\u00e7\u00e3o em um objeto. Para isso, podemos ter mais de um construtor no mesmo objeto, chamamos isso de sobrecarregamento . A condi\u00e7\u00e3o \u00e9 que esses construtores sejam diferentes em termos de par\u00e2metros ou ordem dos par\u00e2metros. # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor { _raio = 0 ; } public circulo ( int R ) { _raio = R ; } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Para executar o segundo construtor, basta passarmos um par\u00e2metro no momento do instanciamento do nosso novo objeto. # c sharp circulo xcirc = new circulo ( 2.3 ); Como fizemos um instanciamento com valor, o c# saber\u00e1 que queremos usar o segundo construtor ao inv\u00e9s do primeiro.","title":"Definindo Construtores"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#destrutores","text":"Ao contr\u00e1rio do que podemos pensar pelo nome, os destrutores n\u00e3o s\u00e3o usados para \"destruir\" os objetos. Eles s\u00e3o usados definir um comportamento espec\u00edfico no momento da destrui\u00e7\u00e3o de um objeto. Ou seja, eles s\u00e3o acionados na destrui\u00e7\u00e3o e n\u00e3o s\u00e3o os destruidores. N\u00e3o precisam ser chamados ou referenciados pois s\u00e3o invocados automaticamente. O normal \u00e9 n\u00e3o se usar destrutores no dia a dia visto que o CLR j\u00e1 faz o trabalho de padroniza\u00e7\u00e3o para elimina\u00e7\u00e3o de um objeto. Diferente dos construtores, uma classe pode ter apenas um destrutor . E a sua cria\u00e7\u00e3o \u00e9 parecida com a do construtor, uma vez que s\u00e3o m\u00e9todos sem retorno. A \u00fanica diferen\u00e7a \u00e9 que sua nota\u00e7\u00e3o come\u00e7a com o til. # c sharp [...] // C\u00f3digo com o namespasce class circulo { private double _raio ; public double raio { get { return _raio ;} set { _raio = value ;} } public circulo () // construtor 1 { _raio = 0 ; } public circulo ( int R ) // construtor 2 { _raio = R ; } ~ circulo { Console . WriteLine ( \"Adeus, mundo cruel!\" ); } public double calcArea () { return Math . PI * Math . Pow ( _raio , 2 ); } } Os detalhes de como um computador funciona s\u00e3o estudados em Estrutura de Computadores mas, para adiantar, algumas linguagens tem um programa chamado garbage colector que \u00e9 respons\u00e1vel pela reutiliza\u00e7\u00e3o de slots de mem\u00f3ria que est\u00e3o sendo usados por objetos que n\u00e3o tem mais utiliza\u00e7\u00e3o no c\u00f3digo. Em c# n\u00f3s n\u00e3o precisamos explicitamente eliminar um objeto porque o pr\u00f3prio garbage colector faz esse trabalho.","title":"Destrutores"},{"location":"nav/PUC/eixo1/algoritmos_e_abstracao/#bibliografia","text":"ASCENCIO, Ana Fernanda Gomes; CAMPOS, Edilene Aparecida Veneruchi de. Fundamentos da programa\u00e7\u00e3o de computadores . S\u00e3o Paulo: Pearson, 2012. ISBN 9788564574168 SOUZA, Marco A. Furlan de; GOMES, Marcelo Marques; SOARES, Marcio Vieira; CONC\u00cdLIO, Ricardo. Algoritmos e l\u00f3gica de programa\u00e7\u00e3o: um texto introdut\u00f3rio para a engenharia . S\u00e3o Paulo: Cengage Learning, 2019. ISBN: 9788522128150 AGUILAR, Luis Joyanes. Fundamentos de programa\u00e7\u00e3o algoritmos, estruturas de dados e objetos . 3. ed. Porto Alegre: AMGH, 2008. ISBN: 9788580550146 DEITEL, Harvey M; DEITEL, Paul J. Java - como programar . 8. ed. S\u00e3o Paulo: Pearson, 2010. ISBN 9788576055631 GRIFFITHS, Ian. Programming C# 8.0 . O'Reilly Media, Inc. 2019. ISBN 9781492056812 MANZANO, Jos\u00e9 Augusto N. G; OLIVEIRA, Jayr Figueiredo de. Algoritmos: l\u00f3gica para desenvolvimento de programa\u00e7\u00e3o de computadores . 28. ed. rev. e atual. S\u00e3o Paulo, SP: \u00c9rica, 2016. E-book. ISBN 9788536518657 PRICE, Mark J. C# 8.0 and T Core 3.0 - Modern Cross - Platform Development . O'Reilly Media; 2019. ISBN 9781788478120 PUGA, Sandra; RISSETTI, Gerson. L\u00f3gica de programa\u00e7\u00e3o e estruturas de dados com aplica\u00e7\u00f5es em Java . 2. ed. S\u00e3o Paulo: Prentice Hall, 2009. ISBN 9788576052074 Isso \u00e9 muito legal! \u21a9","title":"Bibliografia"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/","text":"hljs.initHighlightingOnLoad(); Assuntos L\u00f3gica de Programa\u00e7\u00e3o e Estrutura de Controle, Fun\u00e7\u00f5es e Procedimentos Conceito de Algoritmo Vari\u00e1veis Etapas de um Algoritmo e Operador de Atribui\u00e7\u00e3o Estrutura Sequencial Estrutura Condicional Estrutura de Repeti\u00e7\u00e3o Manipula\u00e7\u00e3o de Dados em Mem\u00f3ria Prim\u00e1ria e Secund\u00e1ria Criando e Usando Fun\u00e7\u00f5es e Procedimentos Passagem de Par\u00e2metros Manipula\u00e7\u00e3o de Arquivos em C# Bibliografia L\u00f3gica de Programa\u00e7\u00e3o e Estrutura de Controle, Fun\u00e7\u00f5es e Procedimentos Conceito de Algoritmo Em resumo, um algoritmo \u00e9 uma sequ\u00eancia de ordens que, se seguidas, deve gerar um resultado previsto e desejado. N\u00e3o vale muito a pena aprofundar al\u00e9m disso agora. Vari\u00e1veis Uma vari\u00e1vel \u00e9 uma posi\u00e7\u00e3o na mem\u00f3ria do computador. Isso mesmo, \u00e9 algo com endere\u00e7o definido, nada solto no universo ou obscuro dentro da m\u00e1quina. Esse dado \u00e9 gravado para posterior leitura por parte do programa que est\u00e1 sendo executado. Podemos ter como origem do dado o pr\u00f3prio programa que est\u00e1 sendo executado ou o usu\u00e1rio por meio da entrada de dados ou, ainda, a leitura de dados previamente armazenados na mem\u00f3ria do computador. Cada vari\u00e1vel possui v\u00e1rios tipos de atributos que podemos elencar na lista abaixo: Tem um endere\u00e7o na mem\u00f3ria Possui um nome de identifica\u00e7\u00e3o Armazena um valor Possui um tipo de dados: Num\u00e9rico - Inteiros e Reais (Double ou Ponto Flutuante) 1 N\u00e3o num\u00e9rico - L\u00f3gico e Caractere Arranjos - Vetores e Matrizes Arquivos etc O endere\u00e7o da mem\u00f3ria \u00e9 feita pelos endere\u00e7os que possuem apenas 2 est\u00e1gios de registro: 0 ou 1. Um bit \u00e9 exatamente essa medida de registo. 1 byte \u00e9 composto de 8bits. 1 kilobyte cont\u00e9m 1024bytes ( \\(2^{10}\\) ). 1 megabyte cont\u00e9m 1024KB ( \\(2^{20}\\) ). 1 gigabyte cont\u00e9m 1024MB ( \\(2^{30}\\) ). 1 terabyte possui 1024GB ( \\(2^{40}\\) ). Ou seja, se um computador possui 3 gigas de mem\u00f3ria RAM, ele tem 3 bilh\u00f5es de bytes como endere\u00e7os dispon\u00edveis para um registro na mem\u00f3ria 2 . Cada byte possui um endere\u00e7o \u00fanico. Na mem\u00f3ria RAM costuma-se usar a base Hexadecimal para definir os endere\u00e7os. Vamos ver isso melhor na mat\u00e9ria de Arquitetura de Computadores. Tamb\u00e9m vimos que as vari\u00e1veis possuem identificadores. Em c# existem regras para a cria\u00e7\u00e3o dos identificadores: Devem come\u00e7ar com uma letra N\u00e3o podem ter espa\u00e7os N\u00e3o podem usar uma das palavras reservadas pela linguagem \u00c9 case sensitive, ou seja, o nome \"Var\" \u00e9 diferente do nome \"var\" O identificador deve sempre ter algum sentido que permita a r\u00e1pida interpreta\u00e7\u00e3o por parte de algum leitor do c\u00f3digo fonte da aplica\u00e7\u00e3o. Isso \u00e9 fundamental para manuten\u00e7\u00e3o de c\u00f3digos produzidos por v\u00e1rias pessoas diferentes. Entretanto, devemos evitar nomes de vari\u00e1veis muito grandes. Na verdade, quanto menor o nome, mantido o sentido na leitura, melhor. Outra boa pr\u00e1tica \u00e9 usar o camelCase para vari\u00e1veis com mais de uma palavra. Esse padr\u00e3o \u00e9 bem simples: primeira palavra em min\u00fasculo e a segunda com a primeira letra em mai\u00fascula. Declara\u00e7\u00e3o de Vari\u00e1veis em c# Vamos aprender agora como declarar os 4 tipos mais simples de vari\u00e1veis: int para definir inteiros double ou float para definir n\u00fameros reais string para cadeia de caracteres bool para as vari\u00e1veis booleanas ( true ou false ) Coment\u00e1rio: c# \u00e9 uma linguagem fortemente tipada, entretanto, existe um tipo de tipagem impl\u00edcita que \u00e9 muito usado na pr\u00e1tica onde o pr\u00f3prio compilador \"interpreta\" o tipo de vari\u00e1vel. Ao longo desse microfundamento n\u00f3s vamos usar apenas os tokens de tipagem expl\u00edcita. Mas vale muito a pena a leitura da documenta\u00e7\u00e3o oficial nesse link . # c sharp static void Main ( string [] args ) { int idade , numero ; double peso , salario ; string nomePai , rua , dtNasc ; bool temCasa ; } Nesse c\u00f3digo acima temos a declara\u00e7\u00e3o de v\u00e1rias vari\u00e1veis de cada tipo. Basta colocar o tipo da vari\u00e1vel seguido do nome de cada uma delas separadas por v\u00edrgula. Coment\u00e1rio: Em c# todas as linhas precisam conter um car\u00e1cter de encerramento que \u00e9 o ponto e v\u00edrgula ; . Sem esse token, o computador vai interpretar a pr\u00f3xima linha como sendo a continua\u00e7\u00e3o da anterior. Etapas de um Algoritmo e Operador de Atribui\u00e7\u00e3o Podemos resumir um algoritmo simples como contendo apenas 3 etapas: 1) A entrada de dados; 2) O processamento e 3) A sa\u00edda de dados. Na etapa de processamento, podemos precisar de grande criatividade e esfor\u00e7o para produzir a sa\u00edda de dados desejada. Como ferramenta para alcance desse objetivo, temos as estruturas b\u00e1sicas que s\u00e3o: Estrutura Sequencial - Usada para garantir a ordem correta dos passos Estrutura Condicional - Usada para permitir contexto ou cen\u00e1rios Estrutura de Repeti\u00e7\u00e3o - Usada para evitar repetir c\u00f3digo sequencial Operador de Atribui\u00e7\u00e3o Uma vez que j\u00e1 sabemos como atribuir uma vari\u00e1vel ao seu tipo, precisamos aprender a como atribuir um valor a essas vari\u00e1veis. Em c# a atribui\u00e7\u00e3o de valor \u00e9 feita do seguinte modo: # c sharp idade = 28 ; numero = 9992233 ; \u00c9 poss\u00edvel fazer 3 tipos de atribui\u00e7\u00e3o de valor para uma vari\u00e1vel: Valor fixo; Conte\u00fado de outra vari\u00e1vel e Express\u00e3o aritm\u00e9tica ou booliana. Abaixo temos 3 exemplo disso. # c sharp idade = 28 ; // Valor fixo numero = idade ; // Valor de outra vari\u00e1vel idadeNum = idade + numero ; // Valor por express\u00e3o idadeEqNum = idade == numero ; // Valor por express\u00e3o booliana Nesse ponto vale uma reflex\u00e3o. Ser\u00e1 que sempre precisamos separar as etapas de atribui\u00e7\u00e3o do tipo de dados e do valor? Ou podemos, no mesmo momento, definir o tipo de dados e o valor da vari\u00e1vel? A resposta, para nossa sorte, \u00e9 que \u00e9 poss\u00edvel em c# atribui\u00e7\u00e3o de tipo e valor ao mesmo tempo. A sintaxe fica desse modo: # c sharp int idade = 28 ; int numero = idade ; double = 2.3 ; string nome = \"bruno\" ; int idadeNum = idade + numero ; bool idadeEqNum = idade == numero ; Sa\u00eddas de Dados Agora que fizemos esse pequeno desvio no assunto, vamos retornar para as estruturas. Por incr\u00edvel que pare\u00e7a, \u00e9 melhor a gente come\u00e7ar pelo final. A etapa de sa\u00edda de dados. Em c# temos duas maneiras de sa\u00edda de dados: # c sharp // Imprime a informa\u00e7\u00e3o e cursor fica na mesma linha Console . Write ( ' string ' ); // Imprime a info mas o curso vai pra proxima linha Console . WriteLine ( ' string ' + var1 + ' string ' ); Nesses exemplos a gente pode perceber que podemos concatenar textos e vari\u00e1veis textuais por meio do operador de soma. Al\u00e9m dessa forma, podemos fazer uso de PlaceHolders ou Interpola\u00e7\u00e3o de string como nos exemplos abaixo. # c sharp string nome = \"Bruno\" ; // Concatena\u00e7\u00e3o Console . WriteLine ( \"Meu nome \u00e9 \" + nome + \", obrigado!\" ); // PlaceHolder Console . WriteLine ( \"Meu nome \u00e9 {0}, obrigado!\" , nome ); // Interpola\u00e7\u00e3o Console . WriteLine ( $\"Meu nome \u00e9 {nome}, obrigado!\" ); Os tr\u00eas exemplos geram o mesmo resultado mas s\u00e3o consideravelmente diferentes no m\u00e9todo. Podemos usar o que for mais agrad\u00e1vel para uma leitura do c\u00f3digo e posterior manuten\u00e7\u00e3o do mesmo. Entrada de Dados Agora que sabemos como fazer nosso programa imprimir resultados, vamos aprender como inputar dados nele. Em c# podemos inserir dados com o seguinte comando: # c sharp variavel = Console . ReadLine (); O input captado por esse comando sempre retorna uma string . Mas as vezes precisamos nos certificar que o input foi feito da maneira correta. Para isso podemos manipular os dados inseridos do seguinte modo: # c sharp // Valores Inteiros variavel = int . Parse ( Console . ReaLine ()); variavel = Convert . ToInt32 ( Console . ReadLine ()); // Valores Reais variavel = double . Parse ( Console . ReadLine ()); variavel = float . Parse ( Console . ReadLine ()); variavel = Convert . ToDouble ( Console . ReadLine ()); // Valores Booleanos variavel = bool . Parse ( Console . ReadLine ()); // Valores String variavel = Console . ReadLine (); Depois que executamos um dessas maneiras de coletar os dados, \u00e9 de boa pr\u00e1tica fornecermos um output logo ap\u00f3s a entrada do dado. Isso evita aquela sensa\u00e7\u00e3o de d\u00favida se o programa est\u00e1 sendo executado ou n\u00e3o. Ou seja, \u00e9 bom sempre manter a dupla ReadLine() com o WriteLine() . O nome que damos para essa dupla \u00e9 \"Prompt\". Outra dica boa \u00e9 usar o comando Console.ReadKey() no final do programa. Isso faz com que o console aguarde alguma tecla para finalizar. Evita que a aplica\u00e7\u00e3o abra e feche sem que o user consiga enxergar o resultado do processo. Estrutura Sequencial Agora que sabemos como receber valores do usu\u00e1rio e como devolver nova informa\u00e7\u00e3o a partir do processamento, vamos come\u00e7ar a estudar a etapa de processamento atrav\u00e9s do estudo das estruturas sequenciais. Operadores e Fun\u00e7\u00f5es Aritm\u00e9ticas Em c# n\u00f3s temos os seguintes tokens para realizar as opera\u00e7\u00f5es aritm\u00e9ticas: + Soma - Subtra\u00e7\u00e3o * Multiplica\u00e7\u00e3o / Divis\u00e3o % Resto da Divis\u00e3o inteira Al\u00e9m disso, temos a presen\u00e7a do que podemos chamar de operadores de atribui\u00e7\u00e3o combinada . Que faz a atribui\u00e7\u00e3o de valor com alguma opera\u00e7\u00e3o aritm\u00e9tica: soma += 100 \u00e9 igual a soma = soma + 100 subtracao -= 10 \u00e9 igual a subtracao = subtracao - 10 multiplica *= 2 \u00e9 igual a multiplica = multiplica * 2 divide /= 3 \u00e9 igual a divide = divide / 3 resto \\%= 2 \u00e9 igual a resto = resto / 2 N\u00e3o bastando essa grande variedade, temos os operadores de incremento e decremento : Pr\u00e9-incremento ( ++x ) - Usa x + 1 antes do processamento P\u00f3s-incremento ( x++ ) - Usa x + 1 ap\u00f3s o processamento Pr\u00e9-decr\u00e9scimo ( --x ) - Usa x - 1 antes do processamento P\u00f3s-decr\u00e9scimo ( x-- ) - Usa x -1 ap\u00f3s o processamento Essa diferen\u00e7a de pre e p\u00f3s \u00e9 importante para as estruturas de repeti\u00e7\u00e3o, porque podemos lidar com \u00edndices de tabelas que come\u00e7am com valores diferentes. Mas, no geral, devemos olhar cada caso para escolher o que usar. Existem outras opera\u00e7\u00f5es que est\u00e3o contidas em um objeto nativo chamado Math . Para fazermos potencia\u00e7\u00e3o usamos o m\u00e9todo Math.Pow() . Para fazermos raiz quadrada podemos usar Math.Sqrt() 3 . Express\u00f5es Aritm\u00e9ticas Agora podemos juntar tudo que vimos em um programa simples de c\u00e1lculo da m\u00e9dia de 5 valores. O c\u00f3digo e o seu resultado podem ser vistos abaixo. # c sharp // Declara\u00e7\u00e3o dos tipos das vari\u00e1veis int n1 , n2 , n3 , n4 , n5 , soma ; float media ; // Input dos dados Console . WriteLine ( \"Programa para c\u00e1lculo da m\u00e9dia de 5 valores.\" ); Console . WriteLine ( \"Por favor, forne\u00e7a o primeiro n\u00famero\" ); n1 = Convert . ToInt32 ( Console . ReadLine ()); Console . WriteLine ( \"Por favor, forne\u00e7a o segundo n\u00famero\" ); n2 = Convert . ToInt32 ( Console . ReadLine ()); Console . WriteLine ( \"Por favor, forne\u00e7a o terceiro n\u00famero\" ); n3 = Convert . ToInt32 ( Console . ReadLine ()); Console . WriteLine ( \"Por favor, forne\u00e7a o quarto n\u00famero\" ); n4 = Convert . ToInt32 ( Console . ReadLine ()); Console . WriteLine ( \"Por favor, forne\u00e7a o quinto n\u00famero\" ); n5 = Convert . ToInt32 ( Console . ReadLine ()); // Processamento soma = n1 + n2 + n3 + n4 + n5 ; media = soma / 5 ; // Output dos dados Console . WriteLine ( \"Os n\u00fameros fornecidos foram:\" ); Console . WriteLine ( \"N1={0},N2={1},N3={2},N4={3},N5={4}\" , n1 , n2 , n3 , n4 , n5 ); Console . WriteLine ( \"Cuja m\u00e9dia \u00e9 igual a {0}\" , media ); Outro exemplo que podemos usar \u00e9 o do c\u00e1lculo das ra\u00edzes de uma fun\u00e7\u00e3o de segundo grau 4 . O programa abaixo recebe 3 valores e calcula as ra\u00edzes, a imagem logo ap\u00f3s nos mostra o resultado no prompt de comando. # c sharp // Programa para calcular o valor de x em uma equa\u00e7\u00e3o de segundo grau // Declara\u00e7\u00e3o das vari\u00e1veis double a , b , c , x1 , x2 ; Console . WriteLine ( \"Vamos resolver uma equa\u00e7\u00e3o do tipo ax^2 + bx + c = 0\" ); // Input das variaveis Console . WriteLine ( \"Qual o valor de a? \" ); a = Convert . ToDouble ( Console . ReadLine ()); Console . WriteLine ( \"Qual o valor de b? \" ); b = Convert . ToDouble ( Console . ReadLine ()); Console . WriteLine ( \"Qual o valor de c? \" ); c = Convert . ToDouble ( Console . ReadLine ()); x1 = ( - b + Math . Sqrt ( Math . Pow ( b , 2 ) - 4 * a * c )) / 2 * a ; x2 = ( - b - Math . Sqrt ( Math . Pow ( b , 2 ) - 4 * a * c )) / 2 * a ; // Output dos resultados Console . WriteLine ( \"Dados: a = {0}, b = {1} e c = {2}\" , a , b , c ); Console . WriteLine ( $\"Equa\u00e7\u00e3o: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0\" ); Console . WriteLine ( \"Resultado: x1 = {0} e x2 = {1}\" , x1 , x2 ); A essa altura j\u00e1 aprendemos como criar programas inteiros com as etapas de software que vimos anteriormente: input, processamento e output. Tudo isso em c#. Entretanto, no estado atual do c\u00f3digo, nossos programas n\u00e3o est\u00e3o muito competentes em se adaptar a diferentes tipos de inputs ou resultados. Um exemplo pr\u00e1tico \u00e9 que, nesse segundo programa, podemos ter inputs que retornem um resultado indesejado como podemos ver na imagem abaixo. Estrutura Condicional A necessidade de lidarmos com diferentes situa\u00e7\u00f5es ou contextos \u00e9 o que nos leva a estudarmos as \\textbf{} estruturas condicionais . Por meio dessas estruturas, podemos construir diferentes outputs de acordo com qualquer l\u00f3gica que implementarmos e, com isso, evitar v\u00e1rios bugs nos nossos programas. Operadores Relacionais Ao lidarmos com estrutura condicionais n\u00f3s temos alguns operadores que nada mais s\u00e3o do que express\u00f5es l\u00f3gicas que retornam apenas 2 resultados poss\u00edveis: true ou false. Esses operadores s\u00e3o como \"gatilhos\"\\ que s\u00e3o usados para controle do fluxo de processamento do c\u00f3digo. Operador Opera\u00e7\u00e3o Exemplo == Igualdade n1 == n2 < Menor a < 10 > Maio b > 1 <= Menor igual c <= 2 >= Maior igual d >= 22 != Desigualdade e != 100 Na tabela acima, temos os operadores relacionais que s\u00e3o usados ao longo das estruturas condicionais simples e compostas. Tome cuidado com o operador de igualdade == e o de atribui\u00e7\u00e3o = , afinal, eles usam o sinal de igualdade mas significam coisas diferentes. Condi\u00e7\u00e3o Simples e Composta Em c# o comando usado para criar uma condi\u00e7\u00e3o simples \u00e9 o if . Se a condi\u00e7\u00e3o que colocarmos atrelada ao comando if retornar um true, o bloco de c\u00f3digo atribu\u00eddo a ele ser\u00e1 executar, caso contr\u00e1rio, o c\u00f3digo do bloco ser\u00e1 ignorado. # c sharp // Parte condicional no calculo da equa\u00e7\u00e3o de segundo grau delta = ( Math . Pow ( b , 2 ) - 4 * a * c ); // Output dos resultados com condi\u00e7\u00e3o if ( delta >= 0 ) { Console . WriteLine ( \"Dados: a = {0}, b = {1} e c = {2}\" , a , b , c ); Console . WriteLine ( $\"Equa\u00e7\u00e3o: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0\" ); Console . WriteLine ( $\"Delta: {delta}\" ); Console . WriteLine ( \"Resultado: x1 = {0} e x2 = {1}\" , x1 , x2 ); }; if ( delta < 0 ) { Console . WriteLine ( \"Dados: a = {0}, b = {1} e c = {2}\" , a , b , c ); Console . WriteLine ( $\"Equa\u00e7\u00e3o: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0\" ); Console . WriteLine ( $\"Delta: {delta}\" ); Console . WriteLine ( \"Resultado: X n\u00e3o possui raiz real! \" ); }; Com essa adapta\u00e7\u00e3o, nosso c\u00f3digo estar\u00e1 preparado para o caso onde o interior da raiz (que chamamos de delta) seja negativo. Mas podemos ver que o nosso c\u00f3digo ficou um pouco esquisito. Criamos dois blocos de c\u00f3digo que s\u00e3o, claramente, relacionados entre si: Se um bloco for executado, o outro n\u00e3o ser\u00e1. Para facilitar o trabalho com essas situa\u00e7\u00f5es, as linguagens de programa\u00e7\u00e3o possuem as estruturas de condi\u00e7\u00e3o compostas. Esses s\u00e3o os casos onde, se o teste l\u00f3gico retorna true, executamos um bloco, ou o outro bloco ser\u00e1 executado caso o resultado l\u00f3gico seja false. Com isso evitamos ter que criar dois testes com if . O token usado em c# para uma condi\u00e7\u00e3o com dois blocos de c\u00f3digos (ou seja, uma condicional composta) \u00e9 o if-else . Abaixo n\u00f3s reescrevemos a solu\u00e7\u00e3o anterior mas agora fazendo uso do condional composto. # c sharp // Parte condicional no calculo da equa\u00e7\u00e3o de segundo grau delta = ( Math . Pow ( b , 2 ) - 4 * a * c ); // Output dos resultados com condi\u00e7\u00e3o if ( delta >= 0 ) { Console . WriteLine ( \"Dados: a = {0}, b = {1} e c = {2}\" , a , b , c ); Console . WriteLine ( $\"Equa\u00e7\u00e3o: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0\" ); Console . WriteLine ( $\"Delta: {delta}\" ); Console . WriteLine ( \"Resultado: x1 = {0} e x2 = {1}\" , x1 , x2 ); } else { Console . WriteLine ( \"Dados: a = {0}, b = {1} e c = {2}\" , a , b , c ); Console . WriteLine ( $\"Equa\u00e7\u00e3o: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0\" ); Console . WriteLine ( $\"Delta: {delta}\" ); Console . WriteLine ( \"Resultado: X n\u00e3o possui raiz real! \" ); }; Agora sim nosso c\u00f3digo est\u00e1 elegante e adaptado para as duas sa\u00eddas poss\u00edveis de resultado para os inputs do usu\u00e1rio. Operadores Booleanos e Comandos IF Aninhados N\u00f3s aprendemos que o bloco de c\u00f3digo ser\u00e1 executado sempre que a express\u00e3o l\u00f3gica retornar um resultado true. Tamb\u00e9m vimos que existem os operadores relacionais que nos ajudam a construir essas express\u00f5es. Agora, vamos aprender os operadores booleanos que nada mais s\u00e3o do que os operadores l\u00f3gicos cl\u00e1ssicos ( \\(\\land, \\lor, \\neg\\) ). Operador Opera\u00e7\u00e3o Exemplo && (AND) true se tudo for true if (a > 2 && b == 1) || (OR) true se um for true if (a < 2 || b != 0) ! (NOT) false se true if (!(x==y)) Existem problemas que requerem mais de dois resultados no output. Nesse caso, n\u00e3o \u00e9 suficiente usarmos apenas os tokens de condicional composto if-else da maneira como aprendemos at\u00e9 agora. Para resolver esse problema temos a t\u00e9cnica de IF aninhados (nested) e a de IF escada (ladder). As duas formas produzem o mesmo resultado mas mudam significativamente legibilidade do nosso c\u00f3digo. Abaixo temos um exemplo de cada. # c sharp // Leadder IF if ( condicao1 ) comando1 ; else if ( condicao2 ) comando2 ; else if ( condicao3 ) comando3 ; ... else if ( condicao_n - 1 ) comando_n - 1 ; else comando_n ; # c sharp // Nested IF if ( condicao1 ) comando1 ; else if ( condicao2 ) comando2 ; else if ( condicao3 ) comando3 ; else if ( condicao4 ) comando4 ; ... else if ( condicao_n - 1 ) comando_n - 1 ; else comando_n ; O Comando Switch e o Operador Tern\u00e1rio Agora que aprendemos a lidar com v\u00e1rios casos condicionais encadeados, podemos construir solu\u00e7\u00f5es relativamente complexas com v\u00e1rias sa\u00eddas diferentes. Entretanto, quando tempos muitas situa\u00e7\u00f5es poss\u00edveis, o nosso c\u00f3digo pode ficar um pouco ruim de ser lido por outras pessoas. Pensando nessa necessidade, os criadores do c# criaram um operador que simplifica ainda mais nosso trabalho. Sim, \u00e9 isso mesmo, n\u00f3s acabamos de aprender IFs aninhados e em escada e j\u00e1 vamos aprender uma maneira melhor de fazer exatamente o que eles fazem. Se acostume com isso. Em tecnologia existem quase sempre v\u00e1rias maneiras de se chegar no mesmo resultado. O operador que \u00e9 mais indicado para lidar com v\u00e1rias situa\u00e7\u00f5es de sa\u00edda \u00e9 o switch-case . Cuja constru\u00e7\u00e3o \u00e9 bem mais leg\u00edvel que os IFs anteriores. Abaixo temos um exemplo. # c sharp // Lidando com varias condi\u00e7\u00f5es com switch/case switch ( opcao ) { case op1 : comandos1 ; break ; case op2 : comandos2 ; break ; case op3 : comandos3 ; break ; ... case op_n : comandos_n ; break ; default : // bloco que sera executado se nenhuma // das anteriores for escolhida; } \\textbf{} Coment\u00e1rio: Existem v\u00e1rias maneiras de se usar o switch. Eu n\u00e3o vou me aprofundar agora em todas elas. Mas vale muito a pena fazer uso dessa ferramenta para cen\u00e1rios de v\u00e1rias intera\u00e7\u00f5es poss\u00edveis ou m\u00faltiplas sa\u00eddas contextuais. Para finalizar o nosso estudo das estruturas condicionais, vamos aprender como trabalhar com o \\textbf{} Operador tern\u00e1rio . Esse nome \u00e9 relativo ao n\u00famero de operandos que esse comando usa (no caso, 3). # c sharp condicao ? expressao_true : expressao_false A condi\u00e7\u00e3o \u00e9 uma express\u00e3o l\u00f3gica (que usa operadores relacionais e booleanos) que s\u00f3 pode retornar true ou false. A express\u00e3o logo ap\u00f3s o ponto de interroga\u00e7\u00e3o ser\u00e1 o retorno do operador em caso de true. A express\u00e3o ap\u00f3s os dois pontos \u00e9 o retorno em caso de false. Sim, \u00e9 exatamente um caso de if-else s\u00f3 que em apenas uma linha. Como as solu\u00e7\u00f5es podem ficar muito grandes, \u00e9 sempre bom termos em mente que quanto menos linhas, mais f\u00e1cil ser\u00e1 fazer manuten\u00e7\u00e3o nos nossos programas. O operador tern\u00e1rio \u00e9 muito usado por programadores mais experientes. Abaixo temos um exemplo comparando as duas maneiras. # c sharp // Compara\u00e7\u00e3o entre if-else e operador tern\u00e1rio bool passou ; double nota ; // if-else if ( nota >= 60 ) passou = true ; else passou = false ; // operador ternario passou = nota >= 60 ? true : false // maneira 1 passou = ( nota >= 60 ) ? true : false // maneira 2 Agora podemos ver claramente a vantagem do uso do operador tern\u00e1rio. Estrutura de Repeti\u00e7\u00e3o Como sabemos, ainda temos mais um tipo de estrutura para estudarmos. At\u00e9 agora, aprendemos como estruturar um c\u00f3digo sequencialmente e como criar blocos de c\u00f3digo que s\u00f3 ser\u00e3o executados se determinadas condi\u00e7\u00f5es previamente definidas forem satisfeitas. Agora, vamos aprender como evitar ter que repetir blocos de c\u00f3digos. O c# possui 3 operadores de repeti\u00e7\u00e3o: # c sharp // tipo 01 while ( condicao ) comando ; // tipo 02 do comando ; while ( condicao ); // tipo 03 for ( inicial ; expressao logica ; atualizacao ) comando ; Vamos ver um exemplo de como nosso c\u00f3digo pode ser reduzir com o uso da estrutura de repeti\u00e7\u00e3o. Primeiro, vamos ver um exemplo onde o programa recebe uma lista de 3 palavras (nome, nome do meio e sobrenome) e depois faz o print. # c sharp // Programa que recebe nome completo e // depois devolve uma mensagem de boas vindas string nome , mid , last ; Console . WriteLine ( \" Seja bem vindo(a)!\" ); Console . WriteLine ( \" Qual seu primeiro nome?\" ); nome = Console . ReadLine (); Console . WriteLine ( \" Qual seu nome do meio?\" ); mid = Console . ReadLine (); Console . WriteLine ( \" Qual seu sobrenome?\" ); last = Console . ReadLine (); Console . WriteLine ( \" Bem Vindo(a)!\" ); Console . WriteLine ( nome ); Console . WriteLine ( mid ); Console . WriteLine ( last ); Console . WriteLine ( \" E Volte sempre!\" ); Agora vamos refazer esse programa usando os 3 tokens de estrutura de repeti\u00e7\u00e3o que o c# nos d\u00e1. Vamos usar a mesma ordem em que elas foram apresentadas. Os Comandos WHILE, DO WHILE e FOR Repeti\u00e7\u00e3o usando WHILE A repeti\u00e7\u00e3o usando o token while \u00e9 condicionada ao resultado de uma express\u00e3o l\u00f3gica. Caso a express\u00e3o l\u00f3gica retorne true, o bloco de c\u00f3digo ser\u00e1 executado at\u00e9 o seu final. Ap\u00f3s a execu\u00e7\u00e3o, \u00e9 feita uma nova verifica\u00e7\u00e3o da express\u00e3o l\u00f3gica. O processo de loop s\u00f3 ser\u00e1 finalizado caso a express\u00e3o l\u00f3gica retorne o valor false. Abaixo temos a refatora\u00e7\u00e3o 5 evitando a repeti\u00e7\u00e3o de partes de partes do c\u00f3digo anterior. # c sharp // Programa de nomes refatorado com while string nome , mid , last ; int contador ; // nome default nome = \"\" ; mid = \"\" ; last = \"\" ; Console . WriteLine ( \" Seja bem vindo(a)!\" ); Console . WriteLine ( \" Por favor, insira o seu nome completo.\" ); Console . WriteLine ( \" Obs. No m\u00e1ximo 3 palavras\" ); contador = 1 ; while ( contador <= 3 ) { Console . WriteLine ( $\" Palavra n\u00ba {contador} do seu nome?\" ); if ( contador == 1 ) nome = Console . ReadLine (); else if ( contador == 2 ) mid = Console . ReadLine (); else if ( contador == 3 ) last = Console . ReadLine (); contador += 1 ; }; Console . WriteLine ( \" Bem Vindo(a)!\" ); Console . WriteLine ( nome ); Console . WriteLine ( mid ); Console . WriteLine ( last ); Console . WriteLine ( \" E Volte sempre!\" ); Agora n\u00f3s temos um loop usando a express\u00e3o \"a vari\u00e1vel contador \u00e9 menor igual a 3?\" sempre que a resposta for sim, o programa perguntar\u00e1 qual a n-\u00e9sima palavra do nome da pessoa. Pode parecer que nesse exemplo o uso do loop mais complicou do que facilitou. Mas o objetivo aqui \u00e9 exercitar o uso desse operador, ent\u00e3o devemos focar em compreender como usar o while. Repeti\u00e7\u00e3o usando DO-WHILE Para a nossa sorte, o operador DO WHILE \u00e9 muito similar ao WHILE. A \u00fanica diferen\u00e7a \u00e9 que primeiro declaramos o bloco de c\u00f3digo e, no final, colocamos a condi\u00e7\u00e3o para sua execu\u00e7\u00e3o. No exemplo abaixo temos o mesmo resultado que o de cima mas usando essa outra estrutura de operador. # c sharp // Programa de nomes refatorado com do-while string nome , mid , last ; int contador ; // nome default nome = \"\" ; mid = \"\" ; last = \"\" ; Console . WriteLine ( \" Seja bem vindo(a)!\" ); Console . WriteLine ( \" Por favor, insira o seu nome completo.\" ); Console . WriteLine ( \" Obs. No m\u00e1ximo 3 palavras\" ); contador = 1 ; do { Console . WriteLine ( $\" Palavra n\u00ba {contador} do seu nome?\" ); if ( contador == 1 ) nome = Console . ReadLine (); else if ( contador == 2 ) mid = Console . ReadLine (); else if ( contador == 3 ) last = Console . ReadLine (); contador += 1 ; } while ( contador <= 3 ); Console . WriteLine ( \" Bem Vindo(a)!\" ); Console . WriteLine ( nome ); Console . WriteLine ( mid ); Console . WriteLine ( last ); Console . WriteLine ( \" E Volte sempre!\" ); Repeti\u00e7\u00e3o usando FOR Quando usamos nosso operador while, foi criada uma vari\u00e1vel contador que era incrementada a cada itera\u00e7\u00e3o at\u00e9 que o teste l\u00f3gico \"menor igual a 3\"\\ retorne false. A vantagem do operador de loop for \u00e9 que podemos fazer isso diretamente no par\u00e2metro da fun\u00e7\u00e3o. O operador de loop for recebe 3 par\u00e2metros, na ordem: condi\u00e7\u00e3o inicial da vari\u00e1vel de controle; express\u00e3o l\u00f3gica (que retorna true ou false) e, por fim, um incremento ou decremento. # c sharp // Programa de nomes refatorado com for string nome , mid , last ; int contador ; // nome default nome = \"\" ; mid = \"\" ; last = \"\" ; Console . WriteLine ( \" Seja bem vindo(a)!\" ); Console . WriteLine ( \" Por favor, insira o seu nome completo.\" ); Console . WriteLine ( \" Obs. No m\u00e1ximo 3 palavras\" ); contador = 1 ; for ( contador = 1 ; contador <= 3 ; contador ++ ) { Console . WriteLine ( $\" Qual a palavra n\u00ba {contador} do seu nome?\" ); if ( contador == 1 ) nome = Console . ReadLine (); else if ( contador == 2 ) mid = Console . ReadLine (); else if ( contador == 3 ) last = Console . ReadLine (); }; Console . WriteLine ( \" Bem Vindo(a)!\" ); Console . WriteLine ( nome ); Console . WriteLine ( mid ); Console . WriteLine ( last ); Console . WriteLine ( \" E Volte sempre!\" ); Contadores e Acumuladores Agora sabemos reduzir nossos c\u00f3digos usando 3 tipos de tokens fornecidos pelo c#. Vamos ver um pouquinho mais a respeito do atributo de contador do loop for . Um \\textbf{} contador nada mais \u00e9 do que uma vari\u00e1vel do tipo constante que receber\u00e1 a atualiza\u00e7\u00e3o do seu valor a cada loop. Se a situa\u00e7\u00e3o inicial do nosso contador for igual a 1, a cada itera\u00e7\u00e3o ele receber\u00e1 a express\u00e3o contador = contador + 1 . Podemos criar um contador diretamente no c\u00f3digo atrav\u00e9s da atribui\u00e7\u00e3o do valor pela soma. Ou, podemos usar os operadores de incremento e decremento que aprendemos anteriormente. A cada itera\u00e7\u00e3o em uma estrutura de loop, a vari\u00e1vel receber\u00e1 +1 como incremento ou -1 no caso do decremento. Podemos usar o operador de incremento tanto no bloco de c\u00f3digo de um loop quanto como par\u00e2metro. Em um for , quando colocamos o terceiro par\u00e2metro igual a contador++ , a cada itera\u00e7\u00e3o teremos +1 atribu\u00eddo ao contador. Um \\textbf{} acumulador \u00e9 muito parecido com um contador, a diferen\u00e7a \u00e9 que a cada itera\u00e7\u00e3o n\u00f3s podemos adicionar qualquer valor ao acumulador. Por exemplo, se queremos calcular a m\u00e9dia de uma turma, teremos que somar todas as notas e dividir pelo quantitativo dos alunos da turma. Para isso, podemos criar um acumulador chamado soma_notas que recebe, para cada aluno, a nota atrav\u00e9s de um comando parecido com o exemplo a baixo. # c sharp double soma_notas = 0 ; for ( n_aluno = 0 ; n_alunos <= qtd ; n_aluno ++ ) { soma_notas = soma_notas + nota }; A cada itera\u00e7\u00e3o, somamos o valor da vari\u00e1vel nota \u00e0 vari\u00e1vel soma_notas . Manipula\u00e7\u00e3o de Dados em Mem\u00f3ria Prim\u00e1ria e Secund\u00e1ria Criando e Usando Fun\u00e7\u00f5es e Procedimentos Passagem de Par\u00e2metros Manipula\u00e7\u00e3o de Arquivos em C# Bibliografia Ana Fernanda Gomes ASCENCIO; Edilene Aparecida Veneruchi de CAMPOS. Fundamentos da Programa\u00e7\u00e3o de Computadores: algoritmos, Pascal, C/C++ e Java - 2\u00aa edi\u00e7\u00e3o . S\u00e3o Paulo, SP : Pearson Education do Brasil, 2012 H. DEITEL et. Al. C#: Como Programar . S\u00e3o Paulo: Makron Books, 2003 John SHARP. Microsoft Visual C# 2013 . Grupo A, 2014 Andr\u00e9 Luiz Villar FORBELLONE, Henri Frederico EBERSP\u00c4CHER. L\u00f3gica de programa\u00e7\u00e3o: a constru\u00e7\u00e3o de algoritmos e estruturas de dados . S\u00e3o Paulo: Prentice Hall, 2005. MANZANO, Jos\u00e9 Augusto N. G; OLIVEIRA, Jayr Figueiredo de. Al goritmos: l\u00f3gica para desenvolvimento de programa\u00e7\u00e3o de computadores 28. ed. rev. e atual. S\u00e3o Paulo, SP: \u00c9rica, 2016 Sandra PUGA, Gerson RISSETTI. L\u00f3gica de Programa\u00e7\u00e3o e Estrutura de Dados: com aplica\u00e7\u00f5es em Java - 2\u00aa edi\u00e7\u00e3o . S\u00e3o Paulo : Pearson, 2017 Float possui precis\u00e3o simples e Double possui dupla precis\u00e3o. \u21a9 Isso \u00e9 muito impressionante! \u21a9 Embora a gente saiba que a radicia\u00e7\u00e3o \u00e9 uma pot\u00eancia de fra\u00e7\u00e3o. \u21a9 Se voc\u00ea n\u00e3o se lembra como resolver um problema desse, seu professor da sexta s\u00e9rie est\u00e1 rindo de voc\u00ea nesse exato minuto. \u21a9 Refatorar \u00e9 o processo de mudar o c\u00f3digo e obter o mesmo resultado no final. \u00c9 uma \u00f3tima pr\u00e1tica a ser feita. \u21a9","title":"Algoritmo e L\u00f3gica"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#assuntos","text":"L\u00f3gica de Programa\u00e7\u00e3o e Estrutura de Controle, Fun\u00e7\u00f5es e Procedimentos Conceito de Algoritmo Vari\u00e1veis Etapas de um Algoritmo e Operador de Atribui\u00e7\u00e3o Estrutura Sequencial Estrutura Condicional Estrutura de Repeti\u00e7\u00e3o Manipula\u00e7\u00e3o de Dados em Mem\u00f3ria Prim\u00e1ria e Secund\u00e1ria Criando e Usando Fun\u00e7\u00f5es e Procedimentos Passagem de Par\u00e2metros Manipula\u00e7\u00e3o de Arquivos em C# Bibliografia","title":"Assuntos"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#logica-de-programacao-e-estrutura-de-controle-funcoes-e-procedimentos","text":"","title":"L\u00f3gica de Programa\u00e7\u00e3o e Estrutura de Controle, Fun\u00e7\u00f5es e Procedimentos"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#conceito-de-algoritmo","text":"Em resumo, um algoritmo \u00e9 uma sequ\u00eancia de ordens que, se seguidas, deve gerar um resultado previsto e desejado. N\u00e3o vale muito a pena aprofundar al\u00e9m disso agora.","title":"Conceito de Algoritmo"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#variaveis","text":"Uma vari\u00e1vel \u00e9 uma posi\u00e7\u00e3o na mem\u00f3ria do computador. Isso mesmo, \u00e9 algo com endere\u00e7o definido, nada solto no universo ou obscuro dentro da m\u00e1quina. Esse dado \u00e9 gravado para posterior leitura por parte do programa que est\u00e1 sendo executado. Podemos ter como origem do dado o pr\u00f3prio programa que est\u00e1 sendo executado ou o usu\u00e1rio por meio da entrada de dados ou, ainda, a leitura de dados previamente armazenados na mem\u00f3ria do computador. Cada vari\u00e1vel possui v\u00e1rios tipos de atributos que podemos elencar na lista abaixo: Tem um endere\u00e7o na mem\u00f3ria Possui um nome de identifica\u00e7\u00e3o Armazena um valor Possui um tipo de dados: Num\u00e9rico - Inteiros e Reais (Double ou Ponto Flutuante) 1 N\u00e3o num\u00e9rico - L\u00f3gico e Caractere Arranjos - Vetores e Matrizes Arquivos etc O endere\u00e7o da mem\u00f3ria \u00e9 feita pelos endere\u00e7os que possuem apenas 2 est\u00e1gios de registro: 0 ou 1. Um bit \u00e9 exatamente essa medida de registo. 1 byte \u00e9 composto de 8bits. 1 kilobyte cont\u00e9m 1024bytes ( \\(2^{10}\\) ). 1 megabyte cont\u00e9m 1024KB ( \\(2^{20}\\) ). 1 gigabyte cont\u00e9m 1024MB ( \\(2^{30}\\) ). 1 terabyte possui 1024GB ( \\(2^{40}\\) ). Ou seja, se um computador possui 3 gigas de mem\u00f3ria RAM, ele tem 3 bilh\u00f5es de bytes como endere\u00e7os dispon\u00edveis para um registro na mem\u00f3ria 2 . Cada byte possui um endere\u00e7o \u00fanico. Na mem\u00f3ria RAM costuma-se usar a base Hexadecimal para definir os endere\u00e7os. Vamos ver isso melhor na mat\u00e9ria de Arquitetura de Computadores. Tamb\u00e9m vimos que as vari\u00e1veis possuem identificadores. Em c# existem regras para a cria\u00e7\u00e3o dos identificadores: Devem come\u00e7ar com uma letra N\u00e3o podem ter espa\u00e7os N\u00e3o podem usar uma das palavras reservadas pela linguagem \u00c9 case sensitive, ou seja, o nome \"Var\" \u00e9 diferente do nome \"var\" O identificador deve sempre ter algum sentido que permita a r\u00e1pida interpreta\u00e7\u00e3o por parte de algum leitor do c\u00f3digo fonte da aplica\u00e7\u00e3o. Isso \u00e9 fundamental para manuten\u00e7\u00e3o de c\u00f3digos produzidos por v\u00e1rias pessoas diferentes. Entretanto, devemos evitar nomes de vari\u00e1veis muito grandes. Na verdade, quanto menor o nome, mantido o sentido na leitura, melhor. Outra boa pr\u00e1tica \u00e9 usar o camelCase para vari\u00e1veis com mais de uma palavra. Esse padr\u00e3o \u00e9 bem simples: primeira palavra em min\u00fasculo e a segunda com a primeira letra em mai\u00fascula.","title":"Vari\u00e1veis"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#declaracao-de-variaveis-em-c","text":"Vamos aprender agora como declarar os 4 tipos mais simples de vari\u00e1veis: int para definir inteiros double ou float para definir n\u00fameros reais string para cadeia de caracteres bool para as vari\u00e1veis booleanas ( true ou false ) Coment\u00e1rio: c# \u00e9 uma linguagem fortemente tipada, entretanto, existe um tipo de tipagem impl\u00edcita que \u00e9 muito usado na pr\u00e1tica onde o pr\u00f3prio compilador \"interpreta\" o tipo de vari\u00e1vel. Ao longo desse microfundamento n\u00f3s vamos usar apenas os tokens de tipagem expl\u00edcita. Mas vale muito a pena a leitura da documenta\u00e7\u00e3o oficial nesse link . # c sharp static void Main ( string [] args ) { int idade , numero ; double peso , salario ; string nomePai , rua , dtNasc ; bool temCasa ; } Nesse c\u00f3digo acima temos a declara\u00e7\u00e3o de v\u00e1rias vari\u00e1veis de cada tipo. Basta colocar o tipo da vari\u00e1vel seguido do nome de cada uma delas separadas por v\u00edrgula. Coment\u00e1rio: Em c# todas as linhas precisam conter um car\u00e1cter de encerramento que \u00e9 o ponto e v\u00edrgula ; . Sem esse token, o computador vai interpretar a pr\u00f3xima linha como sendo a continua\u00e7\u00e3o da anterior.","title":"Declara\u00e7\u00e3o de Vari\u00e1veis em c#"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#etapas-de-um-algoritmo-e-operador-de-atribuicao","text":"Podemos resumir um algoritmo simples como contendo apenas 3 etapas: 1) A entrada de dados; 2) O processamento e 3) A sa\u00edda de dados. Na etapa de processamento, podemos precisar de grande criatividade e esfor\u00e7o para produzir a sa\u00edda de dados desejada. Como ferramenta para alcance desse objetivo, temos as estruturas b\u00e1sicas que s\u00e3o: Estrutura Sequencial - Usada para garantir a ordem correta dos passos Estrutura Condicional - Usada para permitir contexto ou cen\u00e1rios Estrutura de Repeti\u00e7\u00e3o - Usada para evitar repetir c\u00f3digo sequencial","title":"Etapas de um Algoritmo e Operador de Atribui\u00e7\u00e3o"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#operador-de-atribuicao","text":"Uma vez que j\u00e1 sabemos como atribuir uma vari\u00e1vel ao seu tipo, precisamos aprender a como atribuir um valor a essas vari\u00e1veis. Em c# a atribui\u00e7\u00e3o de valor \u00e9 feita do seguinte modo: # c sharp idade = 28 ; numero = 9992233 ; \u00c9 poss\u00edvel fazer 3 tipos de atribui\u00e7\u00e3o de valor para uma vari\u00e1vel: Valor fixo; Conte\u00fado de outra vari\u00e1vel e Express\u00e3o aritm\u00e9tica ou booliana. Abaixo temos 3 exemplo disso. # c sharp idade = 28 ; // Valor fixo numero = idade ; // Valor de outra vari\u00e1vel idadeNum = idade + numero ; // Valor por express\u00e3o idadeEqNum = idade == numero ; // Valor por express\u00e3o booliana Nesse ponto vale uma reflex\u00e3o. Ser\u00e1 que sempre precisamos separar as etapas de atribui\u00e7\u00e3o do tipo de dados e do valor? Ou podemos, no mesmo momento, definir o tipo de dados e o valor da vari\u00e1vel? A resposta, para nossa sorte, \u00e9 que \u00e9 poss\u00edvel em c# atribui\u00e7\u00e3o de tipo e valor ao mesmo tempo. A sintaxe fica desse modo: # c sharp int idade = 28 ; int numero = idade ; double = 2.3 ; string nome = \"bruno\" ; int idadeNum = idade + numero ; bool idadeEqNum = idade == numero ;","title":"Operador de Atribui\u00e7\u00e3o"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#saidas-de-dados","text":"Agora que fizemos esse pequeno desvio no assunto, vamos retornar para as estruturas. Por incr\u00edvel que pare\u00e7a, \u00e9 melhor a gente come\u00e7ar pelo final. A etapa de sa\u00edda de dados. Em c# temos duas maneiras de sa\u00edda de dados: # c sharp // Imprime a informa\u00e7\u00e3o e cursor fica na mesma linha Console . Write ( ' string ' ); // Imprime a info mas o curso vai pra proxima linha Console . WriteLine ( ' string ' + var1 + ' string ' ); Nesses exemplos a gente pode perceber que podemos concatenar textos e vari\u00e1veis textuais por meio do operador de soma. Al\u00e9m dessa forma, podemos fazer uso de PlaceHolders ou Interpola\u00e7\u00e3o de string como nos exemplos abaixo. # c sharp string nome = \"Bruno\" ; // Concatena\u00e7\u00e3o Console . WriteLine ( \"Meu nome \u00e9 \" + nome + \", obrigado!\" ); // PlaceHolder Console . WriteLine ( \"Meu nome \u00e9 {0}, obrigado!\" , nome ); // Interpola\u00e7\u00e3o Console . WriteLine ( $\"Meu nome \u00e9 {nome}, obrigado!\" ); Os tr\u00eas exemplos geram o mesmo resultado mas s\u00e3o consideravelmente diferentes no m\u00e9todo. Podemos usar o que for mais agrad\u00e1vel para uma leitura do c\u00f3digo e posterior manuten\u00e7\u00e3o do mesmo.","title":"Sa\u00eddas de Dados"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#entrada-de-dados","text":"Agora que sabemos como fazer nosso programa imprimir resultados, vamos aprender como inputar dados nele. Em c# podemos inserir dados com o seguinte comando: # c sharp variavel = Console . ReadLine (); O input captado por esse comando sempre retorna uma string . Mas as vezes precisamos nos certificar que o input foi feito da maneira correta. Para isso podemos manipular os dados inseridos do seguinte modo: # c sharp // Valores Inteiros variavel = int . Parse ( Console . ReaLine ()); variavel = Convert . ToInt32 ( Console . ReadLine ()); // Valores Reais variavel = double . Parse ( Console . ReadLine ()); variavel = float . Parse ( Console . ReadLine ()); variavel = Convert . ToDouble ( Console . ReadLine ()); // Valores Booleanos variavel = bool . Parse ( Console . ReadLine ()); // Valores String variavel = Console . ReadLine (); Depois que executamos um dessas maneiras de coletar os dados, \u00e9 de boa pr\u00e1tica fornecermos um output logo ap\u00f3s a entrada do dado. Isso evita aquela sensa\u00e7\u00e3o de d\u00favida se o programa est\u00e1 sendo executado ou n\u00e3o. Ou seja, \u00e9 bom sempre manter a dupla ReadLine() com o WriteLine() . O nome que damos para essa dupla \u00e9 \"Prompt\". Outra dica boa \u00e9 usar o comando Console.ReadKey() no final do programa. Isso faz com que o console aguarde alguma tecla para finalizar. Evita que a aplica\u00e7\u00e3o abra e feche sem que o user consiga enxergar o resultado do processo.","title":"Entrada de Dados"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#estrutura-sequencial","text":"Agora que sabemos como receber valores do usu\u00e1rio e como devolver nova informa\u00e7\u00e3o a partir do processamento, vamos come\u00e7ar a estudar a etapa de processamento atrav\u00e9s do estudo das estruturas sequenciais.","title":"Estrutura Sequencial"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#operadores-e-funcoes-aritmeticas","text":"Em c# n\u00f3s temos os seguintes tokens para realizar as opera\u00e7\u00f5es aritm\u00e9ticas: + Soma - Subtra\u00e7\u00e3o * Multiplica\u00e7\u00e3o / Divis\u00e3o % Resto da Divis\u00e3o inteira Al\u00e9m disso, temos a presen\u00e7a do que podemos chamar de operadores de atribui\u00e7\u00e3o combinada . Que faz a atribui\u00e7\u00e3o de valor com alguma opera\u00e7\u00e3o aritm\u00e9tica: soma += 100 \u00e9 igual a soma = soma + 100 subtracao -= 10 \u00e9 igual a subtracao = subtracao - 10 multiplica *= 2 \u00e9 igual a multiplica = multiplica * 2 divide /= 3 \u00e9 igual a divide = divide / 3 resto \\%= 2 \u00e9 igual a resto = resto / 2 N\u00e3o bastando essa grande variedade, temos os operadores de incremento e decremento : Pr\u00e9-incremento ( ++x ) - Usa x + 1 antes do processamento P\u00f3s-incremento ( x++ ) - Usa x + 1 ap\u00f3s o processamento Pr\u00e9-decr\u00e9scimo ( --x ) - Usa x - 1 antes do processamento P\u00f3s-decr\u00e9scimo ( x-- ) - Usa x -1 ap\u00f3s o processamento Essa diferen\u00e7a de pre e p\u00f3s \u00e9 importante para as estruturas de repeti\u00e7\u00e3o, porque podemos lidar com \u00edndices de tabelas que come\u00e7am com valores diferentes. Mas, no geral, devemos olhar cada caso para escolher o que usar. Existem outras opera\u00e7\u00f5es que est\u00e3o contidas em um objeto nativo chamado Math . Para fazermos potencia\u00e7\u00e3o usamos o m\u00e9todo Math.Pow() . Para fazermos raiz quadrada podemos usar Math.Sqrt() 3 .","title":"Operadores e Fun\u00e7\u00f5es Aritm\u00e9ticas"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#expressoes-aritmeticas","text":"Agora podemos juntar tudo que vimos em um programa simples de c\u00e1lculo da m\u00e9dia de 5 valores. O c\u00f3digo e o seu resultado podem ser vistos abaixo. # c sharp // Declara\u00e7\u00e3o dos tipos das vari\u00e1veis int n1 , n2 , n3 , n4 , n5 , soma ; float media ; // Input dos dados Console . WriteLine ( \"Programa para c\u00e1lculo da m\u00e9dia de 5 valores.\" ); Console . WriteLine ( \"Por favor, forne\u00e7a o primeiro n\u00famero\" ); n1 = Convert . ToInt32 ( Console . ReadLine ()); Console . WriteLine ( \"Por favor, forne\u00e7a o segundo n\u00famero\" ); n2 = Convert . ToInt32 ( Console . ReadLine ()); Console . WriteLine ( \"Por favor, forne\u00e7a o terceiro n\u00famero\" ); n3 = Convert . ToInt32 ( Console . ReadLine ()); Console . WriteLine ( \"Por favor, forne\u00e7a o quarto n\u00famero\" ); n4 = Convert . ToInt32 ( Console . ReadLine ()); Console . WriteLine ( \"Por favor, forne\u00e7a o quinto n\u00famero\" ); n5 = Convert . ToInt32 ( Console . ReadLine ()); // Processamento soma = n1 + n2 + n3 + n4 + n5 ; media = soma / 5 ; // Output dos dados Console . WriteLine ( \"Os n\u00fameros fornecidos foram:\" ); Console . WriteLine ( \"N1={0},N2={1},N3={2},N4={3},N5={4}\" , n1 , n2 , n3 , n4 , n5 ); Console . WriteLine ( \"Cuja m\u00e9dia \u00e9 igual a {0}\" , media ); Outro exemplo que podemos usar \u00e9 o do c\u00e1lculo das ra\u00edzes de uma fun\u00e7\u00e3o de segundo grau 4 . O programa abaixo recebe 3 valores e calcula as ra\u00edzes, a imagem logo ap\u00f3s nos mostra o resultado no prompt de comando. # c sharp // Programa para calcular o valor de x em uma equa\u00e7\u00e3o de segundo grau // Declara\u00e7\u00e3o das vari\u00e1veis double a , b , c , x1 , x2 ; Console . WriteLine ( \"Vamos resolver uma equa\u00e7\u00e3o do tipo ax^2 + bx + c = 0\" ); // Input das variaveis Console . WriteLine ( \"Qual o valor de a? \" ); a = Convert . ToDouble ( Console . ReadLine ()); Console . WriteLine ( \"Qual o valor de b? \" ); b = Convert . ToDouble ( Console . ReadLine ()); Console . WriteLine ( \"Qual o valor de c? \" ); c = Convert . ToDouble ( Console . ReadLine ()); x1 = ( - b + Math . Sqrt ( Math . Pow ( b , 2 ) - 4 * a * c )) / 2 * a ; x2 = ( - b - Math . Sqrt ( Math . Pow ( b , 2 ) - 4 * a * c )) / 2 * a ; // Output dos resultados Console . WriteLine ( \"Dados: a = {0}, b = {1} e c = {2}\" , a , b , c ); Console . WriteLine ( $\"Equa\u00e7\u00e3o: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0\" ); Console . WriteLine ( \"Resultado: x1 = {0} e x2 = {1}\" , x1 , x2 ); A essa altura j\u00e1 aprendemos como criar programas inteiros com as etapas de software que vimos anteriormente: input, processamento e output. Tudo isso em c#. Entretanto, no estado atual do c\u00f3digo, nossos programas n\u00e3o est\u00e3o muito competentes em se adaptar a diferentes tipos de inputs ou resultados. Um exemplo pr\u00e1tico \u00e9 que, nesse segundo programa, podemos ter inputs que retornem um resultado indesejado como podemos ver na imagem abaixo.","title":"Express\u00f5es Aritm\u00e9ticas"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#estrutura-condicional","text":"A necessidade de lidarmos com diferentes situa\u00e7\u00f5es ou contextos \u00e9 o que nos leva a estudarmos as \\textbf{} estruturas condicionais . Por meio dessas estruturas, podemos construir diferentes outputs de acordo com qualquer l\u00f3gica que implementarmos e, com isso, evitar v\u00e1rios bugs nos nossos programas.","title":"Estrutura Condicional"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#operadores-relacionais","text":"Ao lidarmos com estrutura condicionais n\u00f3s temos alguns operadores que nada mais s\u00e3o do que express\u00f5es l\u00f3gicas que retornam apenas 2 resultados poss\u00edveis: true ou false. Esses operadores s\u00e3o como \"gatilhos\"\\ que s\u00e3o usados para controle do fluxo de processamento do c\u00f3digo. Operador Opera\u00e7\u00e3o Exemplo == Igualdade n1 == n2 < Menor a < 10 > Maio b > 1 <= Menor igual c <= 2 >= Maior igual d >= 22 != Desigualdade e != 100 Na tabela acima, temos os operadores relacionais que s\u00e3o usados ao longo das estruturas condicionais simples e compostas. Tome cuidado com o operador de igualdade == e o de atribui\u00e7\u00e3o = , afinal, eles usam o sinal de igualdade mas significam coisas diferentes.","title":"Operadores Relacionais"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#condicao-simples-e-composta","text":"Em c# o comando usado para criar uma condi\u00e7\u00e3o simples \u00e9 o if . Se a condi\u00e7\u00e3o que colocarmos atrelada ao comando if retornar um true, o bloco de c\u00f3digo atribu\u00eddo a ele ser\u00e1 executar, caso contr\u00e1rio, o c\u00f3digo do bloco ser\u00e1 ignorado. # c sharp // Parte condicional no calculo da equa\u00e7\u00e3o de segundo grau delta = ( Math . Pow ( b , 2 ) - 4 * a * c ); // Output dos resultados com condi\u00e7\u00e3o if ( delta >= 0 ) { Console . WriteLine ( \"Dados: a = {0}, b = {1} e c = {2}\" , a , b , c ); Console . WriteLine ( $\"Equa\u00e7\u00e3o: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0\" ); Console . WriteLine ( $\"Delta: {delta}\" ); Console . WriteLine ( \"Resultado: x1 = {0} e x2 = {1}\" , x1 , x2 ); }; if ( delta < 0 ) { Console . WriteLine ( \"Dados: a = {0}, b = {1} e c = {2}\" , a , b , c ); Console . WriteLine ( $\"Equa\u00e7\u00e3o: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0\" ); Console . WriteLine ( $\"Delta: {delta}\" ); Console . WriteLine ( \"Resultado: X n\u00e3o possui raiz real! \" ); }; Com essa adapta\u00e7\u00e3o, nosso c\u00f3digo estar\u00e1 preparado para o caso onde o interior da raiz (que chamamos de delta) seja negativo. Mas podemos ver que o nosso c\u00f3digo ficou um pouco esquisito. Criamos dois blocos de c\u00f3digo que s\u00e3o, claramente, relacionados entre si: Se um bloco for executado, o outro n\u00e3o ser\u00e1. Para facilitar o trabalho com essas situa\u00e7\u00f5es, as linguagens de programa\u00e7\u00e3o possuem as estruturas de condi\u00e7\u00e3o compostas. Esses s\u00e3o os casos onde, se o teste l\u00f3gico retorna true, executamos um bloco, ou o outro bloco ser\u00e1 executado caso o resultado l\u00f3gico seja false. Com isso evitamos ter que criar dois testes com if . O token usado em c# para uma condi\u00e7\u00e3o com dois blocos de c\u00f3digos (ou seja, uma condicional composta) \u00e9 o if-else . Abaixo n\u00f3s reescrevemos a solu\u00e7\u00e3o anterior mas agora fazendo uso do condional composto. # c sharp // Parte condicional no calculo da equa\u00e7\u00e3o de segundo grau delta = ( Math . Pow ( b , 2 ) - 4 * a * c ); // Output dos resultados com condi\u00e7\u00e3o if ( delta >= 0 ) { Console . WriteLine ( \"Dados: a = {0}, b = {1} e c = {2}\" , a , b , c ); Console . WriteLine ( $\"Equa\u00e7\u00e3o: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0\" ); Console . WriteLine ( $\"Delta: {delta}\" ); Console . WriteLine ( \"Resultado: x1 = {0} e x2 = {1}\" , x1 , x2 ); } else { Console . WriteLine ( \"Dados: a = {0}, b = {1} e c = {2}\" , a , b , c ); Console . WriteLine ( $\"Equa\u00e7\u00e3o: (-({b}) +- Raiz(({b})^2 - 4*{a}*{c}))/2*{a} = 0\" ); Console . WriteLine ( $\"Delta: {delta}\" ); Console . WriteLine ( \"Resultado: X n\u00e3o possui raiz real! \" ); }; Agora sim nosso c\u00f3digo est\u00e1 elegante e adaptado para as duas sa\u00eddas poss\u00edveis de resultado para os inputs do usu\u00e1rio.","title":"Condi\u00e7\u00e3o Simples e Composta"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#operadores-booleanos-e-comandos-if-aninhados","text":"N\u00f3s aprendemos que o bloco de c\u00f3digo ser\u00e1 executado sempre que a express\u00e3o l\u00f3gica retornar um resultado true. Tamb\u00e9m vimos que existem os operadores relacionais que nos ajudam a construir essas express\u00f5es. Agora, vamos aprender os operadores booleanos que nada mais s\u00e3o do que os operadores l\u00f3gicos cl\u00e1ssicos ( \\(\\land, \\lor, \\neg\\) ). Operador Opera\u00e7\u00e3o Exemplo && (AND) true se tudo for true if (a > 2 && b == 1) || (OR) true se um for true if (a < 2 || b != 0) ! (NOT) false se true if (!(x==y)) Existem problemas que requerem mais de dois resultados no output. Nesse caso, n\u00e3o \u00e9 suficiente usarmos apenas os tokens de condicional composto if-else da maneira como aprendemos at\u00e9 agora. Para resolver esse problema temos a t\u00e9cnica de IF aninhados (nested) e a de IF escada (ladder). As duas formas produzem o mesmo resultado mas mudam significativamente legibilidade do nosso c\u00f3digo. Abaixo temos um exemplo de cada. # c sharp // Leadder IF if ( condicao1 ) comando1 ; else if ( condicao2 ) comando2 ; else if ( condicao3 ) comando3 ; ... else if ( condicao_n - 1 ) comando_n - 1 ; else comando_n ; # c sharp // Nested IF if ( condicao1 ) comando1 ; else if ( condicao2 ) comando2 ; else if ( condicao3 ) comando3 ; else if ( condicao4 ) comando4 ; ... else if ( condicao_n - 1 ) comando_n - 1 ; else comando_n ;","title":"Operadores Booleanos e Comandos IF Aninhados"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#o-comando-switch-e-o-operador-ternario","text":"Agora que aprendemos a lidar com v\u00e1rios casos condicionais encadeados, podemos construir solu\u00e7\u00f5es relativamente complexas com v\u00e1rias sa\u00eddas diferentes. Entretanto, quando tempos muitas situa\u00e7\u00f5es poss\u00edveis, o nosso c\u00f3digo pode ficar um pouco ruim de ser lido por outras pessoas. Pensando nessa necessidade, os criadores do c# criaram um operador que simplifica ainda mais nosso trabalho. Sim, \u00e9 isso mesmo, n\u00f3s acabamos de aprender IFs aninhados e em escada e j\u00e1 vamos aprender uma maneira melhor de fazer exatamente o que eles fazem. Se acostume com isso. Em tecnologia existem quase sempre v\u00e1rias maneiras de se chegar no mesmo resultado. O operador que \u00e9 mais indicado para lidar com v\u00e1rias situa\u00e7\u00f5es de sa\u00edda \u00e9 o switch-case . Cuja constru\u00e7\u00e3o \u00e9 bem mais leg\u00edvel que os IFs anteriores. Abaixo temos um exemplo. # c sharp // Lidando com varias condi\u00e7\u00f5es com switch/case switch ( opcao ) { case op1 : comandos1 ; break ; case op2 : comandos2 ; break ; case op3 : comandos3 ; break ; ... case op_n : comandos_n ; break ; default : // bloco que sera executado se nenhuma // das anteriores for escolhida; } \\textbf{} Coment\u00e1rio: Existem v\u00e1rias maneiras de se usar o switch. Eu n\u00e3o vou me aprofundar agora em todas elas. Mas vale muito a pena fazer uso dessa ferramenta para cen\u00e1rios de v\u00e1rias intera\u00e7\u00f5es poss\u00edveis ou m\u00faltiplas sa\u00eddas contextuais. Para finalizar o nosso estudo das estruturas condicionais, vamos aprender como trabalhar com o \\textbf{} Operador tern\u00e1rio . Esse nome \u00e9 relativo ao n\u00famero de operandos que esse comando usa (no caso, 3). # c sharp condicao ? expressao_true : expressao_false A condi\u00e7\u00e3o \u00e9 uma express\u00e3o l\u00f3gica (que usa operadores relacionais e booleanos) que s\u00f3 pode retornar true ou false. A express\u00e3o logo ap\u00f3s o ponto de interroga\u00e7\u00e3o ser\u00e1 o retorno do operador em caso de true. A express\u00e3o ap\u00f3s os dois pontos \u00e9 o retorno em caso de false. Sim, \u00e9 exatamente um caso de if-else s\u00f3 que em apenas uma linha. Como as solu\u00e7\u00f5es podem ficar muito grandes, \u00e9 sempre bom termos em mente que quanto menos linhas, mais f\u00e1cil ser\u00e1 fazer manuten\u00e7\u00e3o nos nossos programas. O operador tern\u00e1rio \u00e9 muito usado por programadores mais experientes. Abaixo temos um exemplo comparando as duas maneiras. # c sharp // Compara\u00e7\u00e3o entre if-else e operador tern\u00e1rio bool passou ; double nota ; // if-else if ( nota >= 60 ) passou = true ; else passou = false ; // operador ternario passou = nota >= 60 ? true : false // maneira 1 passou = ( nota >= 60 ) ? true : false // maneira 2 Agora podemos ver claramente a vantagem do uso do operador tern\u00e1rio.","title":"O Comando Switch e o Operador Tern\u00e1rio"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#estrutura-de-repeticao","text":"Como sabemos, ainda temos mais um tipo de estrutura para estudarmos. At\u00e9 agora, aprendemos como estruturar um c\u00f3digo sequencialmente e como criar blocos de c\u00f3digo que s\u00f3 ser\u00e3o executados se determinadas condi\u00e7\u00f5es previamente definidas forem satisfeitas. Agora, vamos aprender como evitar ter que repetir blocos de c\u00f3digos. O c# possui 3 operadores de repeti\u00e7\u00e3o: # c sharp // tipo 01 while ( condicao ) comando ; // tipo 02 do comando ; while ( condicao ); // tipo 03 for ( inicial ; expressao logica ; atualizacao ) comando ; Vamos ver um exemplo de como nosso c\u00f3digo pode ser reduzir com o uso da estrutura de repeti\u00e7\u00e3o. Primeiro, vamos ver um exemplo onde o programa recebe uma lista de 3 palavras (nome, nome do meio e sobrenome) e depois faz o print. # c sharp // Programa que recebe nome completo e // depois devolve uma mensagem de boas vindas string nome , mid , last ; Console . WriteLine ( \" Seja bem vindo(a)!\" ); Console . WriteLine ( \" Qual seu primeiro nome?\" ); nome = Console . ReadLine (); Console . WriteLine ( \" Qual seu nome do meio?\" ); mid = Console . ReadLine (); Console . WriteLine ( \" Qual seu sobrenome?\" ); last = Console . ReadLine (); Console . WriteLine ( \" Bem Vindo(a)!\" ); Console . WriteLine ( nome ); Console . WriteLine ( mid ); Console . WriteLine ( last ); Console . WriteLine ( \" E Volte sempre!\" ); Agora vamos refazer esse programa usando os 3 tokens de estrutura de repeti\u00e7\u00e3o que o c# nos d\u00e1. Vamos usar a mesma ordem em que elas foram apresentadas.","title":"Estrutura de Repeti\u00e7\u00e3o"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#os-comandos-while-do-while-e-for","text":"","title":"Os Comandos WHILE, DO WHILE e FOR"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#repeticao-usando-while","text":"A repeti\u00e7\u00e3o usando o token while \u00e9 condicionada ao resultado de uma express\u00e3o l\u00f3gica. Caso a express\u00e3o l\u00f3gica retorne true, o bloco de c\u00f3digo ser\u00e1 executado at\u00e9 o seu final. Ap\u00f3s a execu\u00e7\u00e3o, \u00e9 feita uma nova verifica\u00e7\u00e3o da express\u00e3o l\u00f3gica. O processo de loop s\u00f3 ser\u00e1 finalizado caso a express\u00e3o l\u00f3gica retorne o valor false. Abaixo temos a refatora\u00e7\u00e3o 5 evitando a repeti\u00e7\u00e3o de partes de partes do c\u00f3digo anterior. # c sharp // Programa de nomes refatorado com while string nome , mid , last ; int contador ; // nome default nome = \"\" ; mid = \"\" ; last = \"\" ; Console . WriteLine ( \" Seja bem vindo(a)!\" ); Console . WriteLine ( \" Por favor, insira o seu nome completo.\" ); Console . WriteLine ( \" Obs. No m\u00e1ximo 3 palavras\" ); contador = 1 ; while ( contador <= 3 ) { Console . WriteLine ( $\" Palavra n\u00ba {contador} do seu nome?\" ); if ( contador == 1 ) nome = Console . ReadLine (); else if ( contador == 2 ) mid = Console . ReadLine (); else if ( contador == 3 ) last = Console . ReadLine (); contador += 1 ; }; Console . WriteLine ( \" Bem Vindo(a)!\" ); Console . WriteLine ( nome ); Console . WriteLine ( mid ); Console . WriteLine ( last ); Console . WriteLine ( \" E Volte sempre!\" ); Agora n\u00f3s temos um loop usando a express\u00e3o \"a vari\u00e1vel contador \u00e9 menor igual a 3?\" sempre que a resposta for sim, o programa perguntar\u00e1 qual a n-\u00e9sima palavra do nome da pessoa. Pode parecer que nesse exemplo o uso do loop mais complicou do que facilitou. Mas o objetivo aqui \u00e9 exercitar o uso desse operador, ent\u00e3o devemos focar em compreender como usar o while.","title":"Repeti\u00e7\u00e3o usando WHILE"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#repeticao-usando-do-while","text":"Para a nossa sorte, o operador DO WHILE \u00e9 muito similar ao WHILE. A \u00fanica diferen\u00e7a \u00e9 que primeiro declaramos o bloco de c\u00f3digo e, no final, colocamos a condi\u00e7\u00e3o para sua execu\u00e7\u00e3o. No exemplo abaixo temos o mesmo resultado que o de cima mas usando essa outra estrutura de operador. # c sharp // Programa de nomes refatorado com do-while string nome , mid , last ; int contador ; // nome default nome = \"\" ; mid = \"\" ; last = \"\" ; Console . WriteLine ( \" Seja bem vindo(a)!\" ); Console . WriteLine ( \" Por favor, insira o seu nome completo.\" ); Console . WriteLine ( \" Obs. No m\u00e1ximo 3 palavras\" ); contador = 1 ; do { Console . WriteLine ( $\" Palavra n\u00ba {contador} do seu nome?\" ); if ( contador == 1 ) nome = Console . ReadLine (); else if ( contador == 2 ) mid = Console . ReadLine (); else if ( contador == 3 ) last = Console . ReadLine (); contador += 1 ; } while ( contador <= 3 ); Console . WriteLine ( \" Bem Vindo(a)!\" ); Console . WriteLine ( nome ); Console . WriteLine ( mid ); Console . WriteLine ( last ); Console . WriteLine ( \" E Volte sempre!\" );","title":"Repeti\u00e7\u00e3o usando DO-WHILE"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#repeticao-usando-for","text":"Quando usamos nosso operador while, foi criada uma vari\u00e1vel contador que era incrementada a cada itera\u00e7\u00e3o at\u00e9 que o teste l\u00f3gico \"menor igual a 3\"\\ retorne false. A vantagem do operador de loop for \u00e9 que podemos fazer isso diretamente no par\u00e2metro da fun\u00e7\u00e3o. O operador de loop for recebe 3 par\u00e2metros, na ordem: condi\u00e7\u00e3o inicial da vari\u00e1vel de controle; express\u00e3o l\u00f3gica (que retorna true ou false) e, por fim, um incremento ou decremento. # c sharp // Programa de nomes refatorado com for string nome , mid , last ; int contador ; // nome default nome = \"\" ; mid = \"\" ; last = \"\" ; Console . WriteLine ( \" Seja bem vindo(a)!\" ); Console . WriteLine ( \" Por favor, insira o seu nome completo.\" ); Console . WriteLine ( \" Obs. No m\u00e1ximo 3 palavras\" ); contador = 1 ; for ( contador = 1 ; contador <= 3 ; contador ++ ) { Console . WriteLine ( $\" Qual a palavra n\u00ba {contador} do seu nome?\" ); if ( contador == 1 ) nome = Console . ReadLine (); else if ( contador == 2 ) mid = Console . ReadLine (); else if ( contador == 3 ) last = Console . ReadLine (); }; Console . WriteLine ( \" Bem Vindo(a)!\" ); Console . WriteLine ( nome ); Console . WriteLine ( mid ); Console . WriteLine ( last ); Console . WriteLine ( \" E Volte sempre!\" );","title":"Repeti\u00e7\u00e3o usando FOR"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#contadores-e-acumuladores","text":"Agora sabemos reduzir nossos c\u00f3digos usando 3 tipos de tokens fornecidos pelo c#. Vamos ver um pouquinho mais a respeito do atributo de contador do loop for . Um \\textbf{} contador nada mais \u00e9 do que uma vari\u00e1vel do tipo constante que receber\u00e1 a atualiza\u00e7\u00e3o do seu valor a cada loop. Se a situa\u00e7\u00e3o inicial do nosso contador for igual a 1, a cada itera\u00e7\u00e3o ele receber\u00e1 a express\u00e3o contador = contador + 1 . Podemos criar um contador diretamente no c\u00f3digo atrav\u00e9s da atribui\u00e7\u00e3o do valor pela soma. Ou, podemos usar os operadores de incremento e decremento que aprendemos anteriormente. A cada itera\u00e7\u00e3o em uma estrutura de loop, a vari\u00e1vel receber\u00e1 +1 como incremento ou -1 no caso do decremento. Podemos usar o operador de incremento tanto no bloco de c\u00f3digo de um loop quanto como par\u00e2metro. Em um for , quando colocamos o terceiro par\u00e2metro igual a contador++ , a cada itera\u00e7\u00e3o teremos +1 atribu\u00eddo ao contador. Um \\textbf{} acumulador \u00e9 muito parecido com um contador, a diferen\u00e7a \u00e9 que a cada itera\u00e7\u00e3o n\u00f3s podemos adicionar qualquer valor ao acumulador. Por exemplo, se queremos calcular a m\u00e9dia de uma turma, teremos que somar todas as notas e dividir pelo quantitativo dos alunos da turma. Para isso, podemos criar um acumulador chamado soma_notas que recebe, para cada aluno, a nota atrav\u00e9s de um comando parecido com o exemplo a baixo. # c sharp double soma_notas = 0 ; for ( n_aluno = 0 ; n_alunos <= qtd ; n_aluno ++ ) { soma_notas = soma_notas + nota }; A cada itera\u00e7\u00e3o, somamos o valor da vari\u00e1vel nota \u00e0 vari\u00e1vel soma_notas .","title":"Contadores e Acumuladores"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#manipulacao-de-dados-em-memoria-primaria-e-secundaria","text":"","title":"Manipula\u00e7\u00e3o de Dados em Mem\u00f3ria Prim\u00e1ria e Secund\u00e1ria"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#criando-e-usando-funcoes-e-procedimentos","text":"","title":"Criando e Usando Fun\u00e7\u00f5es e Procedimentos"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#passagem-de-parametros","text":"","title":"Passagem de Par\u00e2metros"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#manipulacao-de-arquivos-em-c","text":"","title":"Manipula\u00e7\u00e3o de Arquivos em C#"},{"location":"nav/PUC/eixo1/algoritmos_e_logica/#bibliografia","text":"Ana Fernanda Gomes ASCENCIO; Edilene Aparecida Veneruchi de CAMPOS. Fundamentos da Programa\u00e7\u00e3o de Computadores: algoritmos, Pascal, C/C++ e Java - 2\u00aa edi\u00e7\u00e3o . S\u00e3o Paulo, SP : Pearson Education do Brasil, 2012 H. DEITEL et. Al. C#: Como Programar . S\u00e3o Paulo: Makron Books, 2003 John SHARP. Microsoft Visual C# 2013 . Grupo A, 2014 Andr\u00e9 Luiz Villar FORBELLONE, Henri Frederico EBERSP\u00c4CHER. L\u00f3gica de programa\u00e7\u00e3o: a constru\u00e7\u00e3o de algoritmos e estruturas de dados . S\u00e3o Paulo: Prentice Hall, 2005. MANZANO, Jos\u00e9 Augusto N. G; OLIVEIRA, Jayr Figueiredo de. Al goritmos: l\u00f3gica para desenvolvimento de programa\u00e7\u00e3o de computadores 28. ed. rev. e atual. S\u00e3o Paulo, SP: \u00c9rica, 2016 Sandra PUGA, Gerson RISSETTI. L\u00f3gica de Programa\u00e7\u00e3o e Estrutura de Dados: com aplica\u00e7\u00f5es em Java - 2\u00aa edi\u00e7\u00e3o . S\u00e3o Paulo : Pearson, 2017 Float possui precis\u00e3o simples e Double possui dupla precis\u00e3o. \u21a9 Isso \u00e9 muito impressionante! \u21a9 Embora a gente saiba que a radicia\u00e7\u00e3o \u00e9 uma pot\u00eancia de fra\u00e7\u00e3o. \u21a9 Se voc\u00ea n\u00e3o se lembra como resolver um problema desse, seu professor da sexta s\u00e9rie est\u00e1 rindo de voc\u00ea nesse exato minuto. \u21a9 Refatorar \u00e9 o processo de mudar o c\u00f3digo e obter o mesmo resultado no final. \u00c9 uma \u00f3tima pr\u00e1tica a ser feita. \u21a9","title":"Bibliografia"},{"location":"nav/PUC/eixo1/desenvolvimento_web/","text":"hljs.initHighlightingOnLoad(); Assuntos A Web: Evolu\u00e7\u00e3o, Padr\u00f5es e Arquitetura Hist\u00f3rico e Evolu\u00e7\u00e3o da Web W3C e os Padr\u00f5es da Web Componentes da Arquitetura da Web URI, URL e URN Protocolo HTTP Servidores Web Din\u00e2mica de Aplica\u00e7\u00f5es Web Desenvolvimento de Interfaces Web A Linguagem HTML A Linguagem CSS A Linguagem JavaScript","title":"Desenvolvimento Web Frontend"},{"location":"nav/PUC/eixo1/desenvolvimento_web/#assuntos","text":"A Web: Evolu\u00e7\u00e3o, Padr\u00f5es e Arquitetura Hist\u00f3rico e Evolu\u00e7\u00e3o da Web W3C e os Padr\u00f5es da Web Componentes da Arquitetura da Web URI, URL e URN Protocolo HTTP Servidores Web Din\u00e2mica de Aplica\u00e7\u00f5es Web Desenvolvimento de Interfaces Web A Linguagem HTML A Linguagem CSS A Linguagem JavaScript","title":"Assuntos"},{"location":"nav/PUC/eixo1/fundamentos_eng_soft/","text":"hljs.initHighlightingOnLoad(); Assuntos Conceitos e Processos de Software Defini\u00e7\u00f5es Modelos e Princ\u00edpios de Processo de Software Processos \u00c1geis Processos Prescritivos Quando usar cada Processo? Requisitos Requisitos Funcionais Requisitos N\u00e3o Funcionais Atividades e Artefatos da Engenharia de Software Atividades T\u00e9cnicas Atividades Gerenciais Testes de Software Artefatos e Templates Desenhando Processos de Software","title":"Fundamentos de Eng. de Software"},{"location":"nav/PUC/eixo1/fundamentos_eng_soft/#assuntos","text":"Conceitos e Processos de Software Defini\u00e7\u00f5es Modelos e Princ\u00edpios de Processo de Software Processos \u00c1geis Processos Prescritivos Quando usar cada Processo? Requisitos Requisitos Funcionais Requisitos N\u00e3o Funcionais Atividades e Artefatos da Engenharia de Software Atividades T\u00e9cnicas Atividades Gerenciais Testes de Software Artefatos e Templates Desenhando Processos de Software","title":"Assuntos"},{"location":"nav/PUC/eixo1/logica_comp/","text":"hljs.initHighlightingOnLoad();","title":"L\u00f3gica Computacional"},{"location":"nav/PUC/eixo1/matematica_basica/","text":"hljs.initHighlightingOnLoad();","title":"Matem\u00e1tica B\u00e1sica"},{"location":"nav/PUC/eixo1/organizacao_computadores/","text":"hljs.initHighlightingOnLoad();","title":"Organiza\u00e7\u00e3o de Computadores"},{"location":"nav/PUC/eixo1/pensamento_comp/","text":"hljs.initHighlightingOnLoad();","title":"Pensamento Computacional"},{"location":"nav/PUC/eixo1/projeto_dev_web_frontend/","text":"hljs.initHighlightingOnLoad();","title":"Projeto 1 - Web Fron-End"},{"location":"nav/setup/colors/","text":"January 17, 2023 Changing the colors Color scheme Default: light theme: theme_style: light light dark Primary color Default: black theme: colors: primary: black black blue green yellow orange purple red white Text color Default: black theme: colors: text: black black blue green yellow orange purple red white Title color Default: black theme: colors: title: black black blue green yellow orange purple red white Background color Default: white theme: colors: background: white black blue green yellow orange purple red white","title":"Colors"},{"location":"nav/setup/colors/#changing-the-colors","text":"","title":"Changing the colors"},{"location":"nav/setup/colors/#color-scheme","text":"Default: light theme: theme_style: light light dark","title":"Color scheme"},{"location":"nav/setup/colors/#primary-color","text":"Default: black theme: colors: primary: black black blue green yellow orange purple red white","title":"Primary color"},{"location":"nav/setup/colors/#text-color","text":"Default: black theme: colors: text: black black blue green yellow orange purple red white","title":"Text color"},{"location":"nav/setup/colors/#title-color","text":"Default: black theme: colors: title: black black blue green yellow orange purple red white","title":"Title color"},{"location":"nav/setup/colors/#background-color","text":"Default: white theme: colors: background: white black blue green yellow orange purple red white","title":"Background color"},{"location":"nav/setup/components/","text":"January 21, 2023 Enable and Disable Components Site Name Default: true theme: components: site_name: true true false Title Default: true theme: components: title: true true false Menu Default: true theme: components: menu: true true false Preview Default: true theme: components: preview: true true false Footer Default: true theme: components: footer: true true false","title":"Components"},{"location":"nav/setup/components/#enable-and-disable-components","text":"","title":"Enable and Disable Components"},{"location":"nav/setup/components/#site-name","text":"Default: true theme: components: site_name: true true false","title":"Site Name"},{"location":"nav/setup/components/#title","text":"Default: true theme: components: title: true true false","title":"Title"},{"location":"nav/setup/components/#menu","text":"Default: true theme: components: menu: true true false","title":"Menu"},{"location":"nav/setup/components/#preview","text":"Default: true theme: components: preview: true true false","title":"Preview"},{"location":"nav/setup/components/#footer","text":"Default: true theme: components: footer: true true false","title":"Footer"},{"location":"nav/setup/favicon/","text":"January 17, 2023 Changing the favicon theme: favicon: assets/favicon.ico","title":"Favicon"},{"location":"nav/setup/favicon/#changing-the-favicon","text":"theme: favicon: assets/favicon.ico","title":"Changing the favicon"},{"location":"nav/setup/fonts/","text":"January 17, 2023 Changing the fonts Site name style Default: normal theme: site_name_style: normal normal bold italic scratched underline overline Title style Default: bold theme: title_style: bold normal bold italic scratched underline overline","title":"Fonts"},{"location":"nav/setup/fonts/#changing-the-fonts","text":"","title":"Changing the fonts"},{"location":"nav/setup/fonts/#site-name-style","text":"Default: normal theme: site_name_style: normal normal bold italic scratched underline overline","title":"Site name style"},{"location":"nav/setup/fonts/#title-style","text":"Default: bold theme: title_style: bold normal bold italic scratched underline overline","title":"Title style"},{"location":"nav/setup/logo/","text":"January 17, 2023 Changing the logo theme: logo: assets/logo.png","title":"Logo"},{"location":"nav/setup/logo/#changing-the-logo","text":"theme: logo: assets/logo.png","title":"Changing the logo"}]}